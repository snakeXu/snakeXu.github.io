<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>张容铭-设计模式-第三篇-结构型设计模式 | 喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、外观模式外观模式:为一组复杂的子系统借口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装用来简化用户使用。当我们用如下代码为页面添加点击事件 document.onclick = funcrtion(e){    e.preventDefault();    if(e.target !== document.ge">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="张容铭-设计模式-第三篇-结构型设计模式">
<meta property="og:url" content="http://yoursite.com/2020/01/09/张容铭-设计模式-第三篇-结构型设计模式/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:description" content="一、外观模式外观模式:为一组复杂的子系统借口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装用来简化用户使用。当我们用如下代码为页面添加点击事件 document.onclick = funcrtion(e){    e.preventDefault();    if(e.target !== document.ge">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-04-30T03:19:01.119Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="张容铭-设计模式-第三篇-结构型设计模式">
<meta name="twitter:description" content="一、外观模式外观模式:为一组复杂的子系统借口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装用来简化用户使用。当我们用如下代码为页面添加点击事件 document.onclick = funcrtion(e){    e.preventDefault();    if(e.target !== document.ge">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-张容铭-设计模式-第三篇-结构型设计模式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/09/张容铭-设计模式-第三篇-结构型设计模式/" class="article-date">
  <time datetime="2020-01-09T02:07:49.000Z" itemprop="datePublished">2020-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      张容铭-设计模式-第三篇-结构型设计模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、外观模式<br>外观模式:为一组复杂的子系统借口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装用来简化用户使用。<br>当我们用如下代码为页面添加点击事件</p>
<p><pre><br>document.onclick = funcrtion(e){<br>    e.preventDefault();<br>    if(e.target !== document.getElementById(‘myinput’)){<br>        hidePageAlert();<br>    }<br>}<br>function hidePageAlert(){<br>    //…<br>}<br></pre><br>为document绑定了onclick事件，但是onclick是DOM0级事件，也就是说这种方式绑定的事件相当于为元素绑定了一个事件方法，所以如果这时团队中有人再次通过这种方式为document绑定click事件时，就相当于重新定义了一个方法，会将上面定义的click事件方法覆盖。因此我们应该用DOM2级事件处理程序提供的方法addEventListener来实现，然而你知道老版本的IE浏览器(低于IE9)是不支持这个方法的，所以你要用attachEvent，当然如果有不支持DOM2级事件处理程序的浏览器，你只能用onclick事件方法绑定事件。外观模式可以用来封装他们，兼容所有浏览器。</p>
<p><pre><br>//外观模式实现<br>function addEvent(dom,type,fn){<br>    //对于支持DOM2级事件处理程序addEventListener方法的浏览器<br>    if(dom.addEventListener){<br>        dom.addEventListener(type,fn,false);<br>    //对于不支持addEventListener方法但支持attachEvent方法的浏览器<br>    }else if(dom.attachEvent){<br>        dom.attachEvent(‘on’+type,fn);<br>    //对于不支持addEventListener方法也不支持attachEvent方法，但支持’on’+事件名称的浏览器<br>    }else{<br>        dom[‘on’+type] = fn<br>    }<br>}<br>var myInput = document.getElementById(‘myinput’);<br>addEvent(myInput,’click’,function(){<br>    console.log(‘绑定第一个事件’)<br>})<br>addEvent(myInput,’click’,function(){<br>    console.log(‘绑定第二个事件’)<br>})<br>addEvent(myInput,’click’,function(){<br>    console.log(‘绑定第三个事件’)<br>})<br></pre><br>这样我们对于支持addEventListener或者attachEvent方法的浏览器就可以放心地绑定多个事件了。另外我们发现，在一开始的代码中，IE低版本浏览器中不兼容e.preventDefault()和e.target,我们也可以通过外观模式来解决。</p>
<p><pre><br>//获取事件对象<br>var getEvent = function(event){<br>    //标准浏览器返回event,IE下window.event<br>    return event || window.event;<br>}<br>//获取元素<br>var getTarget = function(event){<br>    var event = getEvent(event);<br>    //标准浏览器下event.target,IE下event.srcElement<br>    return event.getTarget || event.srcElement<br>}<br>//阻止默认行为<br>var preventDefault = function(event){<br>    var event = getEvent(event);<br>    //标准浏览器<br>    if(event.preventDefault){<br>        event.preventDefault();<br>    //IE浏览器<br>    }else{<br>        event.returnValue = false;<br>    }<br>}<br></pre><br>然后我们可以重写开始的代码</p>
<p><pre><br>document.onclick = function(e){<br>    //阻止默认行为<br>    preventDefault(e);<br>    //获取事件源目标对象<br>    if(getTarget(e) !== document.getElementById(‘myinput’)){<br>        hideInputSug();<br>    }<br>}<br></pre><br>外观模式可以将浏览器不兼容的方法变得简单而又兼容各个浏览器，然而这只是外观模式应用的一部分，很多代码库中都是通过外观模式来封装多个功能，简化底层操作方法，比如我们简单实现获取元素的属性样式的简单方法库。</p>
<p><pre><br>//简约版属性样式方法库<br>var A = {<br>    //通过ID获取元素<br>    g:function(id){<br>        return document.getElementById(id);<br>    },<br>    //设置元素css属性<br>    css:function(id,key,value){<br>        document.getElementById(id).style[key] = value;<br>    },<br>    //设置元素的属性<br>    attr:function(id,key,value){<br>        document.getElementById(id)[key] = value;<br>    },<br>    html:function(id,html){<br>        document.getElementById(id).innerHTML = html;<br>    },<br>    //为元素绑定事件<br>    on:function(){<br>        document.getElementById(id)[‘on’+type] = fn;<br>    }<br>}<br>A.css(‘box’,’background’,’red’);   //设置css样式<br>A.attr(‘box’,’className’,’box’);   //设置class<br>A.html(‘box’,’这是新添加的内容’);     //设置内容<br>A.on(‘box’,’click’,function(){     //绑定事件<br>    A.css(‘box’,’width’,’500px’);<br>})<br></pre><br>二、适配器模式<br>适配器模式:将一个类(对象)的接口(方法或属性)转化成另外一个接口，以满足用户需求，使类(对象)之间的接口的不兼容问题通过适配器得以解决。<br>假如我们现在用公司内部开发的框架A已经写了一部分需求了，这时候发现公司内部的框架不能完全满足现在的需求，我们又引入了jQuery，那现在就有问题了，怎么解决A和jQuery的兼容，毕竟重写之前的需求并不是一个明智的决定。如果框架A和jQuery相似程度很高，那么就可以用一行代码解决问题</p>
<p><pre><br>window.A = A = jQuery;<br></pre><br>但是如果框架A与jQuery差异很大，那情况就要复杂很多了。我们这里用两个事件举例，一个是页面加载事件，一个是点击事件。</p>
<p><pre><br>//定义框架<br>var A = A || {};<br>//通过ID获取元素<br>A.g = function(id){<br>    return document.getElementById(id);<br>}<br>//为元素绑定事件<br>A.on = function(id,type,fn){<br>    //如果传递参数是字符串则以id处理，否则以元素对象处理<br>    var dom = typeof id === ‘string’?this.g(id):id;<br>    //标准DOM2级添加事件方式<br>    if(dom.addEventListener){<br>        dom.addEventListener(type,fn,false);<br>    //IE DOM2级添加事件方式<br>    }else if(dom.attachEvent){<br>        dom.attachEvent(‘on’+type,fn);<br>    //简易添加事件方式<br>    }else{<br>        dom[‘on’+type,fn];<br>    }<br>}<br>//窗口加载完成事件<br>A.on(window,’load’,function(){<br>    //按钮点击事件<br>    A.on(‘mybutton’,’click’,function(){<br>        //do something<br>    })<br>})<br></pre><br>现在，如果我们想引入jQuery来换原有的A库，该怎么做？首先g方法是通过id获取元素，所以通过$(jQuery的简写名称)方法直接获取jQuery对象然后通过get获取第一个成员即可，不过on的方法有些复杂，我们不能直接替换，因为jQuery和我们的A库在通过id获取元素时是有区别的，jQuery的id前面要加#。所以异类框架的适配器做法如下</p>
<p><pre><br>A.g = function(id){<br>    //通过jQuery获取jQuery对象，然后返回第一个成员<br>    return $(id).get(0);<br>}<br>A.on = function(id,type,fn){<br>    //如果传递参数是字符串则以id处理，否则以元素对象处理<br>    var dom = typeof id === ‘string’?$(‘#’+id):$(id);<br>    dom.on(type,fn);<br>}<br></pre><br>除此之外，适配器还有很多用途，比如方法需要传递多个参数，例如……</p>
<p><pre><br>function doSomething(name,title,age,color,size,prize){}<br></pre><br>我们记住上面的代码参数的顺序是很困难的，所以我们经常以一个参数对象的方式传入，如</p>
<p><pre><br>/<strong><br><em>obj.name:name
</em>obj.title:title<br><em>obj.age:age
</em>obj.color:color<br><em>obj.size:size
</em>obj.prize:prize
</strong>/<br>function doSomething(obj){}<br></pre><br>当调用它的时候又不知道传递的参数是否完整，如果有一些必须参数没有传入，一些参数是有默认值的等待，此时我们通常的做法是用适配器来适配传入的这个参数对象，如下</p>
<p><pre><br>function doSomething(obj){<br>    var _adapter = {<br>        name : ‘雨夜清荷’,<br>        title : ‘设计模式’,<br>        age : 24,<br>        color : ‘pink’,<br>        size : 100,<br>        prize : 50<br>    };<br>    for(var i in _adapter){<br>        _adapter[i] = obj[i] || _adapter[i];<br>    }<br>    //或者extend(_adapter,obj) 注:此时可能会多添加属性<br>    //do things<br>}<br></pre><br>对于这类对参数的适配又有衍生性，比如对数据的适配，比如这里有一个数组</p>
<p><pre><br>var arr = [‘JavaScript’,’book’,’前端编程语言’,’8月1日’];<br></pre><br>我们发现数组中每个成员代表的意义不同，所以这种数据结构语义不好，我们通常会将其适配成对象形式，比如下面这种对象数据结构</p>
<p><pre><br>var obj = {<br>    name:’’,<br>    title:’’,<br>    type:’’,<br>    time:’’<br>}<br></pre><br>我们就可以像下面这样适配</p>
<p><pre><br>function arrToObjAdapter(arr){<br>    return {<br>        name:arr[0],<br>        type:arr[1],<br>        title:arr[2],<br>        data:arr[3]<br>    }<br>}<br>var adapterData = arrToObjAdapter(arr);<br>console.log(adapterData);         //[name:’JavaScript’,type:’book’,title:’前端编程语言’,data:’8月1日’]<br></pre><br>它解决了前后端数据依赖，如果后端架构改变导致传递数据结构发生变化，前端只需要写个适配器就好了。</p>
<p><pre><br>//为简化模型，这里使用jQuery的ajax方法 理想数据是一个一维数组<br>function ajaxAdapter(data){<br>    //处理数据并返回新数据<br>    return [data[‘key1’],data[‘key2’],data[‘key3’]]<br>}<br>$.ajax({<br>    url:’someAddress.php’,<br>    success:function(data,status){<br>        if(data){<br>            //使用适配后的数据-返回的对象<br>            doSomething(ajaxAdapter(data))<br>        }<br>    }<br>})<br></pre><br>这样以后后端如果有任何数据变化，我们只需要相应的更改ajaxAdapter适配器转换格式就可以了。<br>三、代理模式<br>代理模式:由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用<br>如果我们想让跨域两端的对象之间实现通信，就需要找个代理对象来实现它们之间的通信。<br>1.代理对象一:img标签<br>img之类的标签通过src属性可以向其他域下的服务器发送请求，不过这类请求是get请求，并且是单向的，它不会有响应数据。可以用于统计，比如：一些站长平台会有对于你的页面统计项，其实现原理就是在你的页面触发一些动作的时候向站长平台发送这类img的get请求，然后它们会对你发送的请求做统计，然而你并不知道统计的相关信息。</p>
<p><pre><br>//统计代理<br>var Count = (function(){<br>    //缓存图片<br>    var _img = new Image();<br>    //返回统计函数<br>    return function(param){<br>        //统计请求字符串<br>        var str = ‘<a href="http://www.count.com/a.gif?&#39;" target="_blank" rel="noopener">http://www.count.com/a.gif?&#39;</a>;<br>        //拼接请求字符串<br>        for(var i in param){<br>            str += i + ‘=’ + param[i];<br>        }<br>        //发送统计请求<br>        _img.src = str;<br>    }<br>})()<br>Count({num:10})<br></pre><br>2.代理对象二:script标签(JSONP)<br>我们知道通过src属性可实现get请求，因此我们可以在src指向的url(请求地址)上面添加一些字段信息，然后服务器端获取这些字段，再相应地生成一份内容</p>
<p><pre><br>//前端浏览器页面<br>&lt; script type=”text/javascript” &gt;<br>//回调函数，打印出请求数据与响应数据<br>function jsonpCallBack(res,req){<br>    console.log(res,req);<br>}<br>&lt; /script &gt;<br>&lt; script type=”text/javascript” src=”<a href="http://localhost/test/jsonp.php?callback=jsonp_CallBack&amp;data=getJsonPData&quot;" target="_blank" rel="noopener">http://localhost/test/jsonp.php?callback=jsonp_CallBack&amp;data=getJsonPData&quot;</a> &gt;&lt; /script &gt;<br>&lt;?php<br>/<em>后端获取请求字段数据，并生成返回内容</em>/<br>$data = $_GET[‘data’];<br>$callback = $_GET[“callback”];<br>echo $callback.”(‘success’,’”.$data.”‘)”;<br>?&gt;<br></pre><br>3.代理对象三:代理模版<br>代理模版的解决思路是这样的:既然不同域之间互相调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问页面的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A就可以了。<br>比如我们将自己的域称为X域，另外的域称为Y域，X域中要有一个被代理页面，即A页面。在A页面中应该具备三个部分，第一个部分是发送请求的模块，如form表单提交，负责向Y域发送请求，并提供额外两组数据，其一是要执行的回调函数名称，其二是X域中代理模版所在的路径，并将target目标指向内嵌框架。第二个部分是一个内嵌框架，如iframe，负责提供第一个部分中form表单的响应目标target的指向，并将迁入X域中的代理页面作为子页面，即B页面。第三个部分是一个回调函数，负责处理返回的数据。</p>
<p><pre><br>//X域中被代理页面A<br>&lt; script type=”text/javascript” &gt;<br>function callback(data){<br>    console.log(‘成功接收数据’,data);<br>}<br>&lt; /script &gt;<br>&lt; iframe name=”proxyIframe” id=”proxyIframe” src=”” &gt;&lt; /iframe &gt;<br>&lt; form  action=”<a href="http://loacalhost/test/proxy.php&quot;" target="_blank" rel="noopener">http://loacalhost/test/proxy.php&quot;</a> method=”post” target=”proxyIframe”&gt;<br>    &lt; input type=”text” name=”callback” value=”callback” &gt;<br>    &lt; input type=”text” name=”proxy” value=”<a href="http://localhost:8080/proxy.html&quot;" target="_blank" rel="noopener">http://localhost:8080/proxy.html&quot;</a> &gt;<br>    &lt; input type=”submit” value=”提交” &gt;<br>&lt; /form &gt;<br></pre><br>其次在X域中我们也要有一个代理页面，主要负责将自己的页面URL中searcher部分的数据解析出来，如 <a href="http://www.a.com?type=1&amp;title=aa" target="_blank" rel="noopener">http://www.a.com?type=1&amp;title=aa</a> 这个URL中searcher部分指的就是?type=1&amp;title=aa 。将数据重新组装好，调用A页面里的回调函数，将组装好的数据作为参数传入父页面中定义的回调函数中并执行。</p>
<p><pre><br>//X域中被代理页面B<br>&lt; script type=”text/javascript” &gt;<br>//页面加载后执行<br>window.onload = function(){<br>    //如果不在A页面中返回，不执行<br>    if(top == self) return;<br>    //获取并解析searcher中的数据<br>    var arr = location.search.substr(1).split(‘&amp;’);<br>    //预定义函数名称以及参数集<br>    fn,args;<br>    for(var i = 0, len = arr.length, item; i &lt; len; i++){<br>        //解析searcher中的每组数据<br>        item = arr[i].split(‘=’);<br>        //判断是否为回调函数<br>        if(item[0] == ‘callback’){<br>            //设置回调函数<br>            fn = item[1];<br>        //判断是否是参数集<br>        }else if(item[0] == ‘arg’){<br>            //设置参数集<br>            args = item[1];<br>        }<br>    }<br>    try{<br>        //执行A页面中预设的回调函数<br>        eval(‘top.’+fn+’(“‘+args+’”)’);<br>    }cache(e){}<br>}<br>&lt; /script &gt;<br></pre><br>最后是Y域中的被请求的接口文件C，它的主要工作是将从X域过来的请求的数据解析并获取回调函数字段与代理模版路径字段数据，并打包返回，并将自己的Header重定向为X域的代理模版B所在路径</p>
<p><pre><br>&lt;?php<br>$proxy = $_POST[“proxy”];<br>$callback = $_POST[“callback”];<br>header(“Location: “.$proxy.”?callback=”.$callback.”&amp;arg=success”);<br>?&gt;<br>测试结果<br>控制台输出依次是<br>成功接收数据success<br></pre><br>四、装饰者模式<br>装饰者模式:在不改变原对象的基础上，通过对其进行包装拓展(添加属性或方法)使原有对象可以满足用户对更复杂需求</p>
<p><pre><br>//装饰者<br>var decorator = function(input,fn){<br>    //获取事件源<br>    var input = document.getElementById(input);<br>    //若事件源已经绑定事件<br>    if(typeof input.onclick === ‘function’){<br>        //缓存事件源原有回调函数<br>        var oldClickFn = input.onclick;<br>        //为事件源定义新的事件<br>        input.onclick = function(){<br>            //事件源原有回调函数<br>            oldClickFn();<br>            //执行事件源新增回调函数<br>            fn();<br>        }<br>    }else{<br>        //事件源未绑定事件，直接为事件源添加新增回调函数<br>        input.onclick = fn;<br>    }<br>    //做其他事情<br>}<br>//电话输入框功能装饰<br>decorator(‘tel_input’,function(){<br>    document.getElementById(‘tel_demo_text’).style.display = ‘none’;<br>})<br></pre><br>装饰器模式与适配器模式的不同:适配器模式进行拓展很多时候是对对象内部结构的重组，因此了解其自身结构是必须的，而装饰者模式对对象的拓展是一种良性循环，不用了解其具体实现，只是在外部进行了一次封装拓展，这又是对原有功能完整性的一种保护。<br>五、桥接模式<br>桥接模式:在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。<br>写代码时一定要注意对相同的逻辑做抽象提取处理，这样很重要，并且重用率也会很大，可读性更高。<br>假设我们现在有如下需求：<br>给页面上的用户信息部分添加一些鼠标滑过的特效，对于用户名，鼠标滑过直接改变背景颜色，但是用户等级、用户消息等只能改变里面的数字内容。如果作为小白，我们的代码可能是这样的</p>
<p><pre><br>var spans = document.getElemenentsByTagName(‘span’);<br>//为用户名绑定特效<br>spans[0].onmouseover = function(){<br>    this.style.color = ‘red’;<br>    this.style.background = ‘#ddd’;<br>}<br>spans[0].onmouseout = function(){<br>    this.style.color = ‘#333’;<br>    this.style.background = ‘#f5f5f5’;<br>}<br>//为等级绑定特效<br>spans[1].onmouseover = function(){<br>    this.getElementsByTagName(‘strong’)[0].style.color = ‘red’;<br>    this.getElementsByTagName(‘strong’)[0].style.background = ‘#ddd’;<br>}<br>spans[1].onmouseout = function(){<br>    this.getElementsByTagName(‘strong’)[0].style.color = ‘#333’;<br>    this.getElementsByTagName(‘strong’)[0].style.background = ‘#f5f5f5’;<br>}<br>……<br></pre><br>明显看出来，上面代码非常冗余，问题出在哪儿呢？应该对事件的回调函数再做处理——在写代码时一定要注意对相同的逻辑做抽象提取处理，这一点很重要。对于用户信息模块的每一个部分鼠标滑过与鼠标离开两个事件的执行函数有很大一部分是相似的，比如他们两个都处理每个部件中的某个元素，他们都是处理该元素的字体颜色和背景颜色。所以对于这个相似点的抽象提取是很有必要的，因此你可以创建下面这样一个函数，让它解除与事件中的this的耦合。</p>
<p><pre><br>//抽象<br>function changeColor(dom,color,bg){<br>    //设置元素的字体颜色<br>    dom.style.color = color;<br>    //设置元素的背景颜色<br>    dom.style.background = bg;<br>}<br></pre><br>剩下你要做的就是对元素绑定事件了，但是有一点你要明白，仅仅知道元素事件绑定与抽象提取的设置样式方法changeColor还是不够，你需要用一个方法将他们链接起来。那么这个方法就是桥接方法，这种模式就是桥接模式。对于事件的桥接方法，我们可以用一个匿名函数代替，否则直接将changeColor作为事件的回掉函数，那么我们刚才所做的事情就白做了，因为他们还将耦合在一起。如下面的为用户名绑定事件</p>
<p><pre><br>var spans = document.getElementByTagName(‘span’);<br>spans[0].onmouseover = function(){<br>    changeColor(this,’red’,’#ddd’)<br>}<br></pre><br>changeColor方法中dom实质上是事件回调函数中的this，那么我们想解除他们之间的耦合，我们就需要一个桥接方法——匿名回掉函数。通过这个回掉函数，我们将获取到的this传递到changeColor函数中，即可实现需求。同样对于用户名模块的鼠标移开事件用同样的方式即可。</p>
<p><pre><br>spans[0].onmouseout = function(){<br>    changeColor(this,’#333’,’#f5f5f5’)<br>}<br></pre><br>既然用户名模块的this在桥接匿名函数中获取，那么也应该是同样的道理应用在用户等级上，通过桥接函数来获取数字元素，然后传入changeColor就可以了吧。</p>
<p><pre><br>spans[1].onmouseover = function(){<br>    changeColor(this.getElementsByTagName(‘strong’)[0],’red’,’#ddd’);<br>}<br>spans[1].onmouseout = function(){<br>    changeColor(this.getElementsByTagName(‘strong’)[0],’#333’,’#f5f5f5’);<br>}<br></pre><br>桥接模式对于多维的变化也同样适用。比如我们写一个canvas跑步游戏，对于游戏中的人、小精灵、小球等一系列的实物都有动作单元，而他们的每个动作实现起来方式又都是统一的，比如人和精灵和球的运动其实就是位置坐标x和y的变化过程，球的颜色与精灵的色彩的绘制方式都相似等，这样我们可以将这些多维化部分，提取出来作为一个抽象运动单元进行保存，而当我们创建实体时，将需要的每个抽象动作单元通过桥接，链接在一起运作。这样他们之间不会相互影响并且该方式降低了他们之间的耦合</p>
<p><pre><br>//多维变量类<br>//运动单元<br>function Speed(x,y){<br>    this.x = x<br>    this.y = y<br>}<br>Speed.prototype.run = function(){<br>    console.log(‘运动起来’)<br>}<br>//着色单元<br>function Color(cl){<br>    this.color = cl;<br>}<br>Color.prototype.draw = function(){<br>    console.log(‘绘制色彩’)<br>}<br>//变形单元<br>function Shape(sp){<br>    this.shape = sp<br>}<br>Shape.prototype.change = function(){<br>    console.log(‘改变形状’)<br>}<br>//说话单元<br>function Speek(wd){<br>    this.word = wd<br>}<br>Speek.prototype.say = function(){<br>    console.log(‘书写字体’)<br>}<br></pre><br>于是我们想创建一个球类，并且他可以运动可以着色</p>
<p><pre><br>function Ball(x,y,c){<br>    //实现运动单元<br>    this.speed = new Speed(x,y);<br>    //实现着色单元<br>    this.color = new Color(c);<br>}<br>Ball.prototype.init = function(){<br>    //实现运动<br>    this.speed.run()<br>    //实现着色<br>    this.speed.dras()<br>}<br></pre><br>同样我们想创建一个人物类，他可以运动以及说话</p>
<p><pre><br>function People(x,y,f){<br>    this.speed = new Speed(x,y)<br>    this.font = new Speek(f)<br>}<br></pre><br>当然我们也可以创建一个精灵类，让他可以运动可以着色可以改变形状</p>
<p><pre><br>function Spirite(x,y,c,s){<br>    this.speed = new Speed(x,y);<br>    this.color = new Color(c);<br>    this.shape = new Shape(s);<br>}<br>Spirite.prototype.init = function(){<br>    this.speed.run();<br>    this.color.draw();<br>    this.shape.change();<br>}<br></pre><br>当我们想实现一个人物时，我们直接实例化一个人物对象，这样他就可以有用运动和说话的动作了</p>
<p><pre><br>var p = new People(10,12,16);<br>p.init();<br></pre><br>桥接模式最主要的特点是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化。由此可以看出桥接模式主要是对结构之间的解构。而前面学过的抽象工厂模式与创建者模式主要业务在于创建。通过桥接模式实现的解耦，使实现层与抽象层分开处理，避免需求的改变造成对象内部的修改，体现了面向对象拓展的开放及对修改的关闭原则，这是很有用的。当然由于侨联的添加，有时也造成开发成本的添加。有时性能上也会受影响。<br>六、组合模式<br>组合模式:又称部分-整体模式，将对象组合成树形结构以表示”部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br>需求:为强化首页用户体验，要求在用户首页添加一个新闻模块，新闻的内容是根据用户平时关注的内容挖掘的，因此有的人可能会显示文字新闻，有的人会是图片新闻，甚至有的人显示的新闻是一个直播链接，方便用户观看比赛……如果一会儿添加一条文字新闻，一会儿添加一条带有直播图标的文字新闻，一会儿添加一条图片新闻……等各种不同的新闻形式的要求。其实我们可以整理出，这些新闻大致可以分为相互独立的几种类型，而对某类新闻修改时又不会影响到其他类新闻，所以可以将每一类新闻抽象成面向对象编程中的一个类，这样日后对某类新闻修改只需针对这类新闻做相应的修改即可。而对于那些不同新闻类型的需求，我们仅需在新闻类中挑选一些组合成需要的模块，也就是说建议用组合模式来完成这个需求。<br>对于每个新闻类这个“部分”，要接口统一，在JavaScript中我们可以通过继承同一个虚拟类来实现，比如这个需求中我们可以让所有的新闻都继承一个新闻虚拟父类News，如下</p>
<p><pre><br>var News = function(){<br>    //子组件容器<br>    this.children = [];<br>    //当前组件元素<br>    this.element = null;<br>}<br>News.prototype = {<br>    init : function(){<br>        throw new Error(‘请重写你的方法’)<br>    },<br>    add : function(){<br>        throw new Error(‘请重写你的方法’)<br>    },<br>    getElement : function(){<br>        throw new Error(‘请重写你的方法’)<br>    }<br>}<br></pre><br>我们在虚拟父类的构造函数中声明了一些特权变量——虽然通常虚拟类是定义而不实现的，但是我们在虚拟类的构造函数中定义两个特权变量是因为后面的所有继承子类都要声明这两个变量，为了简化子类我们也可以将这些共有变量提前声明在父类中。<br>另外要注意，组合模式不仅仅是单层次组合，也可以是一个多层次的，比如需求中的将图片新闻和文字新闻放在一行的条件就是说，我们将组合后的整体作为一个部分，继续组合。这样你就应该在拆分整体后还要确定他们的层次关系，比如最顶层是一个新闻模块的容器，再往下面是每一行新闻成员集合，每一行还可能有新闻组合体，当然最后一层组合体里面的成员就是新闻对象了。也就是说对象的上一层是可以有子成员的，最底层中的对象是没有子成员的。组合模式中用到了继承，所以我们要把以前学过的继承相关的知识拿出来用在组合模式中，比如应用及省组合式继承，像下面这样显现新闻模块容器类。</p>
<p><pre><br>//容器类构造函数<br>var Container = function(id,parent){<br>    //构造函数继承父类<br>    News.call(this);<br>    //模块id<br>    this.id = id;<br>    //模块的父容器<br>    this.parent = parent;<br>    //构建方法<br>    this.init();<br>}<br>//寄生式继承父类原型的方法<br>inheritPrototype(Container,News);<br>//构建方法<br>Container.prototype.init = function(){<br>    this.element = document.createElement(‘ul’);<br>    this.element.id = this.id;<br>    this.element.className = ‘new-container’<br>}<br>//添加子元素方法<br>Container.prototype.add = function(child){<br>    //在子元素容器中插入子元素<br>    this.children.push(child);<br>    //插入当前组件元素树中<br>    this.element.appendChild(child.getElement());<br>    return this;<br>}<br>//获取当前元素方法<br>Container.prototype.getElement = function(){<br>    return this.element;<br>}<br>//显示方法<br>Container.prototype.show = function(){<br>    this.parent.appentChild(this.element);<br>}<br></pre><br>同样下一层级的行成员集合类以及后面的新闻组合体类实现的方式与之类似</p>
<p><pre><br>var Item = function(classname){<br>    News.call(this);<br>    this.calssname = classname || ‘’<br>    this.init();<br>}<br>inheritPrototype(Item,News);<br>Item.prototype.init = function(){<br>    this.element = document.createElement(‘li’);<br>    this.element.className = this.classname;<br>}<br>Item.prototype.add = function(child){<br>    //在子元素容器中插入子元素<br>    this.children.push(child);<br>    //插入当前组件元素树中<br>    this.element.appendChild(child.getElement());<br>    return this;<br>}<br>Item.prototype.getElement = function(){<br>    return this.element;<br>}<br>var NewsGroup = function(classname){<br>    News.call(this);<br>    this.classname = classname || ‘’;<br>    this.init()<br>}<br>inheritPrototype(NewsGroup,News);<br>NewsGroup.prototype.init = function(){<br>    this.element = document.createElement(‘div’);<br>    this.element.className = this.classname;<br>}<br>NewsGroup.prototype.add = function(child){<br>    //在子元素容器中插入子元素<br>    this.children.push(child);<br>    //插入当前组件元素树中<br>    this.element.appendChild(child.getElement());<br>    return this;<br>}<br>NewsGroup.prototype.getElement = function(){<br>    retrun this.element;<br>}<br></pre><br>上面已经把所有子成员类创建出来了，不过光有这些新闻容器类是不行的，我们还需要有更底层的新闻类，但是注意这些新闻成员类是不能拥有子成员的，但是他们继承了父类，所以对于add方法最好声明一下，比如我们创建图片新闻类。</p>
<p><pre><br>var ImageNews = function(url,href,classname){<br>    News.call(this);<br>    this.url = url || ‘’;<br>    this.href = href || ‘#’;<br>    this.classname = classname || ‘normal’;<br>    this.init();<br>}<br>inheritPrototype(ImageNews,News);<br>ImageNews.prototype.init = function(){<br>    this.element = document.crateElement(‘a’);<br>    var img = new Image();<br>    img.src = this.url;<br>    this.element.appendChild(img);<br>    this.element.className = ‘image-news’ + this.classname;<br>    this.element.href = this.href;<br>}<br>ImageNews.prototype.add = function(){}<br>ImageNews.prototype.getElement = function(){<br>    return this.element;<br>}<br></pre><br>新闻类与上面的容器类很像，也很简单吧，那么下面你把剩下的基类新闻自己动手创建一下吧</p>
<p><pre><br>var IconNews = function(text,href,type){<br>    News.call(this);<br>    this.text = text || ‘’;<br>    this.href = href || ‘#’;<br>    this.type = type || ‘video’;<br>    this.init();<br>}<br>inheritPrototype(IconNews,News);<br>IconNews.prototype.init = function(){<br>    this.element = document.createElement(‘a’);<br>    this.element.innerHTML = this.text;<br>    this.element.href = this.href;<br>    this.element.className = ‘icon ‘+ this.type;<br>}<br>IconNews.prototype.add = function(){}<br>IconNews.prototype.getElement = function(){<br>    return this.element;<br>}<br>var EasyNews = function(text,href){<br>    News.call(this);<br>    this.text = text || ‘’;<br>    this.href = href || ‘#’;<br>    this.init();<br>}<br>inheritPrototype(EasyNews,News);<br>EasyNews.prototype.init = function(){<br>    this.element = document.createElement(‘a’);<br>    this.element.innerHTML = this.text;<br>    this.element.href = this.href;<br>    this.element.className = ‘text’;<br>}<br>EasyNews.prototype.add = function(){}<br>EasyNews.prototype.getElement = function(){<br>    return this.element;<br>}<br>var TypeNews = function(text,href,type,pos){<br>    News.call(this);<br>    this.text = text || ‘’;<br>    this.href = href || ‘#’;<br>    this.type = type || ‘’;<br>    this.pos = pos || ‘left’;<br>    this.init();<br>}<br>inheritPrototype(TypeNews,News);<br>TypeNews.prototype.init = function(){<br>    this.element = document.createElement(‘a’);<br>    if(this.pos === ‘left’){<br>        this.element.innerHTML = ‘[‘+this.type+’]’+this.text;<br>    }else{<br>        this.element.innerHTML = this.text + ‘[‘+this.type+’]’<br>    }<br>    this.element.href = this.href;<br>    this.element.className = ‘text’;<br>}<br>TypeNews.prototype.add = function(){}<br>TypeNews.prototype.getElement = function(){<br>    return this.element;<br>}<br></pre><br>现在新闻类都创建了，通过add方法像一棵树一样一层一层创建新闻就可以了</p>
<p><pre><br>var news1 = new Container(‘news’,document.body);<br>news1.add(<br>    new Item(‘normal’).add(<br>        new IconNews(‘梅西不拿金球也伟大’,’#’,’video’)<br>    )<br>).add(<br>    new Item(‘normal’).add(<br>        new IconNews(‘保护强国强队用意明显’,’#’,’live’)<br>    )<br>).add(<br>    new Item(‘normal’).add(<br>        new NewsGroup(‘has-img’).add(<br>            new ImageNews(‘img/1.jpg’,’#’,’small’)<br>        ).add(<br>            new EasyNews(‘从240斤的胖子成功变型男’,’#’)<br>        ).add(<br>            new EasyNews(‘五大雷人跑步机’,’#’)<br>        )<br>    )<br>).add(<br>    new Item(‘normal’).add(<br>        new TypeNews(‘AK47不愿为费城打球’,’#’,’NBA’,’left’);<br>    )<br>).add(<br>    new Item(‘normal’).add(<br>        new TypeNews(‘火炮飚6三分创新高’,’#’,’CBA’,’right’);<br>    )<br>).show();<br></pre><br>这样创建的每一条新闻都是一个独立的个体，互不影响，避免相互间的耦合，也增强了组合后的模块的复杂性。日后不论再有什么样的需求，做相应的组合就可以轻松完成。<br>其实在页面中，组合模式更常用在创建表单上，比如注册页面可能有不同的表单提交模块。对于这些需求我们只需要有基本的个体，然后通过一定的组合即可实现。<br>对于日常我们登陆注册常用到的页面，例如：<br>用户名:<intpu type="text"> 4到6位数字或字母<br>密码:<intpu type="password">6到12位数字或密码<br>昵称:<intpu type="text"><br>状态:<intpu type="text"><br>我们如何用组合模式实现呢？我们可以模仿上面创建新闻模块那样创建基类Base，然后3个组合类FormItem、FieldsetItem、Group，以及成员类InputItem、LabelItem、SpanItem、TextItem，创建完成之后</intpu></intpu></intpu></intpu></p>
<p><pre><br>var form = new FormItem(‘FormItem’,document.body);<br>form.add(<br>    new Group().add(<br>        new LabelItem(‘user_name’,’用户名:’)<br>    ).add(<br>        new InputItem(‘user_name’);<br>    ).add(<br>        new SpanItem(‘4到6位数字或字母’)<br>    )<br>).add(<br>    new Group().add(<br>        new labelItem(‘user_password’,’密码:’)<br>    ).add(<br>        new InputItem(‘user_password’)<br>    ).add(<br>        new SpanItem(‘6到12位数字或密码’)<br>    )<br>).add(<br>    //…<br>).show();<br></pre><br>组合模式能够给我们提供一个清晰的组成结构。组合对象类通过继承同一个父类使其具有统一的方法，这样也方便了我们统一管理与使用，当然此时单体成员与组合体成员行为表现就比较一致了。这样就模糊了简单对象与组合对象的区别。有时这也是一种对数据的分级式处理。清晰而又方便我们对数据的管理与使用。<br>当然组合模式有时在实现需求上给我们带来更多的选择方式，虽然对于单体对象的实现简单而又单一，但是通过对其组合将会给我们带来更多的使用形式。<br>七、享元模式<br>享元模式:运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。<br>我们上面介绍组合模式的时候，做了一个新闻模块，可是随着内容的增多，单页面已经无法容纳所有的新闻了，所以需要采取分页显示所有的新闻。<br>如果我们不了解享元模式，我们的代码很可能是这样的</p>
<p><pre><br>var dom = null,                   //缓存创建的新闻标题元素<br>    paper = 0,                    //当前页数<br>    num = 5,                      //每页显示新闻数目<br>    i = 0,                        //创建新闻元素时保存变量<br>    len = article.length;         //新闻数据长度<br>for( ;i &lt; len;i++){<br>    dom = document.createElement(‘div’);           //创建包装新闻标题元素<br>    dom.innerHTML = article[i];                    //向元素中添加新闻标题<br>    if(i &gt;= num){                                  //默认显示第一页<br>        dom.style.display = ‘none’;                //超出第一页新闻隐藏<br>    }<br>    document.getElementById(‘container’).appendChild(dom);   //添加到页面中<br>}<br>//下一页绑定事件<br>document.getElementById(‘next_page’).onclick = function(){<br>    var div = document.getElementById(‘container’).getElementByTagName(‘div’),<br>    //获取所有新闻标题包装元素<br>    j = k = n = 0;       //j,k循环变量，n当前页显示的第一个新闻序号<br>    n = ++paper % Math.ceil(len/num) * num; //获取当前页显示的第一个新闻序号<br>    for(;j &lt; len;j++){<br>        div[j].style.display = ‘none’;     //隐藏所有新闻<br>    }<br>    for(;k &lt; 5;k++){<br>        if(div[n+k])<br>            div[n+k].style.display = ‘block’ //显示当前页新闻<br>    }<br>}<br></pre><br>我们会发现代码在IE浏览器下会有卡顿现象，因为大量相同结构的新闻同时插入页面并造成多余的开销必然会影响浏览器性能。对于相同结构造成的多余开销问题，我们可以用享元模式来解决。<br>享元模式主要还是对其数据、方法共享分离，他将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法，所以将这一部分提取出来减少开销，以提高性能。<br>在我们的案例里，新闻个体都有共同的结构，所以它们应该作为内部的数据，而‘下一页’按钮绑定的事件已经不能再抽象提取里，所以应该就是外部的方法。<br>既然这些内部的数据提取出来了，为了能使用它们，我们还需要提供一个操作方法，像下面这样:</p>
<p><pre><br>var Flyweight = function(){<br>    //已创建的元素<br>    var created = [];<br>    //创建一个新闻包装容器<br>    function create(){<br>        var dom = document.crateElement(‘div’);<br>        //将容器插入新闻列表容器中<br>        document.getElementById(‘container’).appendChild(dom);<br>        //缓存新创建的元素<br>        created.push(dom);<br>        //返回创建的新元素<br>        return dom;<br>    }<br>    return {<br>        //获取创建新闻元素方法<br>        getDiv : function(){<br>            //如果已创建的元素小于当前页元素总个数，则创建<br>            if(created.length &lt; 5){<br>                return create()<br>            }else{<br>                //获取第一个元素，并插入最后面<br>                var div = created.shift();<br>                created.push(div);<br>                return div;<br>            }<br>        }<br>    }<br>}<br></pre><br>首先，创建一个享元类，由于我们每页只能显示5条新闻，所以我们创建5个元素，保存在享元类的内部，我们可以通过享元类为我们提供的方法getDiv来获取创建的元素。内部的数据和内部的方法提取出来之后我们就要实现外部的数据和外部的方法，外部的数据就是我们要显示的所有新闻内容，每个内容都不一样，所以它们不能被共享。当然，为下一页绑定的事件是独立的，它只绑定一次。然后我们需要做两件事，第一件事情，我们需要根据新闻的内容实例化页面，第二件事情，对下一页绑定一个点击事件，显示下一页，显示过程中我们可以优化一个策略，就是如果当前页显示的新闻数据不够5条，那么我们可以在所有新闻数据中起始处获取，这样，就要求我们新闻数据的总条数大于页面显示最多的条数——5条。首先我们初始化页面。</p>
<p><pre><br>var paper = 0,<br>    num = 5,<br>    len = article.length;<br>//添加5条新闻<br>for(var i = 0;i &lt; 5;i++){<br>    if(article[i]){<br>        //通过享元类获取创建的元素并写入新闻内容<br>        Flyweight.getDiv().innerHTML = article[i];<br>    }<br>}<br></pre><br>现在生成新闻界面很简单了，我们还要给’下一页’元素绑定一个事件，像下面这样</p>
<p><pre><br>document.getElementById(‘next_page’).onclick = function(){<br>    //如果新闻内容不足5条则返回<br>    if(article.length &lt; 5){<br>        return;<br>    }<br>    var n = ++paper * num % len,  //获取当前页的第一条新闻索引<br>        j = 0;                    //循环变量<br>    //插入5条新闻<br>    for(;j &lt; 5;j++){<br>        //如果存在第n+j条则插入<br>        if(article[n+j]){<br>            Flyweight.getDiv().innerHTML = article[n+j];<br>        //否则插入起始位置第n+j-len条<br>        }else if(article[n+j-len]){<br>            Flyweight.getDiv().innerHTML = article[n+j-len];<br>        //如果都不存在则插入空字符串<br>        }else{<br>            Flyweight.getDiv().innerHTML = ‘’<br>        }<br>    }<br>}<br></pre><br>通过享元模式对页面重构之后每次操作只需要操作那5个元素，与之前需要操作几百个元素的性能相比，提高了许多。<br>组合模式还有那些用途呢？我们在面向对象编程上还是很常用的，比如说一个游戏中我们可能创建一些人、精灵等角色，那么它们都会有运动这个动作，其实这一动作在所有角色中实现的方式都是相同的。对此我们可以创建一个通用的享元类，让它可以实现横向移动以及纵向移动，举例如下：</p>
<p><pre><br>var Flyweight = {<br>    moveX : function(x){<br>        this.x = x<br>    },<br>    moveY : function(y){<br>        this.y = y<br>    }<br>}<br></pre><br>其他任何角色都可以通过继承的方式来实现这些方法，比如让人继承移动方法</p>
<p><pre><br>var Player = function(x,y,c){<br>    this.x = x;<br>    this.y = y;<br>    this.color = c;<br>}<br>Player.prototype = Flyweight;<br>Player.prototype.changeC = function(c){<br>    this.color = c<br>}<br></pre><br>让精灵继承移动的方法</p>
<p><pre><br>var Spirit = function(x,y,r){<br>    this.x = x;<br>    this.y = y;<br>    this.r = r;<br>}<br>Spirit.prototype = Flyweight;<br>Spirit.prototype.changeR = function(r){<br>    this.r = r<br>}<br></pre><br>那么我们创建一个人</p>
<p><pre><br>var player1 = new Player(5,6,’red’);<br>console.log(player1); //Player {x:5,y:6,color:’red’,moveX:function,moveY:function……}<br></pre><br>让这个人移动起来</p>
<p><pre><br>player1.moveX(6);<br>player1.moveY(7);<br>player1.changeC(‘pink’);<br>console.log(player1); //Player {x:6,y:7,color:’pink’,moveX:function,moveY:function……}<br></pre><br>我们创建一个精灵</p>
<p><pre><br>var spirit1 = new Spirit(2,3,4);<br>console.log(spirit);//Spirit {x:2,y:3,r:4,moveX:function,moveY:function……}<br></pre><br>让精灵移动起来</p>
<p><pre><br>spirit1.moveX(3);<br>spirit1.moveY(4);<br>spirit1.changeR(5);//Spirit {x:3,y:4,r:5,moveX:function,moveY:function……}<br></pre><br>于是我们可以看出，不论是游戏中的人还是游戏中的精灵都拥有了运动这一方法，这样我们就可以将本来在人物类以及精灵类中的内部方法(移动方法)提取出来，实现了公用，减少其他类重写时造成的不必要的开销，类似这样的提取在页面中也是很常见的，所以我们要善于观察提取相似可共享的数据与方法来优化我们的应用。<br>享元模式的应用目的是为了提高程序的执行效率与系统的性能。因此在大型系统开发中应用是比较广泛的，百分之一的效率提成有时可以发生质的改变。它可以避免程序中的数据重复。有时系统内存在大量对象，会造成大量内存占用，所以应用享元模式来减少内存消耗是很有必要的。不过应用时一定要找准内部状态(数据与方法)与外部状态(数据与方法)，这样你才能更合理的提取分离。当然在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑，往往会收到负效应。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/09/张容铭-设计模式-第三篇-结构型设计模式/" data-id="ckbm7ic4y0052d5xq8pw26qh3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/01/10/网易微专业福利期-2-1-JavaScript内存管理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          网易微专业福利期-2.1-JavaScript内存管理
        
      </div>
    </a>
  
  
    <a href="/2020/01/07/网易微专业-现代前端工程实践方案-解锁webpack-3-1-8-webpack的环境，webpack实战演练/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">网易微专业-现代前端工程实践方案 解锁webpack-3.1.8-webpack的环境，webpack实战演练</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/拉勾/">拉勾</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾/">拉勾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaScript异步编程/" style="font-size: 10px;">JavaScript异步编程</a> <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/函数式编程范式/" style="font-size: 10px;">函数式编程范式</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/手写Promise源码/" style="font-size: 10px;">手写Promise源码</a> <a href="/tags/拉勾/" style="font-size: 16.67px;">拉勾</a> <a href="/tags/数据结构/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 16.67px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/18/拉勾-手写Promise源码/">拉勾-手写Promise源码</a>
          </li>
        
          <li>
            <a href="/2020/06/17/拉勾-JavaScript异步编程/">拉勾-JavaScript异步编程</a>
          </li>
        
          <li>
            <a href="/2020/06/15/网易微专业-移动端APP开发工程师-移动UI框架Flutter-2-1-1-Flutter概述及开发环境/">网易微专业-移动端APP开发工程师-移动UI框架Flutter-2.1.1-Flutter概述及开发环境</a>
          </li>
        
          <li>
            <a href="/2020/06/14/拉勾-函数式编程范式/">拉勾-函数式编程范式</a>
          </li>
        
          <li>
            <a href="/2020/06/14/拉勾-函数式编程范式-5-高阶函数-函数作为参数/">拉勾-函数式编程范式-5-高阶函数-函数作为参数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>