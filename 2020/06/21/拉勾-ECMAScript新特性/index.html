<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>拉勾-ECMAScript新特性 | 喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.课程介绍这里主要是对本章节课程简单概述，就不详细记录了2.ECMAScript概述ECMAScript也是一门脚本语言，通常缩写为es，通常看作JavaScript的标准化规范。实际上JavaScript是ECMAScript的扩展语言。 ECMAScript只提供了最基本的语法，也就说约定了代码该如何编写，例如该怎么定义变量和函数以及分支、循环之类的语句。JavaScript实现了ECMAS">
<meta name="keywords" content="拉勾,ECMAScript新特性">
<meta property="og:type" content="article">
<meta property="og:title" content="拉勾-ECMAScript新特性">
<meta property="og:url" content="http://yoursite.com/2020/06/21/拉勾-ECMAScript新特性/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:description" content="1.课程介绍这里主要是对本章节课程简单概述，就不详细记录了2.ECMAScript概述ECMAScript也是一门脚本语言，通常缩写为es，通常看作JavaScript的标准化规范。实际上JavaScript是ECMAScript的扩展语言。 ECMAScript只提供了最基本的语法，也就说约定了代码该如何编写，例如该怎么定义变量和函数以及分支、循环之类的语句。JavaScript实现了ECMAS">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/2_1.png">
<meta property="og:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/10_1.png">
<meta property="og:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/21_1.png">
<meta property="og:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/28_1.png">
<meta property="og:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_1.png">
<meta property="og:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_2.png">
<meta property="og:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_3.png">
<meta property="og:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_4 .png">
<meta property="og:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/34_1.png">
<meta property="og:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/34_2.png">
<meta property="og:updated_time" content="2020-07-01T07:14:11.811Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="拉勾-ECMAScript新特性">
<meta name="twitter:description" content="1.课程介绍这里主要是对本章节课程简单概述，就不详细记录了2.ECMAScript概述ECMAScript也是一门脚本语言，通常缩写为es，通常看作JavaScript的标准化规范。实际上JavaScript是ECMAScript的扩展语言。 ECMAScript只提供了最基本的语法，也就说约定了代码该如何编写，例如该怎么定义变量和函数以及分支、循环之类的语句。JavaScript实现了ECMAS">
<meta name="twitter:image" content="https://snakexu.github.io/images/lagou/part_1/ECMAScript/2_1.png">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-拉勾-ECMAScript新特性" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/拉勾-ECMAScript新特性/" class="article-date">
  <time datetime="2020-06-21T10:12:12.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      拉勾-ECMAScript新特性
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.课程介绍<br>这里主要是对本章节课程简单概述，就不详细记录了<br>2.ECMAScript概述<br>ECMAScript也是一门脚本语言，通常缩写为es，通常看作JavaScript的标准化规范。实际上JavaScript是ECMAScript的扩展语言。 ECMAScript只提供了最基本的语法，也就说约定了代码该如何编写，例如该怎么定义变量和函数以及分支、循环之类的语句。JavaScript实现了ECMAScript的语言标准并且在这个基础之上实现了一些扩展，使得我们可以在浏览器环境中操作DOM和BOM，在node环境中可以做读写文件之类的操作。总之，浏览器环境中的JavaScript就是ECMAScript和webAPI(也就是我们所说的DOM和BOM)。在node环境中的JavaScript就是ECMAScript和node环境提供的API(fs,net…)。JavaScript语言本身指的就是ECMAScript。从2015年ECMAScript就保持着每年一个大版本的迭代，导致JavaScript这门语言本身变得越来越高级，越来越便捷。下图是目前为止所有ECMAScript的标准名称和版本号、发行时间<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/2_1.png"><br>其中ES2015是一个比较重要的点，也是从2015开始按照年份命名，由于一下子没适应从之前的版本号命名变成年份命名，所以ES2015也被称为ES6。<br>3.ES2015概述<br>ES2015也可以叫做ES6，可以说是新时代ECMAScript标准的代表版本——相比上一个版本变化比较大，自此命名规则发生变化。有人喜欢用ES6泛指ES6之后所有的新标准，例如有人说使用ES6之中的async/await，但是实际上async/await是ES2017中制定的新标准。所以需要注意分辨资料中的ES6是特指还是泛指。如果可以，建议阅读ES2015完整语言规格文件，因为包含了新特性/新特性之后的所有语言标准规范。这是链接<a href="https://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">https://www.ecma-international.org/ecma-262/6.0/</a><br>本章节主要介绍ES5.1基础之上的变化，并且主要介绍一些变化大/值得我们单独了解的新特性。主要归为4类:<br>·解决原有语法上的一些问题/不足(如let、const的块级作用域)<br>·对原有语法进行增强(如解构、默认值)<br>·全新的对象/全新的方法/全新的功能(promise、proxy等)<br>·全新的数据类型/数据结构(symbol/set等)<br>4.ES2015准备工作<br>可以使用node环境，也可以使用最新版本的chrome浏览器，老师用的node版本为12.13.0。同时还需要nodemon的小工具，修改完代码后自动执行<br>5.ES2015 let与块级作用域<br>作用域-代码中某个成员能够起作用的范围，在ES2015之前，es只有两种类型的作用域，分别是<br>·全局作用域<br>·函数作用域<br>在ES2015中新增了一个<br>·块级作用域<br>块——在代码中用花括号包裹起来的范围。以前块没有独立作用域</p>
<pre>
for(var i=0; i < 3; i++){
    for(var i=0; i < 3; i++){
        console.log(i)
    }
    console.log('内层结束 i = '+i)
}
</pre>
执行结果
//0
//1
//2
//内层结束 i = 3
造成以上执行结果的原因是:外层声明了i过后，内层再次声明了这个变量，而且都是使用var去声明变量的，也就是说并不是一个块级作用域内的成员，而是全局成员，那么内层声明i就会覆盖掉之前声明的i，内层循环结束后，i=3，那么外层拿到的i也就是i=3，不满足外层循环的条件，自然就不会循环了。如果把var换成let，那么就能解决我们遇到的这个问题，因为let有块级作用域。但是我们这里不鼓励这种同名变量，对于以后程序的理解有很大麻烦。
在我们循环注册事件时，在事件的处理函数中，要访问循环的计数器，这种情况下，以前机会出现一些问题
<pre>
var elements = [{},{},{}]
for(var i=0; i < elements.length;i++){
    elements[i].onclick = function(){
        console.log(i)//获取的是外层的i，在执行完后，无论从哪里调用，i的值都已经是3了
    }
}
elements[0].onclick()//3
elements[1].onclick()//3
elements[2].onclick()//3
</pre>
通过闭包解决这个问题——借助函数作用域摆脱全局作用域所产生的影响
<pre>
var elements = [{},{},{}]
for(var i=0; i < elements.length;i++){
    elements[i].onclick = (function(){
        console.log(i)
    })(i)
}
elements[0].onclick()//0
elements[1].onclick()//1
elements[2].onclick()//2
</pre>
借助let的块级作用域解决问题
<pre>
var elements = [{},{},{}]
for(let i=0; i < elements.length;i++){
    elements[i].onclick = function(){
        console.log(i)
    }
}
elements[0].onclick()//0
elements[1].onclick()//1
elements[2].onclick()//2
</pre>
其实在上面代码中本质也是闭包的机制， onclick执行的时候，循环已经结束，实际的i已经被销毁了，通过闭包的机制才能拿到相应的i
<pre>
for(let i=0; i < elements.length;i++){
    let i = 'foo'
    console.log(i)//得到三次foo
}
</pre>
上面代码表明两个i没有相互影响，没有在同一个作用域当中。如果这样不好理解，那我们把上面的代码拆解开，用if的方式去演示
<pre>
let i = 0;
if(i < 3){

    let i = 'foo'
    console.log(i)
}
i++
if(i < 3){
    let i = 'foo'
    console.log(i)
}
i++
if(i < 3){
    let i = 'foo'
    console.log(i)
}
i++
</pre>
上面代码模拟了循环的完整过程
另外let不会像var一样发生变量提升的情况，至于为什么不继续用var升级而改用let，主要是考虑到很多项目如果这样升级势必造成影响。
6.ES2015 const
定义一个恒量/常量，在let的基础上多了一个"只读"特性，即变量声明之后不可以再修改
<pre>
const name = "zce"
name = "jack"//报错
</pre>
声明的同时要赋值
<pre>
const name
name = "zce"//报错
</pre>
其实这里说的声明的成员不能被修改，指的是不允许在声明过后重新指向一个内存地址，并不是说不允许修改恒量中的成员
<pre>
const obj = {}
obj.name = "zce"//不报错，没有修改obj指向的内存地址，修改了内存地址空间的数据
obj = {}//报错，因为重新为obj指了一个新的地址
</pre>
老师的个人最佳实践是不用var(比如先使用后定义并不是一个好的编程习惯)，主要用const(更明确代码中的成员是否会被修改)，配合let定义必须要修改的值
7.ES2015数组的解构
<pre>
const arr = [100,200,300]
const [foo,bar,baz] = arr
console.log(foo,bar,baz) //100,200,300
//或者如果只想获取第三个成员
const [,,baz] = arr // 300
//提取从当前位置往后的所有成员
const [foo,...rest] = arr //...rest的用法只能在最后一个位置使用
console.log(rest) //[200,300]
//解构成员数组长度小于被解构数组长度，会从前到后提取
const [foo,bar] = arr
console.log(foo,bar); //100,200
//如果解构成员长度大于数组长度，提取到的是undefined
const [foo,bar,baz,more] = arr
console.log(more)//undefined
//如果需要给提取到的下标设置默认值
const [foo,bar,baz,more = 'defalut value'] = arr
console.log(bar,more)//200"defalut value"
</pre>
举例用到解构的好处
<pre>
const path = "/foo/bar/baz";
//const tmp = path.split('/');
//const rootdir = tmp[1]//这种方案需要多用到一个中间变量
const [,rootdir] = path.split('/')
console.log(rootdir)
</pre>
8.ES2015对象的解构
对象的解构和数组的解构很相似，不同之处在于对象没有下标，我们通过变量解构
<pre>
const obj = { name:'zce',age:18}
const { name } = obj
console.log(name)
const { age } = obj
console.log(age)
</pre>
没有匹配到的成员值为undefined，也可以设置默认值。在对象中我们解构的变量名同时用来匹配被解构对象当中的属性名，所以如果当前作用域中有同名的成员就会产生冲突
<pre>
const obj = { name:'zce',age:18}
const name = 'tom'
const { name } = obj
console.log(name)//报错
</pre>
解决的方式是重命名
<pre>
const obj = { name:'zce',age:18}
const name = 'tom'
const { name:objName = 'jace' } = obj//jack为设置默认值
console.log(objName)//zce
</pre>
应用场景的例子
<pre>
const { log } = console
log('foo')
log('bar')
</pre>
简化了代码的编写，减小了代码整体的体积
9.ES2015模版字符串
<pre>
const str = `hello es2015,this is a \`string\``
console.log(str)//hello es2015,this is a `string`
const str1 = `hello es2015,
this is a \`string\``//支持换行
const name = 'tom' 
//${可以嵌入任何标准的js语句}，例如变量
const msg = `hey,${name}---${1+2}---${Math.random()}`//hey,tom---3---0.2061239309540519
</pre>
10.ES2015带标签的模版字符串
<pre>
const str = tag`hello world`//tag是一个标签，是一个特殊的模版字符串函数，这里没有tag这个函数，所以这里会报错
const str1 = console.log`hello world`//console.log作为模版字符串的标签//['hello','world']
</pre>
为什么打印的是数组呢？我们一步步探寻
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings){
    console.log(strings)
}
const result = myTagFunc`hey,${name} is a ${gender}`
</pre>
<img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/10_1.png">
上面打印的数组就是我们模版字符串内容分割过后的结果，模版字符串中可能有嵌入的表达式，所以数组就是按照表达式分割过后的静态内容，所以是数组。除了数组以外，这个函数还可以接收所以在模版字符串中出现的函数表达式的返回值。
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    console.log(strings,name,gender)
}
const result = myTagFunc`hey,${name} is a ${gender}`//["hey,", " is a ", "", raw: Array(3)] "tom" true
</pre>
函数的返回值就是带标签的模版字符串对应的返回值
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    //console.log(strings,name,gender)
    return '123'
}
const result = myTagFunc`hey,${name} is a ${gender}`//123
</pre>
如果想返回正常的返回值
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    return strings[0]+name+strings[1]+gender+strings[2]
}
const result = myTagFunc`hey,${name} is a ${gender}`
console.log(result)//hey,tom is a true
</pre>
标签函数的作用就是对模版字符串进行加工
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    const sex = gender ? 'man' : 'woman'
    return strings[0]+name+strings[1]+sex+strings[2]
}
const result = myTagFunc`hey,${name} is a ${gender}`
console.log(result)//hey,tom is a man
</pre>
11.ES2015字符串的扩展方法
·includes()
·startsWith()
·endsWith()
<pre>
const message = 'Error:foo is not defined.'
console.log(message.startsWith('Error'))//true
console.log(message.endsWith('.'))//true
console.log(message.includes('foo'))//true
</pre>
12.ES2015参数默认值
过去是通过逻辑参数来设置默认值
<pre>
function foo(enable){
    enable = enable || true
    console.log('foo invoked - enable:')
    console.log(enable)
}
foo(true)
//foo invoked - enable:
//true
</pre>
但是上面代码有个问题，就是如果传入的是false，会引起错误，所以我们不要使用短路设置默认值
<pre>
function foo(enable){
    enable = enable === undefined ? true : enable
    console.log('foo invoked - enable:')
    console.log(enable)
}
foo(true)
//foo invoked - enable:
//true
</pre>
而有了参数默认值新功能过后，这一切都会变得简单的多
<pre>
function foo(enable = true){
    console.log('foo invoked - enable:')
    console.log(enable)
}
foo(false)
//foo invoked - enable:
//false
</pre>
如果有多个参数，那么带有默认值的参数一定要放在参数列表的最后，因为参数是按照次序传递的，如果有参数的默认值不在最后面的话，默认值将无法正常工作
13.ES2015剩余参数
<pre>
function foo(...args){
    console.log(args)
}
foo(1,2,3,4 )//[1, 2, 3, 4]
</pre>
因为接收的是剩余的所有参数，所以只能出现在参数列表的最后一位，且只能出现一次
14.ES2015展开数组
把数组当中的每一个成员按照次序传递
<pre>
const arr = ['foo','bar','baz'];
console.log(...arr)//foo bar baz
</pre>
15.ES2015箭头函数
<pre>
const inc = n => n+1
console.log(inc(100))
</pre>
对比一下普通函数，会发现箭头函数使我们的代码更简短更易读
<pre>
const arr = [1,2,3,4,5,6,7]
arr.filter(function(item){
    return itme % 2
})
arr.filter(item => item % 2 )
</pre>
16.ES2015箭头函数与this
箭头函数不会改变this的指向
<pre>
const person = {
    name : 'tom',
    sayHi : function(){
        console.log(`hi, my name is ${this.name}`)
    }
}
person.sayHi()//hi, my name is tom
</pre>
对比上面的代码，我们把sayHi方法改变为箭头函数
<pre>
const person = {
    name : 'tom',
    sayHi : () => {
        console.log(`hi, my name is ${this.name}`)
    }
}
person.sayHi()//hi, my name is undefined
</pre>
这种特性可以解决一些问题
<pre>
const person = {
    name : 'tom',
    sayHi : () => {
        console.log(`hi, my name is ${this.name}`)
    },
    // sayHiAsync:function(){
    //      const _this = this //我们要拿到this的指向
    //     setTimeout(function(){
    //         console.log(_this.name)
    //     },1000)
    // }//这里是ES5的方法
    sayHiAsync:function(){
        setTimeout(() => {
            console.log(_this.name)
        })
    }
}
person.sayHiAsync()
</pre>
17.ES2015对象字面量的增强
<pre>
const bar = '123'
const obj = {
    foo:123,
    // bar:bar,//传统方式
    bar,
    // method:function(){
        // console.log('method111')
    // }//传统方式
    method(){
        console.log('method111')
        console.log(this)
    },
    //ES2015动态添加变量属性的方法
    [Math.random()]:123,//计算属性名，表达式的执行结果作为属性的属性名
}
console.log(obj)//{foo: 123, bar: "123", method: ƒ}
console.log(obj.method())//{foo: 123, bar: "123", method: ƒ}
obj[Math.random()] = 123//过去动态添加变量属性的方法 
</pre>
18.ES2015 Object.assign
将多个源对象的属性复制到一个目标对象中，如果对象中有相同的属性，源对象中的属性会覆盖掉目标对象中的属性(从源对象中取，往目标对象中放)
<pre>
const source1 = {
    a:123,
    b:123
}
const target = {
    a:456,
    c:456
}
const result = Object.assign(target,source1)
// console.log(result)//{a: 123, c: 456, b: 123}
// console.log(target)//{a: 123, c: 456, b: 123}
// console.log(result === target)//true
const source2 = {
    b:789,
    d:789
}
const result = Object.assign(target,source1,source2)
console.log(result)//{a: 123, c: 456, b: 789, d: 789}
console.log(target)//{a: 123, c: 456, b: 789, d: 789}
console.log(result === target)//true
</pre>
本质就是用源对象中的属性覆盖目标对象中的属性，用法举例
<pre>
function func(obj){
    obj.name = 'func obj'
    console.log(obj)//{name: "func obj"}
}
const obj = { name : "global obj"}
func(obj)
console.log(obj)//{name: "func obj"}
</pre>
在上面代码中如果在函数内部直接修改对象参数的属性，外界对应的对象也会发生变化，如果只想在函数内部修改属性
<pre>
function func(obj){
    const funcObj = Object.assign({},obj)
    funcObj.name = 'func obj'
    console.log(funcObj)//{name: "func obj"}
}
const obj = { name : "global obj"}
func(obj)
console.log(obj)//{name: "global obj"}
</pre>
19.ES2015 Object.is
<pre>
console.log(
// 0 === false //false
// 0 == false  //true
// NaN === NaN //false,过去认为NaN是一种无限可能的值，所以认为两个NaN不相等
// +0 === -0   //true
//针对NaN!==NaN和+0===-0两种不符合我们日常需求的运算，我们可以用Object.is
// Object.is(NaN,NaN) //true
Object.is(+0,-0) //false
)
</pre>
虽然Object.is在一些地方很好用，但是日常开发还是建议使用===和==运算符
20.ES2015 Proxy
如果我们要监视某个对象的读写，我们需要Object.defineProperty这样的方法来为我们的对象添加属性，这样我们就能捕获对象属性的读写过程。这样的方法使用的非常广泛，比如vue3.0之前就是使用的这样的方法完成双向数据绑定。在ES2015中设计了Proxy类型，为对象设置访问代理器的。相对于Object.defineProperty，proxy功能更为强大使用起来也更为方便。
<pre>
const person = {
    name:'zce',
    age:20
}
const personProxy = new Proxy(person,{
    get(target,prototype){
        console.log(target,prototype);//{name: "zce", age: 20} "name"
        return 100
    },
    set(){}
})
console.log(personProxy.name) //100
</pre>

<pre>
const person = {
    name:'zce',
    age:20
}
const personProxy = new Proxy(person,{
    get(target,prototype){
        return prototype in target ? target[prototype] : 'default'
    },
    set(){}
})
console.log(personProxy.name) //zce
console.log(personProxy.xxx) //default
</pre>

<pre>
const person = {
    name:'zce',
    age:20
}
const personProxy = new Proxy(person,{
    get(target,prototype){
        return prototype in target ? target[prototype] : 'default'
    },
    set(target, prototype, value){
        console.log(target, prototype, value)//{name: "zce", age: 20} "gender" true
    }
})
personProxy.gender = true
</pre>

<p><pre><br>const person = {<br>    name:’zce’,<br>    age:20<br>}<br>const personProxy = new Proxy(person,{<br>    get(target,prototype){<br>        return prototype in target ? target[prototype] : ‘default’<br>    },<br>    set(target, prototype, value){<br>        if(prototype === ‘age’){<br>            if(!Number.isInteger(value)){<br>                throw new TypeError(<code>${value} is not an int</code>)<br>            }<br>        }<br>        target[prototype] = value<br>    }<br>})<br>personProxy.age = ‘aaa’//报错 aaa is not an int<br>personProxy.gender = true<br></pre><br>21.ES2015 Proxy对比defineProperty<br>21-1.Object.defineProperty只能监视到对象属性的读写，proxy能监视到更多对象操作：比如proxy可以监视到delete操作或对对象中方法的调用等</p>
<p><pre><br>const person = {<br>    name:’zce’,<br>    age:20<br>}<br>const personProxy = new Proxy(person,{<br>    deleteProperty(target,prototype){<br>        console.log(‘delete’,prototype);//delete age<br>        delete target[prototype]<br>    }<br>})<br>delete personProxy.age<br>console.log(person)//{name: “zce”}<br></pre><br>下图列举了proxy可以监视的对象的操作<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/21_1.png"><br>21-2.Proxy更好的支持数组对象的监视<br>以往通过Object.defineProperty监视数组的操作往往通过重写数组的操作方法来实现(通过自定义的方法覆盖掉数组原型上的操作)</p>
<p><pre><br>const list = []<br>const listProxy = new Proxy(list,{<br>    set(target, prototype, value){<br>        console.log(‘set’,prototype,value)<br>        target[prototype] = value<br>        return true//表示设置成功<br>    }<br>})<br>listProxy.push(100)<br>//set 0 100<br>//set length 1<br></pre><br>21-3.Proxy是以非侵入的方式监管了对象的读写<br>对一个已经定义好的对象，不需要对对象本身进行任何操作就可以监视到它内部成员的读写，而Object.defineProperty需要我们通过特定的方式单独去定义对象中的需要被监视的属性，对已经存在的对象，我们需要做很多额外的操作</p>
<p><pre><br>const person = {}<br>Object.defineProperty(person,’name’,{<br>    get(){<br>        console.log(‘name 被访问’)<br>        return person._name<br>    },<br>    set(value){<br>        console.log(‘name 被设置’)<br>        person._name = value<br>    }<br>})<br>Object.defineProperty(person,’age’,{<br>    get(){<br>        console.log(‘age 被访问’)<br>        return person._age<br>    },<br>    set(value){<br>        console.log(‘age 被设置’)<br>        person._age = value<br>    }<br>})<br>person.name = ‘jack’<br>console.log(person.name)<br></pre><br>22.ES2015 Reflect<br>统一的对象操作，是一个静态类，也就是说不能通过new去实例化一个对象，只能调用静态类中的一些静态方法(例如Reflect.get())。Relect内部封装了一系列对对象底层的操作，一共13个(定义了14个，但是其中一个已经废弃掉了)，仔细看这13个方法的方法名与Proxy对象中的处理对象方法成员是一致的，相当于是Proxy处理对象方法的默认实现，如果觉得这句话不好理解，可以通过下面的例子理解。</p>
<p><pre><br>const obj = {<br>    foo:’123’,<br>    bar:’456’<br>}<br>const proxy = new Proxy(obj,{<br>    get(target,property){<br>        console.log(‘watch logic~’)<br>        return Reflect.get(target,property)<br>    }<br>})<br>console.log(proxy.foo)//123<br></pre><br>Reflect的主要意义在于提供了一套统一的用于操作对象的API</p>
<p><pre><br>const obj = {<br>    foo:’123’,<br>    bar:’456’<br>}<br>//console.log(‘name’ in obj)//传统判断对象属性是否存在<br>//console.log(delete obj[‘age’])//传统删除对象属性<br>//console.log(Object.keys(obj))//传统遍历对象属性<br>console.log(Reflect.has(obj,’name’))//判断对象属性是否存在<br>console.log(Reflect.deleteProperty(obj,’age’))//删除对象属性<br>console.log(Reflect.ownKeys(obj))//获取对象中所有属性名<br></pre><br>23.ES2015 Promise<br>一种更优的异步编程解决方案，解决了传统异步编程中回调函数嵌套过深的问题<br>24.ES2015 class类<br>从前定义一个类，我们要通过函数、原型去实现</p>
<p><pre><br>function Person(name){<br>    this.name = name<br>}<br>Person.prototype.say = function(){<br>    console.log(<code>hi, my name is ${this.name}</code>)<br>}<br></pre><br>现在我们用class去实现</p>
<p><pre><br>class Person{<br>    constructor(name){<br>        this.name = name<br>    }<br>    say(){<br>        console.log(<code>hi, my name is ${this.name}</code>)<br>    }<br>}<br>const p = new Person(‘tom’)<br>p.say()<br></pre><br>25.ES2015静态方法<br>在类中通常有实例方法和静态方法，实例方法就是通过构造的实例对象去调用，静态方法是通过类型本身去调用。以前实现静态方法就是在构造函数对象去挂载方法来实现，因为在js中函数也是对象，可以添加一些方法成员。ES2015中新增添加静态成员的static关键词</p>
<p><pre><br>class Person{<br>    constructor(name){<br>        this.name = name<br>    }<br>    say(){<br>        console.log(<code>hi, my name is ${this.name}</code>)<br>    }<br>    static create(name){<br>        return new Person(name)<br>    }<br>}<br>const tom = Person.create(‘tom’)<br>tom.say()//hi, my name is tom<br></pre><br>因为静态方法是在当前类中定义的，所以在静态方法内部，this不会指向某一个实例对象而是当前的类型<br>26.ES2015 类的继承<br>通过继承的特性我们就能抽象出来相似的类型之间重复的地方，在ES2015之前大多数情况我们都会通过原型的方式实现继承，在ES2015专门出现了用于继承的关键词extends</p>
<p><pre><br>class Person{<br>    constructor(name){<br>        this.name = name<br>    }<br>    say(){<br>        console.log(<code>hi, my name is ${this.name}</code>)<br>    }<br>}<br>class Student extends Person{<br>    constructor(name,number){<br>        super(name)<br>        this.number = number<br>    }<br>    hello(){<br>        super.say()<br>        console.log(<code>my school number is ${this.number}</code>)<br>    }<br>}<br>const s = new Student(‘jack’,100)<br>s.hello()<br>//hi, my name is jack<br>//my school number is 100<br></pre><br>extends继承比原型继承更方便更清楚一些<br>27.ES2015 Set<br>ES2015提供的全新的数据结构，可以把它理解为集合，与传统的数组非常类似，不过set内部的成员不允许重复，也就是说每一个值在同一个set内部是唯一的。它是一个类型，我们通过用这个类型构造的实例就能用来存放不重复的数据，可以通过集合的add方法往集合中添加数据。由于add方法可以返回集合对象本身，我们可以链式调用，如果我们用add添加了之前已经存在的值，那么这个值就会被忽略掉。想要遍历集合当中的数据，我们可以用forEach方法，也可以通过for…of…。可以通过size属性获取整个集合的长度</p>
<p><pre><br>const s = new Set()<br>s.add(1).add(2).add(3).add(4).add(2)<br>console.log(s)//Set {1,2,3,4}<br>s.forEach(i =&gt; console.log(i))<br>//1<br>//2<br>//3<br>//4<br>for(let i of s){<br>    console.log(i)<br>}<br>//1<br>//2<br>//3<br>//4<br>console.log(s.size)//4<br>console.log(s.has(100))//false，判断集合中是否存在某个特定的值<br>console.log(s.delete(3))//删除集合中某个指定的值，删除成功的话返回true<br>s.clear()//清楚当前集合中全部的内容<br>console.log(s)//Set {}<br></pre><br>最常见的应用场景就是为数组中的元素去重</p>
<p><pre><br>const arr = [1,2,1,3,1,4]<br>const result = new Set(arr)<br>console.log(result)//Set { 1, 2, 3, 4 }<br>//可以用Array.from/[…展开]把Set再次转化成数组<br>const result1 = Array.from(new Set(arr))//[ 1, 2, 3, 4 ]<br>const result2 = […new Set(arr)]//[ 1, 2, 3, 4 ]<br></pre><br>28.ES2015 Map<br>与对象非常相似，本质上都是键值对的集合，但是对象中的键只能是字符串类型，所以说存放复杂数据结构时会有一些问题。有人说我也可以用其他类型的数据做为对象的键，这里我们一起来尝试一下</p>
<p><pre><br>const obj={}<br>obj[true] = ‘value’<br>obj[123] = ‘value’<br>obj[{a:1}] = ‘value’<br>console.log(Object.keys(obj))//[ ‘123’, ‘true’, ‘[object Object]’ ]<br></pre><br>从上面打印结果来看，我们设置的布尔/对象/数字 类型的非字符串类型的键，都被内部toString的结果作为键。看上面的打印结果，我们应该能想到一些问题，设想我们用对象存储学生的考试成绩，假定我们用对象存储每个学生的考试成绩。如果我们用学生对象作为键，那不管每个对象键中的属性有何不同，但是toString的结果都是一样的，就没有办法做到区分</p>
<p><pre><br>console.log(obj[{}])//value<br>console.log(obj[‘[object Object]’])//value<br></pre><br>现在我们明白了问题的所在，Map就是为了解决这样的问题。Map才能算严格意义上的键值对的集合，用来去映射两个任意类型数据之间的关系</p>
<p><pre><br>const m = new Map()<br>const tom = { name:’tom’ }<br>m.set(tom,90)<br>console.log(m)//Map { { name: ‘tom’ } =&gt; 90 }<br>console.log(m.get(tom))//90<br>//m.has()//判断某个键是否存在<br>//m.delete()//删除某个键<br>//m.clear()//清空s所有键值<br>m.forEach((value,key)=&gt;{//遍历<br>    console.log(value,key)<br>})//90 { name: ‘tom’ }<br></pre><br>对象只能用字符串作为键，而Map可以用任意类型数据作为键<br>28.ES2015 Symbol<br>在ES2015之前对象的属性名只能是字符串，字符串是可能会产生冲突的。比如我们设置了全局缓存对象变量cache，而在不同的js文件中我们设置了同一个对象属性，那么就会产生问题，在过去，我们会通过约定来尽量规避这种情况<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/28_1.png"><br>但是约定的方式只是规避了问题，并不是彻底解决问题，ES2015提供了Symbol类型来彻底解决这个问题，作用就是表示一个独一无二的值</p>
<p><pre><br>const s = Symbol()<br>console.log(s)//Symbol()<br>console.log(typeof s)//symbol<br></pre><br>这种类型最大的特点就是独一无二，也就说通过这种方式创建的每一个值都是唯一的，永远不会重复</p>
<p><pre><br>console.log(Symbol() === Symbol())//false<br></pre><br>考虑到在开发过程中的调试，允许我们传入一个字符串作为这个值的描述文本，对于我们多次使用Symbol的情况，就能在控制台中区分出来到底是哪一个对应的Symbol</p>
<p><pre><br>console.log(Symbol(‘foo’))//Symbol(foo)<br>console.log(Symbol(‘bar’))//Symbol(bar)<br>console.log(Symbol(‘baz’))//Symbol(baz)<br></pre><br>从ES2015开始，对象就可以使用Symbol类型的值作为属性名</p>
<p><pre><br>const obj = {}<br>obj[Symbol()] = ‘123’<br>obj[Symbol()] = ‘456’<br>console.log(obj)//{ [Symbol()]: ‘123’, [Symbol()]: ‘456’ }<br>//或者<br>const obj1 = {<br>    [Symbol()]:123<br>}<br>console.log(obj1)//{ [Symbol()]: 123 }<br></pre><br>我们可以通过Symbol的特性来模拟对象的私有成员，假定我们创建了a.js文件</p>
<p><pre><br>//a.js<br>const name = Symbol()<br>const person = {<br>    [name] : ‘zce’,<br>    say(){<br>        console.log(this[name])<br>    }<br>}<br>//b.js<br>//person[Symbol()]//不能访问，因为Symbol成员不能产生完全一样的值<br>person.say()<br></pre><br>在b.js中，我们没有办法再去创建一个完全相同的Symbol，所以无法访问person对象中的Symbol变量的成员，只能访问对象中普通名称的成员。Symbol目前最主要的作用就是为对象添加独一无二的属性名。截止到ES2019，一共定义了6种原始类型和Object数据类型，一共7种数据类型。在未来还会新增一个叫BigInt的原始数据类型，用于去存放更长的数字，目前处于stage-4阶段，预计在下一个版本能正式被标准化，那么ES就是8种数据类型了<br>28.ES2015 Symbol补充<br>Symbol每次生成的都是全新的一个值，如果想去全局复用，可以用全局变量的方式或者使用Symbol类型提供的静态方法，也就是for方法，可以接收一个字符串作为一个参数，相同的字符串一定会返回相同的Symbol类型的值，因为在方法内部维护了一个全局的注册表，为我们的字符串和Symbol提供了一一对应的关系。因为方法内部维护的是字符串与Symbol的关系，也就是说如果我们传入的不是字符串，方法内部会自动转换成字符串，会导致比如传入布尔值的true和传入字符串的true拿到的值是一样的</p>
<p><pre><br>const s1 = Symbol.for(‘foo’)<br>const s2 = Symbol.for(‘foo’)<br>console.log(s1 === s2)//true<br>console.log(Symbol.for(true) === Symbol.for(‘true’))<br></pre><br>Symbol方法中还定义了很多内置的Symbol常量来作为内部方法的标识，可以让一些自定义对象实现js当中内置的一些接口</p>
<p><pre><br>//Symbol.iterator<br>//Symbol.hasInstance<br>const obj = {}<br>console.log(obj.toString())//[object Object]-&gt;我们把这样的字符串叫做对象的toString标签<br>//自定义对象的toString标签，可以在对象中添加一个特定的成员去标识<br>//考虑到使用字符串添加标识可能会跟内部的一些成员产生重复，所以es要求我们使用Symbol实现接口<br>const obj1 = {<br>    [Symbol.toStringTag]:’XObject’<br>}<br>console.log(obj1.toString())//[object XObject]<br>//toStringTag是Symbol内置的一个常量，这种Symbol在后面我们为对象实现迭代器时常用到<br></pre><br>Symbol作为对象的属性名，通过传统的for…in…循环/Object.keys()是无法拿到的，通过JSON.stringify序列化对象为一个字符串，Symbol属性也会被忽略掉，种种特性使得Symbol特别适合作为私有属性</p>
<p><pre><br>const obj = {<br>    [Symbol()]:’symbol value’,<br>    foo:’normal value’<br>}<br>for(var key in obj){<br>    console.log(key)<br>}<br>Object.keys(obj)<br></pre><br>如果想获取Symbol类型的属性名，可以通过Object.getOwnPropertySymbols(obj)。Object.getOwnPropertySymbols类似于Object.keys，所不同的是Object.keys只能获取到字符串类型的属性名，而Object.getOwnPropertySymbols获取到的是Symbol属性名<br>31.ES2015 for…of循环<br>在es中有很多遍历数据的方法，比如for循环适合遍历普通数组，for…in…适合遍历键值对，还有一些函数式的遍历方法，例如forEach方法。但是这些遍历方法都有一些局限性，所以ES2015借鉴其他语言引入了一种新的遍历方法for…of循环，这种遍历方式以后会作为遍历所有数据结构的统一方式。下面先了解for…of循环的基本用法</p>
<p><pre><br>const arr = [100,200,300,400]<br>for(const item of arr){<br>    console.log(item)<br>}<br>//100<br>//200<br>//300<br>//400<br></pre><br>这种循环方式就可以取代我们之前常用的数组循环方式forEach，并且for…of循环可以随时用break关键词终止循环，这一点比forEach表现好，因为forEach循环无法终止遍历</p>
<p><pre><br>const arr = [100,200,300,400]<br>for(const item of arr){<br>    console.log(item)<br>    if(item &gt; 100){<br>        break;<br>    }<br>}<br></pre><br>除了数组可以用for…of循环遍历，一些伪数组对象也是可以用for…of循环遍历的，例如函数中的arguments，DOM节点的列表。这些伪数组对象的遍历和普通数组对象的遍历没有什么区别，这里不再演示。但是一些Set(其实和遍历数组基本一样，拿到的是元素本身)、Map对象，我们还是了解一下吧</p>
<p><pre><br>const s = new Set([‘foo’,’bar’])<br>for(const item of s){<br>    console.log(item)<br>}<br>//foo<br>//bar<br></pre></p>
<p><pre><br>const m = new Map()<br>m.set(‘foo’,’123’)<br>m.set(‘bar’,’345’)<br>for(const item of m){<br>    console.log(item)<br>}<br>//[ ‘foo’, ‘123’ ]//当前被遍历的键和值<br>//[ ‘bar’, ‘345’ ]<br>//配合数组的解构语法，可以直接拿到数组的键和值了<br>for(const [key,value] of m){<br>    console.log(key,value)<br>}<br>//foo 123<br>//bar 345<br></pre><br>上面基本都成功了，但是当我们试图变量普通对象的时候，却报错了</p>
<p><pre><br>const obj = {foo:123,bar:456}<br>for(item of obj){<br>    console.log(item)<br>}<br>//for(item of obj){<br>            ^<br>//TypeError: obj is not iterable<br></pre><br>说好的能遍历所有的数据结构呢？预知原因几何，且听下回分解<br>32.ES2015 可迭代接口<br>上节课说到for…of循环说好的能遍历所有的数据结构，但是居然不能遍历普通对象，这是因为：ES中能够表示有结构的数据类型越来越多，例如数组、对象到ES2015的set、map等，开发者甚至可以组合使用这种类型去定义一些符合自己业务需求的数据结构，为了给各种各样的数据结构提供统一的遍历方式，ES2015提供了一种Iterable的接口，意思就是可迭代的(如果不太理解编程语言当中的接口概念，可以把接口理解为一种规格标准，例如在ES中任意一种数据类型都有toString方法，是因为它们都实现了统一的规格标准。而在编程语言当中更专业的说法是它们都实现了统一的接口)。实现Iterable接口就是for…of的前提。我们可以在浏览器的控制台中查看一下我们之前定义的Map、Set等对象的数据结构<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_1.png"><br>可以看到我们每个可以用for…of循环遍历的数据结构都有Symbol.iterator，在Symbol.iterator中有个next方法，我们调用这个next方法<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_2.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_3.png"><br>我们能看到next方法返回的又是一个对象，当我们多次调用next方法之后可以看到<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_4 .png"><br>我们可以想到，在迭代器当中维护了一个数据指针，我们每调用一次next，数据都会往后移一位，而途中done属性的作用就是表示我们 内部的数据是否遍历完了。我们通过尝试，了解了实现iterable接口数据类型的特点。我们来总结一下，所有能实现for…of循环的数据类型都要实现iterable的接口，在内部必须挂载一个iterator的方法，这个iterator的方法需要返回一个带有next方法的对象，我们不断调用next方法就能实现对内部所有数据的遍历。那么我们再反过来看一下Set</p>
<p><pre><br>const s = new Set([‘foo’,’bar’,’baz’])<br>const iterator = s<a href="">Symbol.iterator</a><br>console.log(iterator.next())//{ value: ‘foo’, done: false }<br>console.log(iterator.next())//{ value: ‘bar’, done: false }<br>console.log(iterator.next())//{ value: ‘baz’, done: false }<br>console.log(iterator.next())//{ value: undefined, done: true }<br></pre><br>这就是for…of循环内部的实现原理，其实我们也可以使用while循环实现相同的遍历<br>33.ES2015 实现可迭代接口<br>上节课我们了解了可迭代接口iterable，也就是说如果我们给对象实现iterable接口，那么也可以通过for…of循环去遍历普通对象。在ES中实现iterable实际上就是在对象中挂载iterator方法，在这个方法中返回一个迭代器对象</p>
<p><pre><br>const obj = {<br>    [Symblo.iterator]:function(){//实现了可迭代接口iterable<br>        return {//实现了迭代器接口iterator<br>            next:function(){<br>                return {//迭代结果接口iterationResult<br>                    value:’zce’,//当前被迭代到的数据，值可以是任意类型，本例中为了方便理解，随便赋了一个值<br>                    done:true   //布尔值，表示迭代是否结束<br>                }<br>            }<br>        }<br>    }<br>}<br>//我们试着调用for…of<br>for(const item of obj){<br>    console.log(‘循环体’)<br>}<br></pre><br>我们试着调用for…of循环，发现并没有报错(虽然也没有执行，但是不报错已经是一个好的开始，毕竟我们把done属性设置为true)，那我们在上面代码的基础上进行修改</p>
<p><pre><br>const obj = {<br>    store:[‘foo’,’bar’,’baz’],//对象中添加一个数组，里面放一些值得被遍历的数据<br>    [Symbol.iterator]:function(){//实现了可迭代接口iterable<br>        let index = 0//既然要在next方法中迭代数组，我们就要维护一个下标<br>        const self = this//在next函数中的this并没有指向当前对象，定义self来接收当前的this<br>        return {//实现了迭代器接口iterator<br>            next:function(){<br>                const result =  {//迭代结果接口iterationResult<br>                    value:self.store[index],//当前被迭代到的数据，值可以是任意类型<br>                    done:index &gt;= self.store.length   //布尔值，表示迭代是否结束<br>                }<br>                index++<br>                return result<br>            }<br>        }<br>    }<br>}<br>for(const item of obj){<br>    console.log(‘循环体’,item)<br>}<br>//循环体 foo<br>//循环体 bar<br>//循环体 baz<br></pre><br>虽然我们实现了对象的迭代器，但是好像也没觉得有什么用处，难道实现起来真的没有意义么？<br>34.ES2015 迭代器模式<br>上节课我们实现了对象的迭代器，但是感觉并不是很实用？这节课我们来学习下迭代器模式，看看能不能派上用场。不过不要被这个名字吓到，我们来了解下就知道了。假如我们合作一个任务清单应用，这里老师的任务是设计一个用于存放所有任务的对象，我的任务是把所有的任务项全部罗列、呈现到界面上。<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/34_1.png"><br>从上图可以看到，用一般的思维方式去完成这个任务，我的代码和老师的代码严重耦合，老师的代码只要修改了，我的代码就需要修改。此时如果老师的数据结构能够对外提供一个统一的遍历接口，对于我(调用者而言)也就不用再关心老师的代码内部的数据结构是怎样的了，更不用担心老师的代码内部结构改变过后产生的影响<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/34_2.png"><br>实现可迭代接口其实是相同的道理，对外提供统一的遍历接口，让外部不用再担关心内部数据的结构是什么样的，ES2015在语言层面实现了迭代器模式，适用于任何数据结构，只需要在需要的地方实现iterator方法就可以</p>
<p><pre><br>//老师的代码===============================<br>const todos = {<br>    life: [‘吃饭’, ‘睡觉’, ‘打豆豆’],<br>    learn: [‘语文’, ‘数学’, ‘外语’],<br>    work: [‘喝茶’],<br>    // 提供统一遍历访问接口<br>    each: function (callback) {<br>        const all = [].concat(this.life, this.learn, this.work)<br>        for (const item of all) {<br>            callback(item)<br>        }<br>    },<br>    // 提供迭代器（ES2015 统一遍历访问接口）<br>    [Symbol.iterator]: function () {<br>        const all = […this.life, …this.learn, …this.work]<br>        let index = 0<br>        return {<br>            next: function () {<br>                return {<br>                      value: all[index],<br>                      done: index++ &gt;= all.length<br>                }<br>            }<br>        }<br>    }<br>}<br>// 我的代码 ===============================<br>todos.each(function (item) {<br>  console.log(item)<br>})<br>console.log(‘——————————-‘)<br>for (const item of todos) {<br>  console.log(item)<br>}<br>/*吃饭<br>睡觉<br>打豆豆<br>语文<br>数学<br>外语</pre></p>
<h2 id="喝茶"><a href="#喝茶" class="headerlink" title="喝茶"></a>喝茶</h2><p>吃饭<br>睡觉<br>打豆豆<br>语文<br>数学<br>外语*/<br><br>35.ES2015 生成器<br>生成器是为了避免异步编程过程中回调嵌套过深，提供更好的异步编程解决方案。我们先来了解一下生成器函数的语法以及基本应用</p>
<p><pre><br>function* foo(){<br>    console.log(‘zce’)//并未被打印<br>    return 100<br>}<br>const result = foo()<br>//console.log(result)//Object [Generator] {}<br>console.log(result.next())<br>//zce<br>//{ value: 100, done: true }//生成器接口也实现了iterator接口，也即是迭代器接口的协议<br></pre><br>这里我们单独用生成器函数并没有什么体会，因为平时使用生成器函数都会配合yield关键词使用</p>
<p><pre><br>function * foo () {<br>  console.log(‘1111’)<br>  yield 100<br>  console.log(‘2222’)<br>  yield 200<br>  console.log(‘3333’)<br>  yield 300<br>}<br>const generator = foo()<br>console.log(generator.next()) // 第一次调用，函数体开始执行，遇到第一个 yield 暂停<br>//1111<br>//{ value: 100, done: false }<br>console.log(generator.next())//第二次调用，从暂停位置继续，直到遇到下一个 yield 再次暂停<br>//2222<br>//{ value: 200, done: false }<br>console.log(generator.next())<br>//3333<br>//{ value: 300, done: false }<br>console.log(generator.next())// 第四次调用，已经没有需要执行的内容了，所以直接得到 undefined<br>//{ value: undefined, done: true }<br>console.log(generator.next())<br>//{ value: undefined, done: true }<br></pre><br>生成器函数自动帮我们返回一个生成器对象，我们调用这个对象的next方法才会让这个函数的函数体开始执行，在执行过程中一旦遇到yield关键词，函数的执行就会被暂停，而且yield后面的值将会被作为next的结果返回，如果我们继续调用生成器对象next，函数就会从暂停的位置继续开始执行，周而复始知道函数的执行完全结束，next所返回done的值也就变成了true。生成器函数最大的特点就是惰性执行，就是我们调用一下next就执行一次。<br>36.ES2015 生成器应用<br>了解了生成器，我们简单应用一下<br>(1)实现一个发号器</p>
<p><pre><br>function * createIdMaker(){<br>    let id = 1;<br>    while(true){//虽然这里是执行条件是true，但是因为有yield，每次只执行一遍就会停下<br>        yield id++<br>    }<br>}<br>const idMaker = createIdMaker()<br>console.log(idMaker.next().value)//1<br>console.log(idMaker.next().value)//2<br>console.log(idMaker.next().value)//3<br>console.log(idMaker.next().value)//4<br></pre><br>(2)实现对象的iterator方法<br>虽然生成器本身是有iterator接口的，我们用生成器实现iterator接口要比之前简单很多</p>
<p><pre><br>const todos = {<br>  life: [‘吃饭’, ‘睡觉’, ‘打豆豆’],<br>  learn: [‘语文’, ‘数学’, ‘外语’],<br>  work: [‘喝茶’],<br>  [Symbol.iterator]: function * () {<br>    const all = […this.life, …this.learn, …this.work]<br>    for (const item of all) {<br>      yield item<br>    }<br>  }<br>}<br>for (const item of todos) {<br>  console.log(item)<br>}<br></pre><br>37.ES2015 ES Modules<br>会在后面相关内容做介绍，这里不讲<br>38.ES2016 概述<br>ES2016与ES2015相比只是一个小版本的迭代<br>(1)Array.prototype.includes检查数组是否包含指定元素变得更加简单<br>过去我们用indexOf查找元素是否存在，但是indexOf不能查找NaN，includes可以查找NaN</p>
<p><pre><br>const arr = [‘foo’,1,NaN,false]<br>console.log(arr.includes(‘foo’))//true<br>console.log(arr.includes(NaN))//true<br></pre><br>(2)指数运算符<br>过去我们求2的10次放就是Math.pow(2,10)，ES2016的指数运算就是语言本身的运算符，在ES2016中2的10次方就是console.log( 2 ** 10 )<br>39.ES2017 概述<br>(1)Object.values()<br>返回对象的值数组<br>(2)Object.entries()<br>以数组的形式返回对象中的所有键值对</p>
<p><pre><br>const obj = {<br>    foo:’value1’,<br>    bar:’value2’<br>}<br>console.log(Object.values(obj))//[ ‘value1’, ‘value2’ ]<br>for(let [key,value] of Object.entries(obj)){<br>    console.log(key,value)<br>}<br>//foo value1<br>//bar value2<br>console.log(new Map(Object.entries(obj)))<br>//Map { ‘foo’ =&gt; ‘value1’, ‘bar’ =&gt; ‘value2’ }<br></pre><br>(3)Object.getOwnPropertyDescriptor()<br>获取对象中属性的完整描述信息。自从ES5之后我们可以给对象定义getter/setter属性，getter/setter是不能通过Object. assign去完全复制的，只会把getter/setter去当成一个普通的属性来复制</p>
<p><pre><br>const p1 = {<br>    firstName : ‘lei’,<br>    lastName : ‘wang’,<br>    get fullName(){<br>        return this.firstName+’ ‘+this.lastName<br>    }<br>}<br>// console.log(p1.fullName)<br>// const p2 = Object.assign({},p1)<br>// p2.firstName = ‘zce’<br>// console.log(p2.fullName)//lei wang<br>// console.log(p2)//{ firstName: ‘zce’, lastName: ‘wang’, fullName: ‘lei wang’ }<br>const descriptors = Object.getOwnPropertyDescriptors(p1)<br>// console.log(descriptor)<br>//{<br>//  firstName: {<br>//    value: ‘lei’,<br>//    writable: true,<br>//    enumerable: true,<br>//    configurable: true<br>//  },<br>//  lastName: {<br>//    value: ‘wang’,<br>//    writable: true,<br>//    enumerable: true,<br>//    configurable: true<br>//  },<br>//  fullName: {<br>//    get: [Function: get fullName],<br>//    set: undefined,<br>//    enumerable: true,<br>//    configurable: true<br>//  }<br>//}<br>const p2 = Object.defineProperties({},descriptors)<br>p2.firstName = ‘zce’<br>console.log(p2.fullName)//zce wang<br></pre><br>(4)String.prototype.padStart/String.prototype.padEnd<br>用给定的字符串填充指定(字符串开始位置或者字符串结束位置)位置</p>
<p><pre><br>const books = {<br>    html:5,<br>    css:16,<br>    javascript:128<br>}<br>for(const [name,count] of Object.entries(books)){<br>    console.log(<code>${name.padEnd(16,&#39;-&#39;)}|${count.toString().padStart(3,&#39;0&#39;)}</code>)<br>}<br>//html————|005<br>//css————-|016<br>//javascript——|128<br></pre><br>(5)在函数参数中添加尾逗号</p>
<p><pre><br>function foo(bar,baz,){<br>    //…<br>}<br></pre><br>(6)Async/Await<br>在异步编程中详细介绍过</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/21/拉勾-ECMAScript新特性/" data-id="ckeeij3bx0060joxq5wgn1fl6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/26/拉勾-TypeScript语言/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          拉勾-TypeScript语言
        
      </div>
    </a>
  
  
    <a href="/2020/06/20/网易微专业-移动端APP开发工程师-微信小程序-3-1-1-创建微信小程序项目/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">网易微专业-移动端APP开发工程师-微信小程序-3.1.1-创建微信小程序项目</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/拉勾/">拉勾</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾/">拉勾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业/">网易微专业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECMAScript新特性/" style="font-size: 10px;">ECMAScript新特性</a> <a href="/tags/JavaScript异步编程/" style="font-size: 10px;">JavaScript异步编程</a> <a href="/tags/TypeScript语言/" style="font-size: 10px;">TypeScript语言</a> <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/函数式编程范式/" style="font-size: 10px;">函数式编程范式</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/手写Promise源码/" style="font-size: 10px;">手写Promise源码</a> <a href="/tags/拉勾/" style="font-size: 20px;">拉勾</a> <a href="/tags/拉勾，自动化构建/" style="font-size: 10px;">拉勾，自动化构建</a> <a href="/tags/数据结构/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 17.5px;">算法</a> <a href="/tags/网易微专业/" style="font-size: 10px;">网易微专业</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/10/拉勾-Virtual-DOM-的实现原理/">拉勾-Virtual DOM 的实现原理</a>
          </li>
        
          <li>
            <a href="/2020/08/05/拉勾-模拟Vue-js响应式原理/">拉勾-模拟Vue.js响应式原理</a>
          </li>
        
          <li>
            <a href="/2020/08/03/拉勾-Vue-Router实现原理/">拉勾-Vue-Router实现原理</a>
          </li>
        
          <li>
            <a href="/2020/08/02/拉勾-Vue-js基础回顾/">拉勾-Vue.js基础回顾</a>
          </li>
        
          <li>
            <a href="/2020/07/29/拉勾-规范化标准/">拉勾-规范化标准</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>