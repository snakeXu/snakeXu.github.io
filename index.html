<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="喵小喵的窝">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="喵小喵的窝">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-拉勾-手写Promise源码" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/18/拉勾-手写Promise源码/" class="article-date">
  <time datetime="2020-06-18T00:56:08.000Z" itemprop="datePublished">2020-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/18/拉勾-手写Promise源码/">拉勾-手写Promise源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.Promise类核心逻辑的实现<br>首先我们来分析一下Promise的一些特性:<br>·Promise就是一个类，在执行这个类的时候需要传递一个执行器进去，执行器会立即执行<br>·Promise中有三种状态，分别为 等待-pending 成功-fulfilled 失败-rejected<br>  pending -&gt; fulfilled<br>  pending -&gt; rejected<br>  一旦状态确定就不可更改<br>·resolve和reject函数是用来更改状态的<br>  resolve:fulfilled<br>  reject:rejected<br>·then方法内部做的事情就是判断状态。如果状态是成功，调用成功的回调函数；如果状态是失败，调用失败的回调函数。then方法是被定义在原型对象中的<br>·then成功回调有一个参数，表示成功之后的值；then失败回调有一个参数，表示失败后的原因<br>下面开始用代码实现这些功能(也就是模拟promise的实现)<br>myPromise.js</p>
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //接收执行器，并且这个执行器是立即执行的
        executor(this.resolve,this.reject)
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
    }
    then(successCallback,failCallback){
        //判断状态
        if(this.status === FULFILLED){
            successCallback(this.value)
        }else if(this.status === REJECTED){
            failCallback(this.reason)
        }
    }
}
module.exports = myPromise;
</pre>
index.js
<pre>
const myPromise = require('./myPromise')
const promise = new myPromise((resolve,reject)=>{
    //resolve('成功')
    reject('失败')
})
promise.then(value=>{
    console.log(value)
},reason =>{
    console.log(reason)
})
</pre>
2.在Promise类中加入异步逻辑
myPromise.js
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //接收执行器，并且这个执行器是立即执行的
        executor(this.resolve,this.reject)
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //成功回调
    successCallback = undefined;
    //失败回调
    failCallback = undefined;
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
        //判断成功回调是否存在，如果存在就调用
        this.successCallback && this.successCallback(this.value)
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
        //判断失败回调是否存在，如果存在就调用
        this.failCallback && this.failCallback(this.reason)
    }
    then(successCallback,failCallback){
        //判断状态
        if(this.status === FULFILLED){
            successCallback(this.value)
        }else if(this.status === REJECTED){
            failCallback(this.reason)
        }else{
            //走到这里证明当前状态是等待pending
            //将成功回调和失败回调存储起来
            this.successCallback = successCallback
            this.failCallback = failCallback
        }
    }
}
module.exports = myPromise;
</pre>
index.js
<pre>
const myPromise = require('./myPromise')
const promise = new myPromise((resolve,reject)=>{
    setTimeout(()=>{
        resolve('成功')
    },2000)
    // reject('失败')
})
promise.then(value=>{
    console.log(value)
},reason =>{
    console.log(reason)
})
</pre>
3.实现then方法多次调用添加多个处理函数
同一个promise对象下面的then方法是可以被多次调用的，当then方法被多次调用，每一次then方法当中传递的回调函数都是要被执行的，如何执行呢？
myPromise.js
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //接收执行器，并且这个执行器是立即执行的
        executor(this.resolve,this.reject)
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //成功回调
    successCallback = [];//数组才可以存储多个可能的then方法的回调函数，failCallback同理
    //失败回调
    failCallback = [];
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
        //判断成功回调是否存在，如果存在就调用
        //this.successCallback && this.successCallback(this.value)//用数组存储回调事件，这里就不能再用了
        while(this.successCallback.length){
            this.successCallback.shift()(this.value)
        }
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
        //判断失败回调是否存在，如果存在就调用
        //this.failCallback && this.failCallback(this.reason)
        while(this.failCallback.length){
            this.failCallback.shift()(this.reason)
        }
    }
    then(successCallback,failCallback){
        //判断状态
        if(this.status === FULFILLED){
            successCallback(this.value)
        }else if(this.status === REJECTED){
            failCallback(this.reason)
        }else{
            //走到这里证明当前状态是等待pending
            //将成功回调和失败回调存储起来
            this.successCallback.push(successCallback)
            this.failCallback.push(failCallback)
        }
    }
}
module.exports = myPromise;
</pre>
index.js
<pre>
const myPromise = require('./myPromise')
const promise = new myPromise((resolve,reject)=>{
    // setTimeout(()=>{
    //     resolve('成功')
    // },2000)
    resolve('成功')
    // reject('失败')
})
promise.then(value=>{
    console.log(1)
    console.log(value)
},reason => {
    console.log(reason)
})
promise.then(value=>{
    console.log(2)
    console.log(value)
},reason => {
    console.log(reason)
})
promise.then(value=>{
    console.log(3)
    console.log(value)
},reason => {
    console.log(reason)
})
</pre>
4.实现then方法的链式调用(一) && 5.实现then方法的链式调用(二)
myPromise.js
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //接收执行器，并且这个执行器是立即执行的
        executor(this.resolve,this.reject)
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //成功回调
    successCallback = [];//数组才可以存储多个可能的then方法的回调函数，failCallback同理
    //失败回调
    failCallback = [];
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
        //判断成功回调是否存在，如果存在就调用
        //this.successCallback && this.successCallback(this.value)//用数组存储回调事件，这里就不能再用了
        while(this.successCallback.length){
            this.successCallback.shift()(this.value)
        }
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
        //判断失败回调是否存在，如果存在就调用
        //this.failCallback && this.failCallback(this.reason)
        while(this.failCallback.length){
            this.failCallback.shift()(this.reason)
        }
    }
    then(successCallback,failCallback){
        let promise2 = new myPromise((resolve,reject) => {
            //判断状态
            if(this.status === FULFILLED){
                let  x = successCallback(this.value);
                //resolve(x)
                //判断x的值是普通值还是promise对象
                //如果是普通值，直接resolve
                //如果是promise对象，查看promise对象返回的结果
                //再根据promise对象返回的结果，决定调用resolve还是reject
                resolvePromise(x, resolve, reject)
            }else if(this.status === REJECTED){
                failCallback(this.reason)
            }else{
                //走到这里证明当前状态是等待pending
                //将成功回调和失败回调存储起来
                this.successCallback.push(successCallback)
                this.failCallback.push(failCallback)
            }
        });
        return promise2 
    }
}
function resolvePromise(x, resolve, reject){
    if(x instanceof myPromise){
        //promise对象
        //x.then(value=>resolve(value),reason=>reject(reason))
        x.then(resolve,reject)
    }else{
        //普通值
        resolve(x)
    }
}
module.exports = myPromise;
</pre>
index.js
<pre>
const myPromise = require('./myPromise')
const promise = new myPromise((resolve,reject)=>{
    resolve('成功')
    // reject('失败')
})
function other(){
    return new myPromise((resolve,reject)=>{
        resolve('other')
    })
}
promise.then(value=>{
    console.log(value)
    return other()
}).then(value =>{
    console.log(value)
})
</pre>
6.then方法链式调用识别Promise对象返回自
如果循环调用本身的promise对象，如下面代码
<pre>
var promise = new Promise(function(resolve,reject){
    resolve(100)
})
var p1 = promise.then(function(value)=>{
    console.log(value)
    p1
})
</pre>
那么程序是会报错的，我们如何判断这种情况呢
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //接收执行器，并且这个执行器是立即执行的
        executor(this.resolve,this.reject)
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //成功回调
    successCallback = [];//数组才可以存储多个可能的then方法的回调函数，failCallback同理
    //失败回调
    failCallback = [];
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
        //判断成功回调是否存在，如果存在就调用
        //this.successCallback && this.successCallback(this.value)//用数组存储回调事件，这里就不能再用了
        while(this.successCallback.length){
            this.successCallback.shift()(this.value)
        }
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
        //判断失败回调是否存在，如果存在就调用
        //this.failCallback && this.failCallback(this.reason)
        while(this.failCallback.length){
            this.failCallback.shift()(this.reason)
        }
    }
    then(successCallback,failCallback){
        let promise2 = new myPromise((resolve,reject) => {
            //判断状态
            if(this.status === FULFILLED){
                //在所有同步代码执行完毕后再执行，能顺利获取promise2
                setTimeout(()=>{
                    let  x = successCallback(this.value);
                    //resolve(x)
                    //判断x的值是普通值还是promise对象
                    //如果是普通值，直接resolve
                    //如果是promise对象，查看promise对象返回的结果
                    //再根据promise对象返回的结果，决定调用resolve还是reject
                    resolvePromise(promise2, x, resolve, reject)
                },0)
            }else if(this.status === REJECTED){
                failCallback(this.reason)
            }else{
                //走到这里证明当前状态是等待pending
                //将成功回调和失败回调存储起来
                this.successCallback.push(successCallback)
                this.failCallback.push(failCallback)
            }
        });
        return promise2 
    }
}
function resolvePromise(promise2, x, resolve, reject){
    if(promise2 === x){
        return reject(new TypeError('Chaining cycle detected for promise #< promise >'))
    }
    if(x instanceof myPromise){
        //promise对象
        //x.then(value=>resolve(value),reason=>reject(reason))
        x.then(resolve,reject)
    }else{
        //普通值
        resolve(x)
    }
}
module.exports = myPromise;
</pre>
index.js
<pre>
const myPromise = require('./myPromise')
const promise = new myPromise((resolve,reject)=>{
    resolve('成功')
    // reject('失败')
})
function other(){
    return new myPromise((resolve,reject)=>{
        resolve('other')
    })
}
let p1 = promise.then(value=>{
    console.log(value)
    return p1
})
p1.then(value =>{
    console.log(value)
},reason=>{
    console.log(reason.message)
})
</pre>
7.捕获错误及then链式调用其他状态代码补充
8.将then方法变成可选参数(确认参数是否存在，不存在设置默认参数返回)
9.Promise.all方法的实现
首先我们了解下Promise.all方法的主要特点，以我们下面的代码为例
<pre>
function p1(){
    return new Promise(function(resolve,reject){
        setTimeout(function(){
            resolve('p1')
        },2000)
    })
}
function p2(){
    return new Promise(function(resolve,reject){
        resolve('p2')
    })
}
Promise.all(['a','b',p1(),p2(),'c']).then(function(result){
    //result->['a','b','p1','p2','c']
})
</pre>
Promise.all主要是解决异步代码的并发问题，允许我们按照异步代码调用的顺序得到异步代码执行的结果，上面代码，如果先调用p1，再调用p2，那么p2会先执行，因为p1有setTimeout定时器延时，但是如果我们把p1，p2放入Promise.all方法，会按放入的先后顺序执行，也就是先放入p1就执行p1。
Promise.all方法接收一个数组作为参数，在数组中我们可以放入任何值，包括普通值和promise对象，数组中值的顺序一定是我们得到的结果中的顺序。Promise.all的返回值也是一个Promise对象，所以我们也可以链式调用then方法。如果all方法中所有promise对象的状态都是成功的，则all方法最好的结果也是成功的，如果有一个失败的，那么all方法就是失败的。
myPromise.js
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //捕获执行过程中的错误
        try{
            //接收执行器，并且这个执行器是立即执行的
            executor(this.resolve,this.reject)
        } catch(e){
            this.reject(e)
        }
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //成功回调
    successCallback = [];//数组才可以存储多个可能的then方法的回调函数，failCallback同理
    //失败回调
    failCallback = [];
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
        //判断成功回调是否存在，如果存在就调用
        //this.successCallback && this.successCallback(this.value)//用数组存储回调事件，这里就不能再用了
        while(this.successCallback.length){
            this.successCallback.shift()()
        }
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
        //判断失败回调是否存在，如果存在就调用
        //this.failCallback && this.failCallback(this.reason)
        while(this.failCallback.length){
            this.failCallback.shift()()
        }
    }
    then(successCallback,failCallback){
        successCallback = successCallback ? successCallback : value => value ;
        failCallback = failCallback ? failCallback : reason => {throw reason} ;
        let promise2 = new myPromise((resolve,reject) => {
            //判断状态
            if(this.status === FULFILLED){
                //在所有同步代码执行完毕后再执行，能顺利获取promise2
                setTimeout(()=>{
                    try{
                        let  x = successCallback(this.value);
                        //resolve(x)
                        //判断x的值是普通值还是promise对象
                        //如果是普通值，直接resolve
                        //如果是promise对象，查看promise对象返回的结果
                        //再根据promise对象返回的结果，决定调用resolve还是reject
                        resolvePromise(promise2, x, resolve, reject)
                    }catch(e){
                        reject(e)
                    }
                },0)
            }else if(this.status === REJECTED){
                setTimeout(()=>{
                    try{
                        let  x = failCallback(this.reason);
                        //resolve(x)
                        //判断x的值是普通值还是promise对象
                        //如果是普通值，直接resolve
                        //如果是promise对象，查看promise对象返回的结果
                        //再根据promise对象返回的结果，决定调用resolve还是reject
                        resolvePromise(promise2, x, resolve, reject)
                    }catch(e){
                        reject(e)
                    }
                },0)
            }else{
                //走到这里证明当前状态是等待pending
                //将成功回调和失败回调存储起来
                this.successCallback.push(()=>{
                    setTimeout(()=>{
                        try{
                            let  x = successCallback(this.value);
                            //resolve(x)
                            //判断x的值是普通值还是promise对象
                            //如果是普通值，直接resolve
                            //如果是promise对象，查看promise对象返回的结果
                            //再根据promise对象返回的结果，决定调用resolve还是reject
                            resolvePromise(promise2, x, resolve, reject)
                        }catch(e){
                            reject(e)
                        }
                    },0)
                })
                this.failCallback.push(()=>{
                    setTimeout(()=>{
                        try{
                            let  x = failCallback(this.reason);
                            //resolve(x)
                            //判断x的值是普通值还是promise对象
                            //如果是普通值，直接resolve
                            //如果是promise对象，查看promise对象返回的结果
                            //再根据promise对象返回的结果，决定调用resolve还是reject
                            resolvePromise(promise2, x, resolve, reject)
                        }catch(e){
                            reject(e)
                        }
                    },0)
                })
            }
        });
        return promise2 
    }
    //类相当于实例的原型，所有在类中定义的方法，都会被实例继承。
    //如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，
    //而是直接通过类来调用（通过类调用指在该类之外调用），这就称为“静态方法”。
    static all(array){
        let result = []
        let index = 0
        return new myPromise((resolve,reject)=>{
            function addData(key, value){
                result[key] = value;
                index++
                if(index === array.length){
                    resolve(result)
                }
            }
            for(let i=0;i<array.length;i++){ let="" current="array[i];" if(current="" instanceof="" mypromise){="" 是一个promise对象，要执行这个对象="" current.then(value=""> addData(i,value),reason => reject(reason))
                }else{
                    //current 是一个普通值
                    addData(i,array[i])
                }
            }
            //resolve(result)
        })
    }
}
function resolvePromise(promise2, x, resolve, reject){
    if(promise2 === x){
        return reject(new TypeError('Chaining cycle detected for promise #<promise>'))
    }
    if(x instanceof myPromise){
        //promise对象
        //x.then(value=>resolve(value),reason=>reject(reason))
        x.then(resolve,reject)
    }else{
        //普通值
        resolve(x)
    }
}
module.exports = myPromise;
</promise></array.length;i++){></pre>
index.js
<pre>
const myPromise = require('./myPromise')
function p1(){
    return new myPromise(function(resolve,reject){
        setTimeout(function(){
            resolve('p1')
        },2000)
    })
}
function p2(){
    return new myPromise(function(resolve,reject){
        resolve('p2')
    })
}
myPromise.all(['a','b',p1(),p2(),'c'])
.then(function(result){
    //result->['a','b','p1','p2','c']
    console.log(result)
})
</pre>
10.Promise.resolve方法的实现
Promise.resolve方法的作用是将给定的值转换为promise对象
这个代码并不复杂，所以就不把整段myPromise代码都展示在这里了
<pre>
static resolve(value){
    if(value instanceof myPromise) return value;
    return new myPromise(resolve => resolve(value))
}
</pre>
11.finally方法的实现
promise最终的状态无论是成功还是失败，finally方法都会被执行一次；在finally对象的后面我们还可以链式调用then方法拿到最终返回的结果。并且在finally中如果返回一个异步函数，是会等待异步对象执行完成的。
<pre>
finally(callback){
        return this.then(value=>{
            // callback()
            // return value//注释掉的两行是不考虑finally中return一个异步函数的情况
            return myPromise.resolve(callback()).then(() => value)//考虑finally中return一个异步函数的情况
        },reason=>{
            // callback()
            // throw reason
            return myPromise.resolve(callback()).then(() => {throw reason})
        })
    }
</pre>
12.catch方法的实现
用来处理当前promise对象最终为失败的情况
<pre>
catch(failCallback){
    return this.then(undefined, failCallback)
}
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/18/拉勾-手写Promise源码/" data-id="ckbm7478j004wb4xq8ko8tifh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾-手写Promise源码/">拉勾  手写Promise源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-JavaScript异步编程" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/17/拉勾-JavaScript异步编程/" class="article-date">
  <time datetime="2020-06-17T02:46:47.000Z" itemprop="datePublished">2020-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/拉勾-JavaScript异步编程/">拉勾-JavaScript异步编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.概述<br>1-1.采用单线程模式工作的原因<br>最早JavaScript是运行在浏览器中的脚本语言，为了实现页面上的动态交互，实现页面操作的核心是DOM操作，这也就决定了必须使用单线程，否则会出现很复杂的线程交互问题。比如JavaScript中多个线程一起工作，其中一个线程修改了元素，另外一个线程删除了该元素，浏览器就无法明确应该以哪个结果为准，为了避免这种问题，JavaScript被设计为单线程模式工作，也就成了这门语言最为核心的特性之一。<br>这里所说的单线程指的是在js执行环境中负责执行代码的线程只有一个。<br>所以每次只能执行一个任务，如果有多个任务就需要排队执行。优点是更安全更简单，缺点是如果遇到一个很耗时的任务，后面的任务都要等待导致整个程序会被拖延出现假死的情况。为了解决耗时任务阻塞的问题，JavaScript将任务的执行模式分为同步模式和异步模式。<br>1-2.我们这里主要关注异步模式:<br>·同步模式与异步模式<br>·事件循环与消息队列<br>·异步编程的几种方式<br>·Promise异步方案、宏任务/微任务队列<br>·Generator异步方案、async/await语法糖<br>2.同步模式<br>同步模式:代码中的任务依次执行，后面的任务必须等待前面的任务结束才能开始执行，程序的执行顺序与代码的编写顺序完全一致。在单线程情况下，大多数任务都会以同步模式执行(同步模式不是指同时执行，而是指排队执行)<br>同步模式代码例子:</p>
<p><pre><br>console.log(‘global begin’)<br>function bar () {<br>  console.log(‘bar task’)<br>}<br>function foo () {<br>  console.log(‘foo task’)<br>  bar()<br>}<br>foo()<br>console.log(‘global end’)<br></pre><br>下面几个图简单模拟了上面代码在函数调用栈中的执行(纯同步模式)<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_2.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_3.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_4.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_5.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_6.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_7.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_8.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_9.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_10.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_11.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_12.png"><br>我们之前也了解到，同步模式最大的问题就是如果某个操作十分耗时，而我们无法继续执行程序，就会造成程序的假死，用户体验变差，所以ajax/大文件读取等都采用异步操作<br>3.异步模式<br>异步模式不会等待这个任务的结束才开始执行下一个任务，对于耗时操作，都是开启过后就立即往后执行下一个任务，耗时任务的后续逻辑一般通过回调函数的方式定义，在内部耗时任务完成之后就会自动执行传入的回调函数。异步模式对JavaScript非常重要，如果没有异步模式单线程的JavaScript就无法同时处理大量耗时任务。对于开发者而言，单线程执行环境下的难点就是代码执行的顺序并不会像同步代码通俗易懂，需要理解和习惯。<br>下面我们通过一个例子开始了解</p>
<p><pre><br>console.log(‘global begin’)<br>setTimeout(function timer1 () {<br>  console.log(‘timer1 invoke’)<br>}, 1800)<br>setTimeout(function timer2 () {<br>  console.log(‘timer2 invoke’)<br>  setTimeout(function inner () {<br>    console.log(‘inner invoke’)<br>  }, 1000)<br>}, 1000)<br>console.log(‘global end’)<br></pre><br>执行过程大致如下<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_2.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_3.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_4.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_5.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_6.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_7.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_8.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_9.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_10.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_11.png"><br>到这里整体的匿名函数调用基本完成，调用栈清空，Event Loop上场，负责监听调用栈和消息队列，一旦调用栈所有任务都结束，事件循环就会从消息队列中取出第一个回调函数压入调用栈。此时当前代码的消息队列是空的，什么都没有，执行被暂停。现在我们看看倒计时器，自从被放入我们就没再关注过，而是直接往后执行<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_12.png"><br>由于timer2是1秒后执行比timer1的1.8秒早，那么timer2倒计时会先结束，会先被放入消息队列的第一位，然后timer1倒计时结束，被放入消息队列第二位<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_13.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_14.png"><br>一旦消息队列发生变化就会被事件循环监听到，就会把消息队列的第一个也就是timer2放到调用栈去执行timer2<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_15.png"><br>此时对调用栈来讲，相当于开启了新一轮的执行，执行过程与我们刚分析的是一样的<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_16.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_17.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_18.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_19.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_20.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_21.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_22.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_23.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_24.png"><br>我们可以这样理解:调用栈-正在执行的工作表，消息队列-待办工作表。js执行引擎先去执行调用栈中的任务，再通过事件循环从消息队列中取一个任务出来，以此类推。在这个过程中我们随时可以往消息队列中再放入任务，这些任务会在消息队列中排队等待放入事件循环。整个过程都是通过消息队列和事件循环去实现的。我们这里是分开分析的，但是不要因此认为这个步骤有先后顺序，各自有各自的timeline，例如倒计时器开始过后就会自动开始倒计时，跟本不会管调用栈/队列的情况。<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_25.png"><br>在这理要理解，虽然JavaScript是单线程执行的，但是浏览器并不是单线程的，浏览器会有 GUI 渲染线程、JavaScript引擎线程、定时触发器线程、事件触发线程、异步http请求线程。我们这里说的同步/异步是说运行环境提供的API是以同步/异步模式的方式工作。<br>4.回调函数<br>回调函数是所有异步编程方案的根基。<br>由调用者定义，交给执行者执行函数的函数就是回调函数。其实就是把函数作为参数传递，但是这种方式不利于阅读。除了传递回调参数以外，还有事件机制、发布订阅都是异步的实现方式。<br>5.Promise概述<br>用传统方式去完成复杂的异步流程就难免出现大量的回调函数的嵌套，也就是回调地狱问题。为了避免回调地狱，我们找到了promise这个解决方案(具体promise如何出现本处不细表)。<br>promise可以理解为一个对象，表示一个异步任务结束过后是成功还是失败。<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/5_1.png"><br>6.Promise基本用法</p>
<p><pre><br>// Promise 基本示例<br>const promise = new Promise(function (resolve, reject) {<br>  // 这里用于“兑现”承诺<br>  // resolve(100) // 承诺达成<br>  reject(new Error(‘promise rejected’)) // 承诺失败<br>})<br>promise.then(function (value) {<br>  // 即便没有异步操作，then 方法中传入的回调仍然会被放入队列，等待下一轮执行<br>  console.log(‘resolved’, value)<br>}, function (error) {<br>  console.log(‘rejected’, error)<br>})<br>console.log(‘end’)<br></pre><br>7.Promise使用案例</p>
<p><pre><br>// Promise 方式的 AJAX<br>function ajax (url) {<br>  return new Promise(function (resolve, reject) {<br>    var xhr = new XMLHttpRequest()<br>    xhr.open(‘GET’, url)<br>    xhr.responseType = ‘json’<br>    xhr.onload = function () {<br>      if (this.status === 200) {<br>        resolve(this.response)<br>      } else {<br>        reject(new Error(this.statusText))<br>      }<br>    }<br>    xhr.send()<br>  })<br>}<br>ajax(‘/api/foo.json’).then(function (res) {<br>  console.log(res)<br>}, function (error) {<br>  console.log(error)<br>})<br></pre><br>8.Promise常见误区<br>从表象上来看，promise的本质也是使用回调函数定义异步任务结束过后所需要执行的任务，只不过这里的回调函数是通过then方法传递的。按照这种思路，仍然会形成回调地狱，promise也就没有任何意义，还增加了额外的复杂度。<br>嵌套使用的方式是使用promise最常见的错误，实际上是借助于promise then方法链式调用的特点，尽量保证异步任务扁平化。<br>9.Promise链式调用</p>
<p><pre><br>// Promise 链式调用<br>function ajax (url) {<br>  return new Promise(function (resolve, reject) {<br>    var xhr = new XMLHttpRequest()<br>    xhr.open(‘GET’, url)<br>    xhr.responseType = ‘json’<br>    xhr.onload = function () {<br>      if (this.status === 200) {<br>        resolve(this.response)<br>      } else {<br>        reject(new Error(this.statusText))<br>      }<br>    }<br>    xhr.send()<br>  })<br>}<br>var promise = ajax(‘/api/users.json’)<br>var promise2 = promise.then(<br>  function onFulfilled (value) {<br>    console.log(‘onFulfilled’, value)<br>  },<br>  function onRejected (error) {<br>    console.log(‘onRejected’, error)<br>  }<br>)<br>console.log(promise2)//这里是说明promise内部返回的也是一个promise对象<br>console.log(promise2 === promise)//false<br></pre><br>promise!==promise2说明这里的链式调用返回的是一个全新的promise，不是传统的this来链式调用 </p>
<p><pre><br>ajax(‘/api/users.json’)<br>  .then(function (value) {<br>    console.log(1111)<br>    return ajax(‘/api/urls.json’)<br>  }) // =&gt; Promise<br>  .then(function (value) {<br>    console.log(2222)<br>    console.log(value)<br>    return ajax(‘/api/urls.json’)<br>  }) // =&gt; Promise<br>  .then(function (value) {<br>    console.log(3333)<br>    return ajax(‘/api/urls.json’)<br>  }) // =&gt; Promise<br>  .then(function (value) {<br>    console.log(4444)<br>    return ‘foo’<br>  }) // =&gt; Promise<br>  .then(function (value) {<br>    console.log(5555)<br>    console.log(value)<br>  })<br></pre><br>如果不断的链式调用then，这里每个then方法都是在为上一个then方法返回的promise添加状态明确过后的回调。promise会依次执行，那么回调函数也就回从前到后依次执行。也可以在then中手动执行返回一个promise对象。如果我们在回调当中返回的是一个普通的值，这个值会作为当前then方法返回的promise中的值，在下一个then方法中接收的回调参数就是这个值。<br>下图返回了上面代码的部分执行结果<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/9_1.png"><br>小结:<br>·Promise对象的then方法会返回一个全新的Promise对象(可以使用链式调用)<br>·后面的then方法就是在为上一个then返回的Promise注册回调<br>·前面then方法中回调函数的返回值会作为后面then方法回调的参数<br>·如果回调中返回的是Promise，那后面then方法的回调会等待它的结束<br>10.Promise异常处理<br>promise结果一旦失败就会调用我们传入的rejected函数，如果在promise执行过程中出现异常或者手动抛出异常rejected回调也会被执行。<br>一般我们会用catch去执行一场回调，这里catch相当于给前面的then方法执行异常回调。用catch和用resolve/reject不同之处在于，resolve/reject相当于给指定promise做回调，而catch相当于给catch之前的then做回调</p>
<p><pre><br>ajax(‘/api/users.json’)<br>  .then(function onFulfilled (value) {<br>    console.log(‘onFulfilled’, value)<br>    return ajax(‘/error-url’)<br>  }, function onRejected (error) {<br>    console.log(‘onRejected’, error)//这里不能捕获ajax(‘/error-url’)的异常，只能捕获ajax(‘/api/users.json’)的异常<br>  })<br></pre></p>
<p><pre><br>ajax(‘/api/users.json’)<br>  .then(function onFulfilled (value) {<br>    console.log(‘onFulfilled’, value)<br>    return ajax(‘/error-url’)<br>  })<br>  .catch(function onRejected (error) {<br>  //这里的catch相当于给ajax(‘/error-url’)做的回调，不能捕获ajax(‘/api/users.json’)的异常<br>    console.log(‘onRejected’, error)<br>  })<br></pre><br>所以链式调用的情况下我们尽量用catch方法，这样如果有异常就会被回调。或者我们可以注册一个全局异常事件处理代码中没有被捕获的异常<br>在window环境中</p>
<p><pre><br>window.addEventListener(‘unhandledrejection’,event =&gt; {<br>    const { reason,promise } = event<br>    console.log(reason,promise)<br>    //reason =&gt; Promise 失败原因，一般是一个错误对象<br>    // promise =&gt; 出现异常的 Promise 对象<br>    event.preventDefault()<br>},false)<br></pre><br>在node环境中</p>
<p><pre><br>process.on(‘unhandledRejection’, (reason, promise) =&gt; {<br>  console.log(reason, promise)<br>  // reason =&gt; Promise 失败原因，一般是一个错误对象<br>  // promise =&gt; 出现异常的 Promise 对象<br>})<br></pre><br>最好的方法是在代码中明确捕获每一个可能的异常，所以全局捕获的方法并不推荐使用<br>11.Promise静态方法<br>11-1.Promise.resolve()//快速把一个值转换为promise对象，返回一个状态为fullfilled的promise对象<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/11_1.png"></p>
<p><pre><br>Promise.resolve(‘foo’)<br>  .then(function (value) {<br>    console.log(value)<br>  })<br>//这里两种方法是等价的，返回foo这个字符串<br>new Promise(function (resolve, reject) {<br>  resolve(‘foo’)<br>})<br></pre><br>如果传入的是一个 Promise 对象，Promise.resolve 方法原样返回</p>
<p><pre><br>var promise = ajax(‘/api/users.json’)<br>var promise2 = Promise.resolve(promise)<br>console.log(promise === promise2)//true<br></pre><br>如果传入的是带有一个跟 Promise 一样的 then 方法的对象，Promise.resolve 会将这个对象作为 Promise 执行<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/11_2.png"><br>11-2.Promise.reject//快速创建一个失败状态的promise对象，传入的数据会作为失败的原因<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/11_3.png"><br>12.Promise并行执行<br>12-1.Promise.all()将多个promise合并为一个promise去管理，会在所有任务结束后才会结束</p>
<p><pre><br>var promise = Promise.all([<br>  ajax(‘/api/users.json’),<br>  ajax(‘/api/posts.json’)<br>])//返回一个全新的promise<br>//当内部所有的promise都完成了，所返回的全新promise才会完成<br>promise.then(function (values) {<br>  console.log(values)<br>}).catch(function (error) {<br>  console.log(error)<br>})<br></pre><br>这里promise对象拿到的结果是一个数组，在数组中包含每一个异步任务执行的结果<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/12_1.png"></p>
<p><pre><br>ajax(‘/api/urls.json’)//去请求包含所有url的对象<br>  .then(value =&gt; {<br>    const urls = Object.values(value)<br>    const tasks = urls.map(url =&gt; ajax(url))<br>    return Promise.all(tasks)<br>  })<br>  .then(values =&gt; {<br>    console.log(values)<br>  })<br></pre><br>12-2.Promise.race()把多个promise对象组合为一个全新的promise对象，只会等待所有任务中第一个结束的任务</p>
<p><pre><br>const request = ajax(‘/api/posts.json’)<br>const timeout = new Promise((resolve, reject) =&gt; {<br>  setTimeout(() =&gt; reject(new Error(‘timeout’)), 500)<br>})<br>Promise.race([<br>  request,<br>  timeout<br>])<br>.then(value =&gt; {<br>  console.log(value)<br>})<br>.catch(error =&gt; {<br>  console.log(error)<br>})<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/12_2.png"><br>13.Promise执行时序<br>即便promise中并没有任何异步操作，它的回调函数仍然会进入到回调队列当中排队，也就是说我们要等当前同步代码执行完毕才能promise中的回调。当然，这句话并不是十分严谨</p>
<p><pre><br>console.log(‘global start’)<br>Promise.resolve().then(()=&gt;{<br>    console.log(‘promise’)<br>})<br>console.log(‘global end’)<br></pre><br>上面代码执行结果<br>global start<br>global end<br>promise</p>
<p>那如果我们稍作修改</p>
<p><pre><br>console.log(‘global start’)<br>Promise.resolve()<br>  .then(() =&gt; {<br>    console.log(‘promise’)<br>  })<br>  .then(() =&gt; {<br>    console.log(‘promise 2’)<br>  })<br>  .then(() =&gt; {<br>    console.log(‘promise 3’)<br>  })<br>console.log(‘global end’)<br></pre><br>则执行结果为<br>global start<br>global end<br>promise<br>promise 2<br>promise 3</p>
<p>如果再加上setTimeout呢</p>
<p><pre><br>console.log(‘global start’)<br>// setTimeout 的回调是 宏任务，进入回调队列排队<br>setTimeout(() =&gt; {<br>  console.log(‘setTimeout’)<br>}, 0)<br>// Promise 的回调是 微任务，本轮调用末尾直接执行<br>Promise.resolve()<br>  .then(() =&gt; {<br>    console.log(‘promise’)<br>  })<br>  .then(() =&gt; {<br>    console.log(‘promise 2’)<br>  })<br>  .then(() =&gt; {<br>    console.log(‘promise 3’)<br>  })<br>console.log(‘global end’)<br></pre><br>我们发现执行结果为<br>global start<br>global end<br>promise<br>promise 2<br>promise 3<br>setTimeout</p>
<p>如何理解上面的执行结果呢<br>我们一般将回调队列中的任务称之为”宏任务”，宏任务执行过程当中可以临时加上一些额外需求，这些临时额外需求可以选择作为一个新的宏任务进到队列中排队，也可以作为当前任务的”微任务”，直接在当前任务结束过后立即执行。Promise的回调会作为微任务执行，会在本轮调用结束的末尾去执行，而setTimmeout会作为宏任务进入回调队列的末尾，所以先打印promise，再打印setTimeout。<br>微任务的概念是在后来才被引入js中的，目的是为了提高整体相应能力。目前绝大多数异步调用都是作为宏任务执行，但是promise和MutationObserver以及node当中的process.nextTick都会作为微任务直接在本轮调用的末尾执行。<br>14.Generator 异步方案(上)<br>Promise虽然解决异步回调的回调地狱问题已经很好了，但是如果我们想更清晰的像看同步代码一样的可读性，可以了解下ES2015提供的Generator</p>
<p><pre><br>function * foo () {<br>  console.log(‘start’)<br>  yield ‘foo’<br>}<br>const generator = foo()<br>const result = generator.next()<br>console.log(result)<br></pre><br>上面代码我们需要了解生成器函数只有在next()调用的时候才会执行，我们也可以在next()对象返回值中拿到yield的返回值<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/14_1.png"><br>另外我们还可以看到返回值里有个done属性，用来表示生成器是否已经全部执行完成，yield只是暂停函数的执行，并不是结束函数的执行，直到我们下次调用next方法，就会继续从yield位置往下执行。</p>
<p><pre><br>function * foo () {<br>  console.log(‘start’)<br>  yield ‘foo’<br>}<br>const generator = foo()<br>const result = generator.next()<br>console.log(result)<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/14_2.png"><br>也就是说如果我们调用next方法的时候传递参数，会作为yield语句的返回值，也就是说我们可以定义变量，把yield的返回值赋给这个变量</p>
<p><pre><br>function * foo () {<br>  console.log(‘start’)<br>  try {<br>    const res = yield ‘foo’<br>    console.log(res)<br>  } catch (e) {<br>    console.log(e)<br>  }<br>}<br>const generator = foo()<br>const result = generator.next()<br>console.log(result)<br>// generator.next(‘bar’)<br>generator.throw(new Error(‘Generator error’))<br></pre><br>如果我们在外部调用生成器对象的throw方法，就可以对生成器函数内部抛出一个异常，内部往下执行的时候就会得到这个异常，我们可以通过try/catch去捕获这个异常<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/14_3.png"><br>15.Generator 异步方案(中)<br>借助yield可以暂停生成器函数执行的特点来使用生成器函数来实现更优的异步编程体验<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/15_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/15_2.png"><br>16.Generator 异步方案(下)<br>用递归的方式实现一个更通用的函数生成器</p>
<p><pre><br>// Async / Await 语法糖<br>function ajax (url) {<br>  return new Promise((resolve, reject) =&gt; {<br>    var xhr = new XMLHttpRequest()<br>    xhr.open(‘GET’, url)<br>    xhr.responseType = ‘json’<br>    xhr.onload = () =&gt; {<br>      if (xhr.status === 200) {<br>        resolve(xhr.response)<br>      } else {<br>        reject(new Error(xhr.statusText))<br>      }<br>    }<br>    xhr.send()<br>  })<br>}<br>function co (generator) {<br>  const g = generator()<br>  function handleResult (result) {<br>    if (result.done) return // 生成器函数结束<br>    result.value.then(data =&gt; {<br>      handleResult(g.next(data))<br>    }, error =&gt; {<br>      g.throw(error)<br>    })<br>  }<br>  handleResult(g.next())<br>}<br>async function main () {<br>  try {<br>    const users = await ajax(‘/api/users.json’)<br>    console.log(users)<br>    const posts = await ajax(‘/api/posts.json’)<br>    console.log(posts)<br>    const urls = await ajax(‘/api/urls.json’)<br>    console.log(urls)<br>  } catch (e) {<br>    console.log(e)<br>  }<br>}<br>// co(main)<br>const promise = main()<br>promise.then(() =&gt; {<br>  console.log(‘all completed’)<br>})<br></pre><br>17.Async函数<br>async/await语法糖是语言层面的异步标准编程，有了async/await我们不再用generator这样的函数，因为generator需要配合co等执行器。async函数返回一个promise对象，await目前只能在async函数内使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/17/拉勾-JavaScript异步编程/" data-id="ckbm74776004nb4xqusr6ny4o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾-JavaScript异步编程/">拉勾 JavaScript异步编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-移动端APP开发工程师-移动UI框架Flutter-2-1-1-Flutter概述及开发环境" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/15/网易微专业-移动端APP开发工程师-移动UI框架Flutter-2-1-1-Flutter概述及开发环境/" class="article-date">
  <time datetime="2020-06-15T08:18:19.000Z" itemprop="datePublished">2020-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/15/网易微专业-移动端APP开发工程师-移动UI框架Flutter-2-1-1-Flutter概述及开发环境/">网易微专业-移动端APP开发工程师-移动UI框架Flutter-2.1.1-Flutter概述及开发环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.初识Flutter<br>1-1.Flutter是什么<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_1.png"><br>1-2.跨平台开发方案<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_2.png"><br>下面图中三个部分依次对应三个不同的跨平台开发方案的时代<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_3.png"><br>上图左上角对应web时代开发方案:主要采用原生应用内嵌于浏览器空间webview。并且定义html5和原生代码交互协议，将部分原生系统能力暴露给html5，从而扩展html5的边界，这类交互协议就是我们通常说的jsBridge。一个完整html5页面的展示要经历浏览器的控件的加载、解析、渲染三大过程，浏览器消耗要比原生开发增加了N个数量级。html5页面的展示是比较复杂的，这和原生开发通过简单直接的创建控件、设置属性后即可完成页面渲染有很大的差异。web和原生在UI渲染和系统功能调用各司其职。<br>右上角是泛web容器时代解决方案的原理图:泛web容器时代优化了web容器时代的加载、解析和渲染这三大过程。它把影响他们独立运行的web标准进行了裁剪，以相对简单的方式支持构建移动端页面的web标准，也保证了便捷的开发体验。同时这个时代的开发方案基本完全放弃了浏览器控件的渲染，而是采用了原生自带的UI组件实现代替了核心的渲染引擎，仅保持必要的基本控件渲染能力，从而使得渲染过程更加简化，也保证了良好的渲染性能。也就是说在web容器时代我们仍然采用的是前端由JavaScript进行开发，整体加载渲染机制大大简化，并且由原生接管绘制。<br>最后中间的图是自绘引擎时代的开发原理:泛web时代采用的是使用原生控件承载界面渲染，固然解决了不少性能问题，但是也同时带来了一些新的问题。抛开框架本身需要大量平台相关的逻辑，随着系统版本的变化和API的变化，我们可能需要处理不同平台原生控件渲染能力的差异，修复各类奇奇怪怪的bug。而在自绘引擎时代，这一新时期的代表Flutter则开辟了一个全新的思路，从头到尾重写了一套跨平台UI框架，包括渲染逻辑甚至是开发语言。Flutter的渲染引擎依靠跨平台的Skia图形库来实现。Skia引擎会将使用大的构建的抽象视图数据加工成GPU数据，然后交由OpenGL，最终提供给GPU渲染，因此可以在最大程度上保证一款应用在不同平台不同设备上的体验一致性。而对于开发语言来讲，开发语言选用的是同时支持JIT和AOT模式的Dart语言。不仅保证了开发效率，更是提升了执行效率。<br>1-3.我该选择哪一类跨平台开发方案<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_4.png"><br>1-4.Flutter框架结构<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_5.png"><br>2.开发环境搭建<br>2-1.开发环境搭建<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_6.png"><br>3.Flutter项目结构</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/15/网易微专业-移动端APP开发工程师-移动UI框架Flutter-2-1-1-Flutter概述及开发环境/" data-id="ckbm7473n003hb4xqy2xb0ipp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-函数式编程范式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/拉勾-函数式编程范式/" class="article-date">
  <time datetime="2020-06-14T10:27:36.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/拉勾-函数式编程范式/">拉勾-函数式编程范式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>6.高阶函数-函数作为返回值</p>
<p><pre><br>function makeFn(){<br>    let msg = ‘Hello function’;<br>    return function(){<br>        console.log(msg);<br>    }<br>}<br>const fn = makeFn()<br>fn()//调用返回函数<br>makeFn()()//和fn()其实调用结果是一致的<br></pre><br>下面我们模拟once(只执行一次的函数)执行</p>
<p><pre><br>function once(fn){<br>    let done = false;<br>    return function(){<br>        if(!done){<br>            done = true;<br>            return fn.apply(this,arguments)<br>        }<br>    }<br>}<br>let pay = once(function(money){<br>    console.log(<code>支付:${money}RMB</code>)<br>})<br>pay(5)<br>pay(5)<br>pay(5)<br></pre><br>7.高阶函数的意义<br>使用高阶函数的意义:抽象可以帮我们屏蔽细节，只需要关注于我们的目标；高阶函数是用来抽象通用的问题<br>举例我们需要打印数组中的所有元素 </p>
<p><pre><br>//面向过程的方式<br>let array = [1,2,3,4]<br>for(let i =0; i &lt; array.length; i++){<br>    console.log(array[i])<br>}<br>//高阶函数<br>let array = [1,2,3,4]<br>forEach(array,(item)=&gt;{<br>    consle.log(item)<br>})<br>//这里是过滤<br>let r = filter(array,(item)=&gt;{<br>    return item % 2 === 0<br>})<br></pre><br>总之我们发现，使用高阶函数能让我们的函数变得很灵活，抽象可以帮助我们屏蔽实现的细节，以后再调用函数，只需要关注我们实现的目标就可以了<br>8.常用的高阶函数<br>模拟常用高阶函数map/every/some<br>8-1.map</p>
<p><pre><br>//这里用const定义是因为我们不希望在我们写好之后被别人修改<br>const map = (array,fn)=&gt;{<br>    let results = []<br>    for(let value of array){<br>        results.push(fn(value))<br>    }<br>    return results<br>}<br>//测试<br>let arr = [1,2,3,4]<br>arr = map(arr,(v)=&gt;v*v)<br>console.log(arr)<br></pre><br>8-2.every</p>
<p><pre><br>const every = (array,fn)=&gt;{<br>    let result = true;<br>    for(let value of array){<br>        result = fn(value)<br>        if(!result){<br>            break;<br>        }<br>    }<br>    return result<br>}<br>//测试<br>let arr = [11,12,14]<br>let r = every(arr,v=&gt; v &gt; 10)<br>console.log(r)<br></pre><br>8-3.some</p>
<p><pre><br>const some = (array,fn)=&gt;{<br>    let result = false;<br>    for(let value of array){<br>        result = fn(value)<br>        if(result){<br>            break;<br>        }<br>    }<br>    return result<br>}<br>//测试<br>let arr = [1,3,4,9]<br>let r = some(arr,v=&gt;v%2===0)<br>console.log(r)<br></pre><br>9.闭包-概念<br>闭包(Closure):函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包。可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。<br>闭包的本质:函数在执行的时候会放到一个执行栈上，当函数执行完毕后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。<br>之前课程中的例子</p>
<p><pre><br>function makeFn(){<br>    let msg = ‘Hello function’;<br>    return function(){<br>        console.log(msg);<br>    }<br>}<br></pre><br>就能体现关于闭包的概念。一般情况下，在makeFn中定义的变量msg会随着makeFn在执行栈中执行完毕被移除，但是因为return了一个函数，所以makeFn内部的成员不会被移除，依然能访问外部函数。<br>闭包延长了内部函数的作用范围。<br>10.闭包-案例<br>比如我们经常需要求一个数的平方/立方，那么就会用到Math.pow(4,2)，而我们需要经常传递第二个参数为2/3，我们想简化这个过程，不需要经常传递2/3</p>
<p><pre><br>function makePower(power){<br>    return function(number){<br>        return Math.pow(number,power)<br>    }<br>}<br>//求平方<br>let power2 = makePower(2)<br>//求立方<br>let power3 = makePower(3)<br>//测试<br>console.log(power2(4))<br>console.log(power2(5))<br>console.log(power3(4))<br></pre><br>初步了解了闭包的例子，我们现在满足这样一个需求：求工资，也就是工资是由基本工资和绩效工资组成，每个职级的基本工资是固定的，但是绩效工资不一样，我们来求不同级别的员工生成工资的函数 </p>
<p><pre><br>function getSalary(base){<br>    //参数base为基本工资<br>    return function(performance){<br>        //参数performance为绩效工资<br>        return base + performance<br>    }<br>}<br>//测试<br>let getSalaryLevel1 = getSalary(12000)<br>let getSalaryLevel2 = getSalary(15000)<br>console.log(getSalaryLevel1(2000))<br>console.log(getSalaryLevel2(3000))<br></pre><br>在这节课程中，我们可以打开浏览器调试工具，在程序中打断点观察程序的执行过程，了解执行栈和作用域<br>11.纯函数概念<br>纯函数:相同的输入永远会得到相同的输出，而且没有任何可观察的副作用(后面的课程会讲什么是副作用)。纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，y=f(x)<br>lodash是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法。<br>数组的slice和splice分别是纯函数和不纯的函数:<br>·slice返回数组中指定部分，不会改变原数组<br>·splice对数组进行操作返回该数组，会改变原数组</p>
<p><pre><br>let array = [1,2,3,4,5]<br>//纯函数<br>console.log(array.slice(0,3))<br>console.log(array.slice(0,3))<br>console.log(array.slice(0,3))<br>//非纯函数<br>console.log(array.splice(0,3))<br>console.log(array.splice(0,3))<br>console.log(array.splice(0,3))<br></pre><br>执行之后我们发现slice和splice之间的区别，也就是纯函数和非纯函数之间的区别</p>
<p><pre><br>//纯函数<br>function getSum(n1,n2){<br>    return n1 + n2<br>}<br>console.log(getSum(1,2))<br>console.log(getSum(1,2))<br>console.log(getSum(1,2))<br></pre><br>对于getSum函数，我们每次输入1，2之后的输出结果都是相同的，也就是纯函数。举了简单例子来说明纯函数，后面我们将学习更多纯函数的用法。<br>函数式编程不会保留中间计算的结果，所以变量是不可变的(无状态的)<br>我们可以把一个函数的执行结果交给另一个函数去处理<br>12.lodash<br>lodash纯函数的代表<br>这个小节，我们会展示一些常用lodash的使用方法，我们可以用npm init -y初始化一个项目，并且安装lodash</p>
<p><pre><br>//first/last/toUpper/reverse/each/includes/find/findIndex<br>const _ = require(‘lodash’);<br>const array = [‘jack’,’tom’,’lucy’,’kate’];<br>console.log(<em>.first(array))<br>console.log(</em>.last(array))<br>console.log(<em>.toUpper(</em>.first(array)))<br>console.log(_.reverse(array))<br>const r = _.each(array,(item,index)=&gt;{<br>    console.log(item,index)<br>})<br>console.log(r)<br></pre><br>剩下的几个我们可以自己练习<br>13.纯函数的好处<br>纯函数的好处:<br>(1)可缓存:因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来<br>(2)可测试:纯函数让测试更方便<br>(3)并行处理:在多线程的环境下并行操作共享的内存数据很可能会出现意外的情况；纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数(Web Worker)<br>这里我们还是通过lodash的函数来演示，功能是求圆的面积</p>
<p><pre><br>const _ = require(‘lodash’);<br>function getArea(r){<br>    console.log(r);//这里的console.log是为了展示，并非功能<br>    return Math.PI<em>r</em>r<br>}<br>let getAreaWithMemory = _.memoize(getArea)<br>console.log(getAreaWithMemory(4))<br>console.log(getAreaWithMemory(4))<br>console.log(getAreaWithMemory(4))<br></pre><br>当我们执行上面的代码发现，getArea的参数只打印了一次，因为我们用了lodash的记忆函数。接下来我们模拟memoize这个方法的实现</p>
<p><pre><br>function memoize(f){<br>    let cache = {}<br>    return function(){<br>        let key = JSON.stringify(arguments)<br>        cache[key] = cache[key] || f.apply(f,arguments)<br>        return cache[key]<br>    }<br>}<br></pre><br>14.副作用<br>纯函数:对于相同的输入永远会得到相同的输出，而且没有任何可观察到副作用</p>
<p><pre><br>//不纯的<br>//本例中如果mini的值改变就会导致调用checkAge对相同的数值输出不同的结果<br>let mini = 18<br>function checkAge (age) {<br>    return age &gt;= mini<br>}<br>//纯的(有硬编码，后续可以通过柯里化解决)<br>function checkAge (age) {<br>    let mini = 18<br>    return age &gt;= mini<br>}<br></pre><br>副作用让一个函数变的不纯(如上例)，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。<br>副作用来源：<br>·配置文件<br>·数据库<br>·获取用户的输入<br>·……<br>所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。<br>15.柯里化(Haskell Brooks Curry)<br>在上一小节中，checkAge这个函数有一个硬编码的问题，这里我们用柯里化解决</p>
<p><pre><br>//有硬编码问题<br>function checkAge (age) {<br>    let mini = 18<br>    return age &gt;= mini<br>}<br>//改造为普通的纯函数<br>function checkAge (min,age) {<br>    return age &gt;= min<br>}<br>//测试<br>console.log(checkAge(18,20))<br>console.log(checkAge(18,24))<br>console.log(checkAge(22,24))<br>//改造为我们之前学的闭包函数<br>function checkAge(min){<br>    return function(age){<br>        return age &gt;= min<br>    }<br>}<br>//测试<br>let checkAge18 = checkAge(18)<br>let checkAge20 = checkAge(20)<br>console.log(checkAge18(20))<br>console.log(checkAge18(24))<br>//用箭头函数实现<br>let checkAge = min =&gt; (age =&gt; age &gt;= min)<br></pre><br>通过上面的改造我们可以大致了解柯里化的含义就是:当函数有多个参数的时候，我们可以对函数进行改造，我们可以调用一个函数只传递部分的参数并且让这个函数返回一个新的函数，新的函数接收剩余的参数，并且返回相应的结果。课程讲义里给的对于柯里化的总结是:<br>柯里化 (Currying)：<br>·当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）<br>·然后返回一个新的函数接收剩余的参数，返回结果<br>16.lodash中的柯里化方法</p>
<p><pre>_.curry(func)</pre><br>·功能：创建一个函数，该函数接收一个或多个func的参数，如果func所需要的参数都被提供则执行func并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。<br>·参数：需要柯里化的函数<br>·返回值：柯里化后的函数</p>
<p><pre><br>//将多元(多个参数)函数转换为一元(一个参数)的函数<br>const _ = require(‘lodash’)<br>function getSum (a, b, c) {<br>    return a + b + c<br>}<br>let curried = _.lodash(getSum)<br>//测试<br>console.log(curried(1, 2, 3))<br>console.log(curried(1)(2)(3))<br>console.log(curried(1, 2)(3))<br></pre><br>17.柯里化案例<br>我们现在有这样的需求<br>‘’.match(/\s+/g)<br>‘’.match(/\d+/g)<br>很明显我们这样写不是优雅的写法<br>于是我们想到用函数方式</p>
<p><pre><br>function match(reg,str){<br>    return str.match(reg)<br>}<br></pre><br>如果我们需要经常获取字符串中所有空白，那这个函数需要很多重复，于是我们想到柯里化函数，这里用lodash中的curry</p>
<p><pre><br>const _ = require(‘lodash’)<br>const match = _.curry(function(reg,str){<br>    return str.match(reg)<br>})<br>const haveSpace = match(/\s+/g)<br>const haveNumber = match(/\d+/g)<br>console.log(haveSpace(‘hello world’))<br>console.log(haveNumber(‘25$’))<br></pre><br>现在我们将filter封装为一个柯里化函数</p>
<p><pre><br>const filter = _.curry(function (func, array) {<br>    return array.filter(func)<br>})<br>console.log(filter(haveSpace, [‘John Connor’, ‘John_Donne’]))<br>//进一步改造<br>const findSpace = filter(haveSpace)<br>console.log(findSpace([‘John Connor’, ‘John_Donne’]))<br></pre><br>18.柯里化原理模拟</p>
<p><pre><br>//const _ = require(‘lodash’)<br>function getSum (a, b, c) {<br>    return a + b + c<br>}<br>//const curried = <em>.curry(getSum)//换成我们自己写的curry测试<br>const curried = curry(getSum)<br>function curry(func){<br>    return function curriedFn (…args){<br>        // 判断实参和形参的个数<br>        if(args.length &lt; func.length){<br>            return function (){<br>                return curriedFn(…args.concat(Array.from(arguments)))<br>            }<br>        }<br>        // 实参和形参个数相同，调用 func，返回结果<br>        return func(…args)<br>    }<br>}<br>console.log(curried(1)(2)(3))<br>console.log(curried(1)(2,3))<br>console.log(curried(1,2)(3))<br></em></pre><br>19.柯里化总结<br>·柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数<br>·这是一种对函数参数的’缓存’<br>·让函数变的更灵活，让函数的粒度更小<br>·可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能<br>20.函数组合概念<br>·纯函数和柯里化很容易写出洋葱代码 h(g(f(x)))<br> ·获取数组的最后一个元素再转换成大写字母<br> <pre>.toUpper(<em>.first(</em>.reverse(array)))</pre><br>·函数组合可以让我们把细粒度的函数重新组合生成一个新的函数<br>管道<br>下面这张图表示程序中使用函数处理数据的过程，给 fn 函数输入参数 a，返回结果 b。可以想想 a 数据通过一个管道得到了 b 数据。<br><img src="https://snakexu.github.io/images/lagou/part_1/20_1.png"><br>当 fn 函数比较复杂的时候，我们可以把函数 fn 拆分成多个小函数，此时多了中间运算过程产生的 m 和 n。<br>下面这张图中可以想象成把 fn 这个管道拆分成了3个管道 f1, f2, f3，数据 a 通过管道 f3 得到结果 m，m 再通过管道 f2 得到结果 n，n 通过管道 f1 得到最终结果 b。对比上面直接通过管道fn生成所要结果，在f1、f2、f3中如果发生问题，我们更容易定位问题位置。<br><img src="https://snakexu.github.io/images/lagou/part_1/20_2.png"><br>使用伪代码描述下上图</p>
<p><pre><br>fn = compose(f1, f2, f3) //在处理过程中f1，f2，f3会产生一些中间结果，我们忽视这些<br>b = fn(a)<br></pre><br>函数组合<br>·函数组合 (compose)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数<br> ·函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果<br> ·函数组合默认是从右到左执行</p>
<p><pre><br>//先假设我们需要一个两个函数组合的函数<br>function compose(f,g){<br>    return function(value){<br>        return f(g(value))<br>    }<br>}<br></pre><br>现在假设我们需要获取数组中最后一个元素，用先反转再获取到数组中第一个元素方法</p>
<p><pre><br>//反转<br>function reverse(array){<br>    return array.reverse()<br>}<br>function first(array){<br>    return array[0]<br>}<br>const last = compose(first,reverse)<br>console.log(last([1,2,3,4]))<br></pre><br>21.lodash中的组合函数<br>·lodash 中组合函数 flow() 或者 flowRight()，他们都可以组合多个函数<br>·flow() 是从左到右运行<br>·flowRight() 是从右到左运行，使用的更多一些</p>
<p><pre><br>const _ = require(‘lodash’)<br>const toUpper = s =&gt; s.toUpperCase()<br>const reverse = arr =&gt; arr.reverse()<br>const first = arr =&gt; arr[0]<br>const f = _.flowRight(toUpper, first, reverse)<br>console.log(f([‘one’, ‘two’, ‘three’]))<br></pre><br>22.组合函数原理模拟</p>
<p><pre><br>// 多函数组合<br>function compose (…fns) {<br>    return function (value) {<br>        return fns.reverse().reduce(function (acc, fn) {<br>            return fn(acc)<br>        }, value)<br>    }<br>}<br>const toUpper = s =&gt; s.toUpperCase()<br>const reverse = arr =&gt; arr.reverse()<br>const first = arr =&gt; arr[0]<br>const f = compose(toUpper, first, reverse)<br>console.log(f([‘one’, ‘two’, ‘three’]))<br></pre><br>或者我们用箭头函数重写compose</p>
<p><pre><br>const compose = (…fns) =&gt; value =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), value)<br></pre><br>23.函数组合-结合律<br>函数的组合要满足结合律 (associativity)：<br>·我们既可以把 g 和 h 组合，还可以把 f 和 g 组合，结果都是一样的<br>用代码描述就是</p>
<p><pre><br>// 结合律（associativity）<br>let f = compose(f, g, h)<br>let associative = compose(compose(f, g), h) == compose(f, compose(g, h))<br>// true<br></pre><br>用lodash中的flowright来感受下</p>
<p><pre><br>const _ = require(‘lodash’)<br>//这里我们不再用自己写的函数了，而是用lodash<br>const f = <em>.flowRight(</em>.toUpper, _.first, _.reverse)<br>const g = <em>.flowRight(</em>.flowRight(_.toUpper, _.first), _.reverse)<br>const h = <em>.flowRight(</em>.toUpper, <em>.flowRight(</em>.first, _.reverse))<br>console.log(f([‘one’, ‘two’, ‘three’])) // =&gt; THREE<br>console.log(g([‘one’, ‘two’, ‘three’])) // =&gt; THREE<br>console.log(h([‘one’, ‘two’, ‘three’])) // =&gt; THREE<br></pre><br>24.函数组合-调试<br>如何调试组合函数</p>
<p><pre><br>const f = <em>.flowRight(</em>.toUpper, _.first, _.reverse)<br>console.log(f([‘one’, ‘two’, ‘three’]))<br></pre><br>需求:NEVER SAY DIE -&gt; never-say-die</p>
<p><pre><br>//<em>.split与</em>.join都是有多个参数，而我们在函数组合的时候不能使用多个参数，于是我们略作修改<br>const split = <em>.curry((sep,str)=&gt;</em>.split(str,sep))//sep-分隔符，str-字符串<br>const join = <em>.curry((sep,array)=&gt;</em>.join(array,sep))<br>//打印下某个函数的执行结果<br>const log = v =&gt; {<br>    console.log(v)<br>    return v<br>}<br>//结果为n-e-v-e-r-,-s-a-y-,-d-i-e-<br>//const f = _.flowRight(join(‘-‘), _.toLower, split(‘ ‘))//发现结果并不是我们预期的<br>//查看中间某个过程的打印结果，这里打印的结果显示split之后的操作是符合我们预期的[“NEVER”,”SAY”,”DIE”]<br>//const f = _.flowRight(join(‘-‘), _.toLower, log, split(‘ ‘))<br>//发现了问题的所在，toLower把split分割成的数组转换为了字符串never,say,die<br>//const f = _.flowRight(join(‘-‘),log,  _.toLower, split(‘ ‘)<br>console.log(f(‘NEVER SAY DIE’))<br></pre><br>在上面代码中我们发现了问题，toLower函数将split分割的数组转化为了字符串，我们应该用map函数，即对数组进行操作</p>
<p><pre><br>const split = <em>.curry((sep,str)=&gt;</em>.split(str,sep))<br>const join = <em>.curry((sep,array)=&gt;</em>.join(array,sep))<br>const map = <em>.curry((fn,array)=&gt;</em>.map(array,fn))<br>//为了解决log打印结果不清晰的问题，我们改造log<br>// const log = v =&gt; {<br>//      console.log(v)<br>//      return v<br>// }<br>const trace = _.curry((tag, v) =&gt; {<br>    console.log(tag, v)<br>    return v<br>})<br>//const f = <em>.flowRight(join(‘-‘), map(</em>.toLower), split(‘ ‘)//已经满足我们的需求<br>//如果我们两次打印log，不能区分是哪个log打印<br>//const f = <em>.flowRight(join(‘-‘), log, map(</em>.toLower), log, split(‘ ‘)<br>const f = <em>.flowRight(join(‘-‘), trace(‘map 之后’), map(</em>.toLower), trace(‘split 之后’), split(‘ ‘))<br>console.log(f(‘NEVER SAY DIE’))<br></pre><br>25.lodash-fp模块<br>·lodash 的 fp 模块提供了实用的对函数式编程友好的方法<br>·提供了不可变 auto-curried iteratee-first data-last 的方法</p>
<p><pre><br>// lodash 模块<br>const _ = require(‘lodash’)<br>_.map([‘a’, ‘b’, ‘c’], _.toUpper)<br>// =&gt; [‘A’, ‘B’, ‘C’]<br>_.map([‘a’, ‘b’, ‘c’])<br>// =&gt; [‘a’, ‘b’, ‘c’]<br>_.split(‘Hello World’, ‘ ‘)<br>// lodash/fp 模块<br>const fp = require(‘lodash/fp’)<br>fp.map(fp.toUpper, [‘a’, ‘b’, ‘c’])<br>fp.map(fp.toUpper)([‘a’, ‘b’, ‘c’])<br>fp.split(‘ ‘, ‘Hello World’)<br>fp.split(‘ ‘)(‘Hello World’)<br></pre><br>我们看上面代码lodash中map方法是数据优先，函数滞后；当我们调用map方法只传递一个参数，会原封不动的返回这个参数数组。lodash的split方法也是，数据优先，函数滞后。<br>而lodash的fp模块函数优先，数据滞后。而如果给fp模块的map/split函数传递一个参数，会返回一个新的函数等待剩余的参数，说明在lodash中map/split都是柯里化的函数<br>我们上一节的需求:NEVER SAY DIE -&gt; never-say-die，为了满足需求我们做了很多操作，有了fp模块我们发现上一节的代码能精简很多</p>
<p><pre><br>const fp = require(‘lodash/fp’)<br>const f = fp.flowRight(fp.join(‘-‘), fp.map(_.toLower), fp.split(‘ ‘))<br>console.log(f(‘NEVER SAY DIE’))<br></pre><br>26.lodash-map方法的小问题</p>
<p><pre><br>//lodash和lodash/fp模块中map方法的区别<br>const _ = require(‘lodash’)<br>//把一个字符串数组中的所有元素都转换为整数<br>console.log(_.map([‘23’,’8’,’10’],parseInt))//打印结果[23,NaN,2]<br></pre><br>上面代码为什么没有得到我们想要的结果，我们要分析下parseInt(要被解析的字符串,要解析的数字的基数。该值介于 2 ~ 36 之间)，在上面函数执行过程中分别执行了<br>parseInt(‘23’,0,array)//这里需要了解下lodash的map函数的参数<br>parseInt(‘8’,1,array)<br>parseInt(‘10’,2,array)<br>也就不难理解了，23转换为0进制，程序理解为十进制，于是是23；8转换为1进制是不包含在2～36中的，于是为NaN；10转换为2进制就是2。如果要解决这个问题，我们需要自己封装一个parseInt来替代lodash中的parseInt，而lodash/fp中的map就不会出现这个问题</p>
<p><pre><br>const fp = require(‘lodash/fp’);<br>console.log(fp.map(parseInt,[‘23’,’8’,’10’]))//是我们预期的[23,8,10]<br></pre><br>27.Pointfree<br>Point Free：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参<br>数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。<br>·不需要指明处理的数据<br>·只需要合成运算过程<br>·需要定义一些辅助的基本运算函数·</p>
<p><pre><br>//我们之前的课程中的案例<br>const f = fp.flowRight(fp.join(‘-‘), fp.map(_.toLower), fp.split(‘ ‘))<br></pre><br>案例演示</p>
<p><pre><br>// 非 Point Free 模式<br>// Hello World =&gt; hello_world<br>function f (word) {<br>    return word.toLowerCase().replace(/\s+/g, ‘<em>‘);<br>}<br>// Point Free<br>const fp = require(‘lodash/fp’)<br>const f = fp.flowRight(fp.replace(/\s+/g, ‘</em>‘), fp.toLower)<br>console.log(f(‘Hello World’))<br></pre><br>28.Pointfree-案例<br>案例需求:使用 Point Free 的模式，把单词中的首字母提取并转换成大写</p>
<p><pre><br>//world wild web =&gt; W.W.W<br>const fp = require(‘lodash/fp’)<br>//这里用了两次map，说起来是影响性能的<br>//const firstLetterToUpper = fp.flowRight(join(‘. ‘), fp.map(fp.first), fp.toUpper, fp.split(‘ ‘))<br>//于是我们对上面的代码进行修改，只用一次map<br>const firstLetterToUpper = fp.flowRight(join(‘. ‘), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(‘ ‘))<br>console.log(firstLetterToUpper(‘world wild web’))<br></pre><br>29.Functor(函子)<br>为什么要学函子<br>到目前为止已经已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。<br>什么是 Functor<br>·容器：包含值和值的变形关系(这个变形关系就是函数)<br>·函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理(变形关系)</p>
<p><pre><br>// 一个容器，包裹一个值<br>class Container {<br>    constructor(value){<br>        this._value = value//这个值是内部的，不对外公布<br>    }<br>    map(fn){//这个map方法对应函子的概念-该对象具有 map 方法<br>        return new Container(fn(this._value))<br>    }<br>}<br>let r = new Container(5).map(x =&gt; x+1 ).map(x =&gt; x*x )//每次调用map都返回一个新的函子对象<br>console.log(r) //Container {_value: 36 }<br></pre><br>上面代码，每次调用都需要new一下用起来不是很方便，我们进行调整修改</p>
<p><pre><br>// 一个容器，包裹一个值<br>class Container {<br>// of 静态方法，可以省略 new 关键字创建对象<br>    static of (value) {<br>        return new Container(value)<br>    }<br>    constructor (value) {<br>        this._value = value<br>    }<br>    // map 方法，传入变形关系，将容器里的每一个值映射到另一个容器<br>    map (fn) {<br>        return Container.of(fn(this._value))<br>    }<br>}<br>// 测试<br>let r = Container.of(3).map(x =&gt; x + 2).map(x =&gt; x * x)<br>console.log(r)<br></pre><br>30.Functor总结<br>·函数式编程的运算不直接操作值，而是由函子完成<br>·函子就是一个实现了 map 契约的对象<br>·我们可以把函子想象成一个盒子，这个盒子里封装了一个值<br>·想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理<br>·最终 map 方法返回一个包含新值的盒子（函子）</p>
<p><pre><br>// 值如果不小心传入了空值(副作用)<br>Container.of(null) .map(x =&gt; x.toUpperCase())<br>// TypeError: Cannot read property ‘toUpperCase’ of null<br></pre><br>对于纯函数，对于相同输入的值必须有相同的输出，这里用null报错，是函数的副作用，我们下一小节会想办法解决这个问题<br>31.MayBe函子<br>·我们在编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理<br>·MayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）</p>
<p><pre><br>class MayBe{<br>    static of (value) {<br>        return new MayBe(value)<br>    }<br>    constructor (value) {<br>        this._value = value<br>    }<br>    // 如果对空值变形的话直接返回 值为 null 的函子<br>    map (fn) {<br>        return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value))<br>    }<br>    isNothing () {<br>        return this._value === null || this._value === undefined<br>    }<br>}<br>// 传入具体值<br>MayBe.of(‘Hello World’) .map(x =&gt; x.toUpperCase())<br>// 传入 null 的情况<br>MayBe.of(null) .map(x =&gt; x.toUpperCase()) // =&gt; MayBe { _value: null }<br>MayBe.of(‘hello world’).map(x =&gt; x.toUpperCase()).map(x =&gt; null) .map(x =&gt; x.split(‘ ‘)) // =&gt; MayBe { _value: null }//这里体现的问题是，虽然我们解决了null报错的问题，但是我们依然不知道是哪里输入了有问题的值<br></pre><br>32.Either函子<br>·Either 两者中的任何一个，类似于 if…else…的处理<br>·异常会让函数变的不纯，Either 函子可以用来做异常处理</p>
<p><pre><br>class Left{<br>    static of (value) {<br>        return new Left(value)<br>    }<br>    constructor (value) {<br>        this._value = value<br>    }<br>    map (fn) {<br>        return this<br>    }<br>}<br>class Right{<br>    static of (value) {<br>        return new Right(value)<br>    }<br>    constructor (value) {<br>        this._value = value<br>    }<br>    map (fn) {<br>        return Right.of(fn(this._value))<br>    }<br>}<br>let r1 = Right.of(12).map(x =&gt; x+2)//Right{ _value: 14 }<br>let r1 = Left.of(12).map(x =&gt; x+2)//Left{ _value: 12 }<br>//直到上面代码，我们都还没有对错误信息作任何处理，接下来要开始处理错误信息<br>function parseJSON(json) {<br>    try {<br>        return Right.of(JSON.parse(json));<br>    } catch (e) {<br>        return Left.of({ error: e.message});<br>    }<br>}<br>let r3 = parseJSON(‘{ name: zs }’) // 报错<br>let r4 = parseJSON(‘{ “name”: “zs” }’).map(x =&gt; x.name.toUpperCase())<br>console.log(r4)<br></pre><br>33.IO函子<br>·IO 函子中的 _value 是一个函数，这里是把函数作为值来处理<br>·IO 函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作(惰性执行)，包装当前的操作纯<br>·把不纯的操作交给调用者来处理</p>
<p><pre><br>const fp = require(‘lodash/fp’)<br>class IO {<br>    static of (x) {<br>        return new IO(function () { return x })<br>    }<br>    constructor (fn) {<br>        this._value = fn<br>    }<br>    map (fn) {<br>        // 把当前的 value 和 传入的 fn 组合成一个新的函数，把副作用延迟到调用的时候<br>        return new IO(fp.flowRight(fn, this._value))<br>    }<br>}<br>// 调用<br>let io = IO.of(process).map(p =&gt; p.execPath)//process.execPath当前进程的执行路径<br>console.log(io) //IO { _value:[Function] }<br>onsole.log(io._value())//打印了当前进程的执行路径<br></pre><br>34.Falktale<br>·异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示<br>·folktale 一个标准的函数式编程库<br> ·和 lodash、ramda 不同的是，他没有提供很多功能函数<br> ·只提供了一些函数式处理的操作，例如：compose、curry 等，一些函子 Task、Either、MayBe 等</p>
<p><pre><br>const { compose, curry } = require(‘folktale/core/lambda’)<br>const { toUpper, first } = require(‘lodash/fp’)<br>// 第一个参数是传入函数的参数个数<br>let f = curry(2, function (x, y) {<br>    console.log(x + y)<br>})<br>f(3, 4) //7<br>f(3)(4) //7<br>// 函数组合<br>let f = compose(toUpper, first)<br>console.log(f([‘one’, ‘two’]))//ONE<br></pre><br>35.Task函子<br>Task 异步执行<br>·folktale(2.3.2) 2.x 中的 Task 和 1.0 中的 Task 区别很大，1.0 中的用法更接近我们现在演示的函子<br>·这里以 2.3.2 来演示</p>
<p><pre><br>const fs = require(‘fs’)<br>const { task } = require(‘folktale/concurrency/task’)<br>function readFile(filename) {<br>    return task(resolver =&gt; {<br>        fs.readFile(filename, ‘utf-8’, (err, data) =&gt; {<br>            if (err) resolver.reject(err)<br>            resolver.resolve(data)<br>        })<br>    })<br>}<br>// 调用 run 执行<br>readFile(‘package.json’)<br>.map(split(‘\n’))//获取package.json文件中的信息后按行分割成数组<br>.map(find(x =&gt; x.includes(‘version’)))//获取version信息<br>.run().listen({<br>    onRejected: err =&gt; {<br>        console.log(err)<br>    },<br>    onResolved: value =&gt; {<br>        console.log(value)<br>    }<br>})<br></pre><br>36.Pointed函子<br>·Pointed 函子是实现了 of 静态方法的函子<br>·of 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文Context（把值放到容器中，使用 map 来处理值）<br><img src="https://snakexu.github.io/images/lagou/part_1/36_1.png"></p>
<p><pre><br>//这里主要是介绍Pointed函子的概念，之前我们已经用过了<br>class Container {<br>    static of (value) {<br>        return new Container(value)<br>    }<br>    ……<br>}<br>Contanier.of(2) .map(x =&gt; x + 5)<br></pre><br>37.IO函子问题</p>
<p><pre><br>//这是我们之前内容的函子，我们用这个函子解决一个问题<br>//linux下cat命令是读取一个文件并打印出文件的内容<br>const fp = require(‘lodash/fp’)<br>const fs = require(‘fs’)<br>class IO {<br>    static of (x) {<br>        return new IO(function () { return x })<br>    }<br>    constructor (fn) {<br>        this._value = fn<br>    }<br>    map (fn) {<br>        return new IO(fp.flowRight(fn, this._value))<br>    }<br>}<br>let readFile = function(filename){<br>    //因为读取文件的时候会引起副作用让我们的函数变得不纯，所以延迟到执行的时候再调用<br>    return new IO(function(){<br>        return fs.readFileSync(filename,’utf-8’)<br>    })<br>}<br>let print = function(x){<br>    return new IO(function(){<br>        console.log(x)<br>        return x<br>    })<br>}<br>let cat = fp.flowRight(print, readFile)<br>let r1 = cat(‘package.json’)<br>console.log(r1)//IO { _value: [Function] }<br>let r2 = cat(‘package.json’)._value()._value()//这里嵌套函子的风格略显麻烦，下一节我们学习怎么修改<br>//r2才能拿到文件内容，第一个value把readFile的IO函子打印出来，<br></pre><br>38.Monad函子<br>·Monad 函子是可以变扁的 Pointed 函子，IO(IO(x))<br>·一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad</p>
<p><pre><br>const fp = require(‘lodash/fp’)<br>const fs = require(‘fs’)<br>class IO {<br>    static of (x) {<br>        return new IO(function () { return x })<br>    }<br>    constructor (fn) {<br>        this._value = fn<br>    }<br>    map (fn) {<br>        return new IO(fp.flowRight(fn, this._value))<br>    }<br>    //整个例子是上节课中的内容，这里我们略作修改，加入了join和flatMap<br>    join () {<br>        return this._value()<br>    }<br>    flatMap (fn) {<br>        return this.map(fn).join()<br>    }<br>}<br>let readFile = function(filename){<br>    return new IO(function(){<br>        return fs.readFileSync(filename,’utf-8’)<br>    })<br>}<br>let print = function(x){<br>    return new IO(function(){<br>        console.log(x)<br>        return x<br>    })<br>}<br>let r = readFile(‘package.json’).flatMap(print).join()//拿到了package.json中的内容<br></pre><br>假设在上面代码中，我们读完文件要继续处理文件，比如把拿出来字符串全部转换成大写，我们该如何做</p>
<p><pre><br>let r = readFile(‘package.json’).map(fp.toUpper).flatMap(print).join()<br></pre><br>39.总结</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/拉勾-函数式编程范式/" data-id="ckbm7478i004ub4xq109iyc2p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾-函数式编程/">拉勾 函数式编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-函数式编程范式-5-高阶函数-函数作为参数" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/拉勾-函数式编程范式-5-高阶函数-函数作为参数/" class="article-date">
  <time datetime="2020-06-14T09:53:08.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/拉勾-函数式编程范式-5-高阶函数-函数作为参数/">拉勾-函数式编程范式-5-高阶函数-函数作为参数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>高阶函数<br>什么是高阶函数(Higher-order function):可以把函数作为参数传递给另一个函数；可以把函数作为另一个函数的返回结果</p>
<pre>
//高阶函数，函数作为参数
function forEach(array,fn){
    for(let i = 0; i < array.length; i++){
        fn(array[i])
    }
}
//测试
let arr = [1,3,4,7,8]
forEach(arr,function(item){
    console.log(item)
})
</pre>
在node环境执行上面代码，依次打印出arr的每一项，这里我们也就了解了forEach的原理，接着我们来模拟filter
<pre>
//这里第二个参数为什么是fn(函数)，因为我们通常需要去过滤满足一定条件的数据
//而这个一定条件是不确定的，我们要让这个函数变得通用，那么函数就是很好的选择，我们在变化的位置传递一个函数
function filter(array,fn){
    let results = [];
    for(let i = 0; i < array.length; i++){
        if(fn(array[i])){
            results.push(array[i])
        }
    }
    return results
}
//测试
let arr = [1,3,4,7,8]
let r = filter(arr,function(item){
    return item % 2 === 0
})
console.log(r)
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/拉勾-函数式编程范式-5-高阶函数-函数作为参数/" data-id="ckbm7471q000sb4xquza7p7ll" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾-函数式编程范式/">拉勾 函数式编程范式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-移动端APP开发工程师-H5移动端开发-1-1-7-canvas" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/网易微专业-移动端APP开发工程师-H5移动端开发-1-1-7-canvas/" class="article-date">
  <time datetime="2020-06-13T07:32:02.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/网易微专业-移动端APP开发工程师-H5移动端开发-1-1-7-canvas/">网易微专业-移动端APP开发工程师-H5移动端开发-1.1.7-canvas</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.canvas概念<br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_1.png"><br>2.基础API和用法<br>2-1.兼容性内容替换<br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_2.png"><br>2-2.canvas2d模版骨架<br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_3.png"><br>2-3.canvas2d形状绘制<br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_4.png"><br>3.样式与颜色<br>3-1.canvas2d色彩(colors)<br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_5.png"><br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_6.png"><br>3-2.canvas2d线型(line styles)<br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_7.png"><br>4.曲线和高级路径<br>4-1.贝塞尔曲线<br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_8.png"><br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_9.png"><br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_10.png"><br>4-2.高级路径之Path2D<br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_11.png"><br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_12.png"><br>5.状态、变形以及动画<br>5-1.canvas的状态控制<br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_13.png"><br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_14.png"><br>5-2.动画的基本步骤<br><img src="https://snakexu.github.io/images/wangyi/app/1.1.7_15.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/网易微专业-移动端APP开发工程师-H5移动端开发-1-1-7-canvas/" data-id="ckbm7473n003gb4xqm6a9er6k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习手动创建react项目过程中" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/10/学习手动创建react项目过程中/" class="article-date">
  <time datetime="2020-06-10T09:49:05.000Z" itemprop="datePublished">2020-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/10/学习手动创建react项目过程中/">学习手动创建react项目过程中</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.shangmayuan.com/a/c9392696e58e4aa1bedcef39.html" target="_blank" rel="noopener">https://www.shangmayuan.com/a/c9392696e58e4aa1bedcef39.html</a> 一个不错的自己搭建react开发环境的教程<br>学习用最传统的npm iniy -y来创建一个react项目，中间一点点学习到的东西<br>1.webpack/webpack-cli是必须安装的<br>2.babel在安装的过程中<br>2-1.@babel/preset-react和babel-preset-react-app个人以为babel-preset-react-app是用npx默认创建react项目中做了更适应于react的一些操作<br>babel-preset-react-app:<a href="https://github.com/facebook/create-react-app/tree/master/packages/babel-preset-react-app" target="_blank" rel="noopener">https://github.com/facebook/create-react-app/tree/master/packages/babel-preset-react-app</a><br>而@babel/preset-react是babel提供的关于react的预设<a href="https://babel.docschina.org/docs/en/babel-preset-react#docsNav" target="_blank" rel="noopener">https://babel.docschina.org/docs/en/babel-preset-react#docsNav</a><br>2-2.babel-loader:<a href="https://www.webpackjs.com/loaders/babel-loader/" target="_blank" rel="noopener">https://www.webpackjs.com/loaders/babel-loader/</a><br>babel和webpack之间的桥梁，允许使用Babel和webpack来转译JavaScript文件。上面关于babel-loader的webpack介绍中，目前来看值得注意的有<br>(1)cacheDirectory:默认值为 false。当有设置时，指定的目录将用来缓存 loader 的执行结果。通过使用cacheDirectory提升打包速度<br>(2)给出了babel-loader很慢的解决方案，其中exclude: /(node_modules|bower_components)/适用于很多可以指定打包目录的loader，也算是一种优化方式。<br>(3)另外，babel 在每个文件都插入了辅助代码，使代码体积过大 这个目录中提到了babel-plugin-transform-runtime，随着babel的升级这个plugin有一些变化我将在接下来的内容中看能补充多少。<br>2-3.babel-plugin-transform-runtime:<a href="https://babel.docschina.org/docs/en/babel-plugin-transform-runtime#docsNav" target="_blank" rel="noopener">https://babel.docschina.org/docs/en/babel-plugin-transform-runtime#docsNav</a><br>一个插件，可重新使用Babel注入的帮助程序代码以节省代码大小。<br>安装babel-plugin-transform-runtime作为开发环境的依赖<br>安装@babel/runtime作为生产环境的依赖<br>下面两篇文章解决了我的疑问，polyfill/transform-runtime/corejs的配置<br><a href="https://segmentfault.com/a/1190000020237790" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020237790</a> Babel7 转码（四）- polyfill 还是 transform-runtime<br><a href="https://segmentfault.com/a/1190000020237817" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020237817</a> 关于介绍Babel7 转码（五）- corejs3 的更新(polyfill和按需加载语法编译在corejs3下的更新)<br><a href="https://segmentfault.com/a/1190000018358854" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018358854</a> 一文读懂 babel7 的配置文件加载逻辑(关于babel配置文件的一些介绍)<br>3.webpack的loader和plugin<br>3-1.html-webpack-plugin把打包的文件插入到html中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/10/学习手动创建react项目过程中/" data-id="ckbm7471m000mb4xqdd6xr90v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react-babel/">react babel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-look直播，企业级全栈web应用搭建分享" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/08/网易微专业-look直播，企业级全栈web应用搭建分享/" class="article-date">
  <time datetime="2020-06-08T11:54:49.000Z" itemprop="datePublished">2020-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/08/网易微专业-look直播，企业级全栈web应用搭建分享/">网易微专业-look直播，企业级全栈web应用搭建分享</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>SPA &amp;&amp; SSR<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_1.png"><br>问题<br>两端代码复用<br>两端的渲染保持一致<br>两端的fallback设计<br>node端降级方案<br>1.工程架构<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_2.png"><br>1-1.组件分割<br>根据路由分割js，避免js bundle过大<br>(演示代码)</p>
<p><pre><br>//webpack的import方法分割js返回一个promise，会有一个异步等待过程，<br>// baseLoadable等待promise完成之后才会去渲染组件<br>import baseLoadable from ‘@loadable/component’<br>const loading = () =&gt; {<br>    &lt; div classname = “m-loading” &gt;加载中…&lt; /div&gt;<br>}<br>const loadable = loader =&gt; baseLoadable(loader,{<br>    fallback:&lt; loading /&gt;<br>}<br>const Home = loadable(()=&gt;import(‘./views/home’))<br>const List = loadable(()=&gt;import(‘./views/list’))<br>const Detail = loadable(()=&gt;import(‘./views/detail’))<br></pre><br>1-2.路由<br>采用配置式路由为了方便node端获取对应组件</p>
<p><pre><br>&lt; Switch &gt;<br>&lt; Route exact path=’/list’ component={List} /&gt;<br>&lt; Route exact path=’/detail/:id’ component={Detail} /&gt;<br>&lt; Route exact path=’/‘ component={Home} /&gt;<br>&lt; /Switch &gt;<br></pre><br>上面代码 组件式配置化</p>
<p><pre><br>const config = [<br>{<br>    path:’/list’,<br>    exact:true,<br>    component:List<br>},<br>{<br>    path:’/detail/:id’,<br>    exact:true,<br>    component:Detail<br>},<br>{<br>    path:’/‘,<br>    exact:true,<br>    component:Home<br>},<br>]<br>export default config;<br></pre><br>1-3.获取组件<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_3.png"><br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_4.png"><br>1-4.请求方法<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_5.png"><br>1-5.两端数据一致</p>
<p><pre><br>&lt; script &gt;<br>window.CURRENT_STATE = &lt; %- state% &gt;<br>&lt; /script &gt;<br>import {createStore} from ‘redux’<br>…<br>const store = createStore(rootReducer,window.CURRENT_STATE)<br></pre><br>保证首屏的css和js加载完</p>
<p><pre><br>import { loadableReady } from ‘@loadable/component’;<br>loadableReady(()=&gt;{<br>    ReactDOM.hydrate(<br>        &lt; APP /&gt;,<br>        document.getElementById(‘j-app’)<br>    );<br>})<br></pre><br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_6.png"><br>1-6.async标签<br>提前执行script脚本<br>&lt; script async src=”/public/app.js” &gt;&lt; /script &gt;<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_7.png"><br>1-8.SEO<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_8.png"><br>1-9.webpack<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_9.png"><br>1-10.缓存<br>没有接口请求，则认为是静态可缓存<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_10.png"><br>新建Map存储上次的html<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_11.png"><br>1-11.降级<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_12.png"><br>2.状态管理<br>2-1.redux<br>只有碰到react实在解决不了的问题，你才需要redux<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_13.png"><br>2-2.思考<br>·繁琐的代码且重复<br>·开发体验不友好<br>·可读性差，不便于维护<br>2-3.改进<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_14.png"><br>·设置modal类<br>·自定义一个中间件<br>·充分利用redux数据流<br>扩展dispatch支持字符串方式<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_15.png"><br>3.异步任务<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_16.png"><br>问题<br>·数据的来源多，ajax、websocket、事件<br>·数据的依赖关系<br>·礼物消息的处理<br>3-1.rxjs<br>为了解决上面的问题，引入了rxjs<br>一种编程模型<br>针对异步数据流的编程<br>将一切数据包装成流<br>提供强大的操作符处理<br>3-2.Observable<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_17.png"><br>Publisher<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_18.png"></p>
<p><pre><br>const Publisher = (observer) =&gt; {<br>    let count = 0;<br>    const inter = setIntrerval(()=&gt;{<br>        count+=1;<br>        observer.next(count);<br>        if(count&gt;=5){<br>            observer.complete();<br>            clearInterval(inter);<br>        }<br>    },1000);<br>}<br>const ob$ = Observable.create(Publisher);<br>const scp = ob$.subscribe((v)=&gt;{<br>    console.log(v)<br>})<br>setTimeout(()=&gt;{<br>    const scp1 = ob$.subscribe((v)=&gt;{<br>        console.log(v)<br>    })<br>},1000)<br>/<em><br>const observer = {<br>    next:(val)=&gt;{},<br>    complete:()=&gt;{},<br>    error:()=&gt;{}<br>}
</em>/<br></pre><br>Subject<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_19.png"><br>Subject-多播<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_20.png"><br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_21.png"><br>3-3.数据的统一<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_22.png"><br>3-4.数据的依赖关系<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_23.png"><br>3-5.礼物消息<br>项目是一个直播项目，有一个需求是30s内同一用户同一礼物数目进行累加<br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_24.png"><br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_25.png"><br><img src="https://snakexu.github.io/images/wangyi/projectlook/look_26.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/08/网易微专业-look直播，企业级全栈web应用搭建分享/" data-id="ckbm7472o0023b4xqni8q72fw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-webpack实战演练-3-3-1-网易的webpack工程化实践" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/网易微专业-webpack实战演练-3-3-1-网易的webpack工程化实践/" class="article-date">
  <time datetime="2020-06-07T03:29:11.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/网易微专业-webpack实战演练-3-3-1-网易的webpack工程化实践/">网易微专业-webpack实战演练-3.3.1-网易的webpack工程化实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.eslint<br>1-1.eslint相关包<br>01.eslint+eslint-loader核心内容<br>02.eslint-plugin-html/eslint-plugin-vue<br>03.eslint-friendly-fromatter 友好提示<br>04.eslint-config-standard 代码风格标准<br>webpack.base.conf.js</p>
<pre>
const createLiningRult = ()=>({
    test:/\.(js|vue)$/,
    loader:'eslint-loader',
    enforce:'pre',
    include:[resolve('src'),resolve('test')],
    options:{
        formatter:require('eslint-friendly-formatter'),
        emitWarning:!config.dev.showEslintErrorsInOverlay
    }
})
</pre>
.eslintrc.js 这里并不是全部配置，截取部分老师讲的内容
<pre>
rules:{
    'generator-star-spacing':'off',
    //1-开启，以警告提示；2-开启，以报错提示；0-等价于off，即关闭这条检查规则
    'no-console':'off',
    'no-alert':1,
    'no-implicit-globals':1,//不准在全局定义function、var
    'no-debugger':process.env.NODE_ENV === 'production'?'error':'off'
}
</pre>
2.一些特别的plugins和loader
webpack.DefinePlugin:将当前环境代码传到业务代码(比如业务代码不能获取process.env，可以通过这个方法获取环境代码)
<pre>
plugins:[
    new webpack.DefinePlugin({
        'process.env':require('../config/dev.env');
    })
]
</pre>
webpack.ProvidePlugin:避免开发过程中频繁引入同一个库
<pre>
plugins:[
    new webpack.ProvidePlugin({
        ax:'axios'
    })
]
</pre>
webpack.NoEmitOnErrorsPlugin:编译出现错误的时候，跳过错误继续编译
copy-webpack-plugin:拷贝文件，需要安装，作用于某文件夹中文件并没有在项目中全部被引用，但是项目中需要某文件夹中全部文件的情况
<pre>
//是的，这里老师并没有给完整的例子
plugins:[
    new copyWebpackPlugin({
        from:……
    })
]
</pre>
mini-css-extract-plugin:这个使用的时候，要先定义引入，再在plugin中写入，另外定义处理css的时候，也不能用style-loader了，要用这个插件
3.环境区分
<img src="https://snakexu.github.io/images/wangyi/node/3.3.1_1.png">
4.项目问题解决
4-1.不要把配置当配置，当成一个程序(项目中的一些配置可以写成方法，以应对灵活多变的业务需求)
4-2.解决方案归纳
·如果要是对模块内容进行处理
loader是第一解决方案
·如果要增加一些特殊的功能
可以自定义增加插件
·项目上的打包简化，可变性配置等
通过编写相应的操作函数

自己写一个plugin
下面是老师示例的自己编写plugin
<pre>
const path = require('path');
const fs = require('fs');
const readFileAsync = require("util").promisify(fs.readFile);
const writeFileAsync = require("util").promisify(fs.writeFile);
class AddStaticServer {
    constructor(options) {
        this.options = options || {
            serverPath: '//kc.stu.126.net'
        };
        this.serverPath = this.options.serverPath;
    }
    apply(compiler) {
        // 等 html-webpack-plugin 解决多页面构建速度慢的问题可以使用此方法
        // compiler.hooks.compilation.tap('AddStaticServer', compilation => {
        //     compilation.hooks.htmlWebpackPluginBeforeHtmlProcessing.tap(
        //         'AddStaticServer',
        //         data => {
        //             data.html =
        //             data.html.replace(/\/static\/css/g, `${this.serverPath}res/css`)
        //                 .replace(/\/static\/js/g, `${this.serverPath}res/js`)
        //                 .replace(/\/static\/img/g, `${this.serverPath}res/img`);
        //         }
        //     );
        // });
        compiler.hooks.done.tap('AddStaticServer', compilation => {
            let context = compiler.options.context;
            let publicPath = path.resolve(context, 'dist');
            compilation.toJson().assets.forEach((ast) => {
                let {dir, base, ext} = path.parse(ast.name);
                if (ext === '.ftl') {
                    readFileAsync(path.resolve(publicPath, dir, base), {encoding: 'utf-8'}).then((cnt) => {
                        cnt = cnt.replace(/\/static\/css/g, `${this.serverPath}res/css`)
                                .replace(/\/static\/js/g, `${this.serverPath}res/js`)
                                .replace(/\/static\/img/g, `${this.serverPath}res/img`);
                        writeFileAsync(path.resolve(publicPath, dir, base), cnt);
                    });
                }
            });
        });
    }
}
module.exports = AddStaticServer;
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/网易微专业-webpack实战演练-3-3-1-网易的webpack工程化实践/" data-id="ckbm74731002rb4xqmgtp4uhn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-webpack实战演练-3-2-6-webpack打包速度优化" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/06/网易微专业-webpack实战演练-3-2-6-webpack打包速度优化/" class="article-date">
  <time datetime="2020-06-06T03:02:23.000Z" itemprop="datePublished">2020-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/06/网易微专业-webpack实战演练-3-2-6-webpack打包速度优化/">网易微专业-webpack实战演练-3.2.6-webpack打包速度优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.打包结果分析<br>1-1.chunks和module<br>chunks:即代码块，即webpack把js分割成了几块代码<br>module:模块，每一个文件即一个模块<br>1-2.如何可视化的获取打包结果分析<br>·官方版本<br>Mac:webpack –profile –json &gt;stats.json<br>Window:webpack –profile –json &gt;stats.json<br>在项目中执行上述命令之后，打开下面的网站<br><a href="http://webpack.github.io/analyse/" target="_blank" rel="noopener">http://webpack.github.io/analyse/</a><br>选择刚才打包生成的stats.json<br><img src="https://snakexu.github.io/images/wangyi/node/3.2.6_1.png"><br>·社区版本<br>(1)webpack-bundle-analyzer<br>2.优化打包速度<br>2-1.有哪些可以优化的点<br>·项目本身<br>(1)减少依赖嵌套深度<br>(2)使用尽可能少的处理<br>·webpack层面<br>(1)Dll处理<br>(2)通过include减少loader范围<br>(3)HappyPack<br>(4)Uglify优化<br>(5)减少resolve、sourcemap、cache-loader，用新版本的node和webpack</p>
<p>webpack.dll.js</p>
<pre>
const webpack = require('webpack')
module.exports = {
    entry:{
        vendor:['jquery','loadsh']
    },
    output:{
        path:__dirname+'/src/dll',
        filename:"./[name].js",
        library:"[name]_library"//引用名
    },
    plugins:[
        new webpack.DllPlugin({
            path:__dirname+"/src/dll/[name].json",
            name:"[name]_library",//这里要与引用名一致(也就是与output.library一致)
        })//告诉打包命令，我们已经处理过jquery和lodash文件了
    ]
}
</pre>
保存之后，在命令行项目文件夹下，输入webpack --config webpack.dll.js，我们可以看到项目src文件夹下生成了一个dll文件夹，里面有vendor.js和vendor.json文件，vendor.json文件会给到真正的打包配置中。
在webpack.config.js文件的plugin中添加:
<pre>
new webpack.DllReferencePlugin({
     manifest:require('./src/dll/vendor.json')
}),
</pre>
到这里，我们只是完成了dll打包，但是我们dll打包的文件并没有被引入到html页面中，我们可以通过
<pre>
new htmlWebpackPlugin({
    filename:"index.html",
    template:"./src/index.html",
    vendorPath:"../src/dll/vendor.js",//在这里引入dll生成的文件
    chunks:['app','runtime']
})
</pre>
并且在html页面通过模版字符串的方式引入
<pre>
< script type="text/javascript" src="${htmlWebpackPlugin.options.vendorPath}">< /script >
</pre>

<p>HappyPack由于webpack是node编写的，而node可以开工作进程，所以通过这个思路，HappyPack开启多线程。HappyPack是要通过npm下载的，假设我们要用happypack处理vue文件</p>
<pre>
rules:[
{
    test:/\.vue$/,
    loader:'happypack/loader?id=happyvue'
}
]
</pre>
在配置生产环境的配置文件中
<pre>
const HappyPack = require('happypack');
const os = require('os')
const happyThreadpool = HappyPack.ThreadPool({size:os.cpus().length})//根据cpu决定建几个线程
const vueLoaderConfig = require('./vue-loader.conf.js')
//这里只是需要修改plugins中的内容，并不是说plugins在文件中层级关系
plugins:[
    new HappyPack({
        id:'happyvue',//对应我们在上面定义的id
        loaders:[
        {
            path:"vue-loader",
            cache:true,
            options:vueLoaderConfig
        }
        ],
        threadPool:happyThreadPool
    })
]
</pre>
其实在webpack中任何操作都是需要增加打包时间的(包括优化操作)，所以在运用优化操作的时候，尽可能却确定优化操作比直接打包更值得
3.长缓存优化
3-1.把hash改为chunkhash
我们在用webpack打包项目的时候，输出文件名通常会加hash，而每次项目中页面有内容变化，整个项目再次打包生成的文件hash代码会改变，影响浏览器生成缓存，我们可以将hash改成chunkhash
<pre>
output:{
    path:__dirname+"/dist",
    filename:"./[name].[chunkhash].js",
}
</pre>
3-2.NamedChunksPlugin和NamedModulesPlugin
上面的把hash改为chunkhash并不完美，当模块发生变动的时候，并不能保证hash的稳定。我们用3-2的方案完善
在webpack配置文件中做如下修改
<pre>
plugins:[
    new webpack.NamedChunksPlugin(),
    new webpack.NamedModulesPlugin()
]
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/06/网易微专业-webpack实战演练-3-2-6-webpack打包速度优化/" data-id="ckbm74731002qb4xqoh1fzs2i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾-手写Promise源码/">拉勾  手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾-JavaScript异步编程/">拉勾 JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾-函数式编程/">拉勾 函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾-函数式编程范式/">拉勾 函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/拉勾-手写Promise源码/" style="font-size: 10px;">拉勾  手写Promise源码</a> <a href="/tags/拉勾-JavaScript异步编程/" style="font-size: 10px;">拉勾 JavaScript异步编程</a> <a href="/tags/拉勾-函数式编程/" style="font-size: 10px;">拉勾 函数式编程</a> <a href="/tags/拉勾-函数式编程范式/" style="font-size: 10px;">拉勾 函数式编程范式</a> <a href="/tags/数据结构/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 16.67px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/18/拉勾-手写Promise源码/">拉勾-手写Promise源码</a>
          </li>
        
          <li>
            <a href="/2020/06/17/拉勾-JavaScript异步编程/">拉勾-JavaScript异步编程</a>
          </li>
        
          <li>
            <a href="/2020/06/15/网易微专业-移动端APP开发工程师-移动UI框架Flutter-2-1-1-Flutter概述及开发环境/">网易微专业-移动端APP开发工程师-移动UI框架Flutter-2.1.1-Flutter概述及开发环境</a>
          </li>
        
          <li>
            <a href="/2020/06/14/拉勾-函数式编程范式/">拉勾-函数式编程范式</a>
          </li>
        
          <li>
            <a href="/2020/06/14/拉勾-函数式编程范式-5-高阶函数-函数作为参数/">拉勾-函数式编程范式-5-高阶函数-函数作为参数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>