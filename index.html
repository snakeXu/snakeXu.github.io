<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="喵小喵的窝">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="喵小喵的窝">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-拉勾-Virtual-DOM-的实现原理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/拉勾-Virtual-DOM-的实现原理/" class="article-date">
  <time datetime="2020-08-09T16:38:47.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/拉勾-Virtual-DOM-的实现原理/">拉勾-Virtual DOM 的实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.课程目标<br>·了解什么是虚拟 DOM，以及虚拟 DOM 的作用<br>·Snabbdom 的基本使用<br>·Snabbdom 的源码解析<br>2.什么是虚拟DOM<br>·Virtual DOM(虚拟 DOM)，是由普通的 JS 对象来描述 DOM 对象，因为不是真实的 DOM 对象，所以叫 Virtual DOM<br>·真实 DOM 成员</p>
<p><pre><br>let element = document.querySelector(‘#app’)<br>let s = ‘’<br>for (var key in element) {<br>    s += key + ‘,’<br>}<br>console.log(s)<br>// 打印结果<br> align,title,lang,translate,dir,hidden,accessKey,draggable,spellcheck,aut ocapitalize,contentEditable,isContentEditable,inputMode,offsetParent,off setTop,offsetLeft,offsetWidth,offsetHeight,style,innerText,outerText,onc opy,oncut,onpaste,onabort,onblur,oncancel,oncanplay,oncanplaythrough,onc hange,onclick,onclose,oncontextmenu,oncuechange,ondblclick,ondrag,ondrag end,ondragenter,ondragleave,ondragover,ondragstart,ondrop,ondurationchan ge,onemptied,onended,onerror,onfocus,oninput,oninvalid,onkeydown,onkeypr ess,onkeyup,onload,onloadeddata,onloadedmetadata,onloadstart,onmousedown ,onmouseenter,onmouseleave,onmousemove,onmouseout,onmouseover,onmouseup, onmousewheel,onpause,onplay,onplaying,onprogress,onratechange,onreset,on resize,onscroll,onseeked,onseeking,onselect,onstalled,onsubmit,onsuspend ,ontimeupdate,ontoggle,onvolumechange,onwaiting,onwheel,onauxclick,ongot pointercapture,onlostpointercapture,onpointerdown,onpointermove,onpointe rup,onpointercancel,onpointerover,onpointerout,onpointerenter,onpointerl eave,onselectstart,onselectionchange,onanimationend,onanimationiteration ,onanimationstart,ontransitionend,dataset,nonce,autofocus,tabIndex,click ,focus,blur,enterKeyHint,onformdata,onpointerrawupdate,attachInternals,n amespaceURI,prefix,localName,tagName,id,className,classList,slot,part,at tributes,shadowRoot,assignedSlot,innerHTML,outerHTML,scrollTop,scrollLef t,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight ,attributeStyleMap,onbeforecopy,onbeforecut,onbeforepaste,onsearch,eleme ntTiming,previousElementSibling,nextElementSibling,children,firstElement Child,lastElementChild,childElementCount,onfullscreenchange,onfullscreen error,onwebkitfullscreenchange,onwebkitfullscreenerror,setPointerCapture ,releasePointerCapture,hasPointerCapture,hasAttributes,getAttributeNames ,getAttribute,getAttributeNS,setAttribute,setAttributeNS,removeAttribute ,removeAttributeNS,hasAttribute,hasAttributeNS,toggleAttribute,getAttrib uteNode,getAttributeNodeNS,setAttributeNode,setAttributeNodeNS,removeAtt ributeNode,closest,matches,webkitMatchesSelector,attachShadow,getElement sByTagName,getElementsByTagNameNS,getElementsByClassName,insertAdjacentE lement,insertAdjacentText,insertAdjacentHTML,requestPointerLock,getClien tRects,getBoundingClientRect,scrollIntoView,scroll,scrollTo,scrollBy,scr ollIntoViewIfNeeded,animate,computedStyleMap,before,after,replaceWith,re move,prepend,append,querySelector,querySelectorAll,requestFullscreen,web kitRequestFullScreen,webkitRequestFullscreen,createShadowRoot,getDestina tionInsertionPoints,ELEMENT_NODE,ATTRIBUTE_NODE,TEXT_NODE,CDATA_SECTION_ NODE,ENTITY_REFERENCE_NODE,ENTITY_NODE,PROCESSING_INSTRUCTION_NODE,COMME NT_NODE,DOCUMENT_NODE,DOCUMENT_TYPE_NODE,DOCUMENT_FRAGMENT_NODE,NOTATION _NODE,DOCUMENT_POSITION_DISCONNECTED,DOCUMENT_POSITION_PRECEDING,DOCUMEN T_POSITION_FOLLOWING,DOCUMENT_POSITION_CONTAINS,DOCUMENT_POSITION_CONTAI NED_BY,DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC,nodeType,nodeName,baseU RI,isConnected,ownerDocument,parentNode,parentElement,childNodes,firstCh ild,lastChild,previousSibling,nextSibling,nodeValue,textContent,hasChild Nodes,getRootNode,normalize,cloneNode,isEqualNode,isSameNode,compareDocu mentPosition,contains,lookupPrefix,lookupNamespaceURI,isDefaultNamespace ,insertBefore,appendChild,replaceChild,removeChild,addEventListener,remo veEventListener,dispatchEvent<br></pre><br>·可以使用 Virtual DOM 来描述真实 DOM，示例</p>
<p><pre><br>{<br>    sel: “div”,<br>    data: {},<br>    children: undefined,<br>    text: “Hello Virtual DOM”,<br>    elm: undefined,<br>    key: undefined<br>}<br></pre><br>可以看出创建虚拟DOM的开销比创建真实DOM小很多<br>3.为什么使用虚拟DOM<br>·手动操作 DOM 比较麻烦，还需要考虑浏览器兼容性问题，虽然有 jQuery 等库简化 DOM 操作，但是随着项目的复杂 DOM 操作复杂提升<br>·为了简化 DOM 的复杂操作于是出现了各种 MVVM 框架，MVVM 框架解决了视图和状态的同步问题<br>·为了简化视图的操作我们可以使用模板引擎，但是模板引擎没有解决跟踪状态变化的问题，于是Virtual DOM 出现了<br>·Virtual DOM 的好处是当状态改变时不需要立即更新 DOM，只需要创建一个虚拟树来描述DOM， Virtual DOM 内部将弄清楚如何有效(diff)的更新 DOM<br>·参考 github 上 virtual-dom 的描述</p>
<ul>
<li>虚拟 DOM 可以维护程序的状态，跟踪上一次的状态</li>
<li>通过比较前后两次状态的差异更新真实 DOM<br>4.虚拟DOM的作用和虚拟DOM库<br>·维护视图和状态的关系<br>·复杂视图情况下提升渲染性能<br>·除了渲染 DOM 以外，还可以实现 SSR(Nuxt.js/Next.js)、原生应用(Weex/React Native)、小程序(mpvue/uni-app)等<br><img src="https://snakexu.github.io/images/lagou/part_3/3_4/4_1.png"><br>Virtual DOM 库<br>·Snabbdom</li>
<li>Vue 2.x 内部使用的 Virtual DOM 就是改造的 Snabbdom</li>
<li>大约 200 SLOC（single line of code）</li>
<li>通过模块可扩展</li>
<li>源码使用 TypeScript 开发</li>
<li>最快的 Virtual DOM 之一<br>·virtual-dom<br>5.创建项目<br><img src="https://snakexu.github.io/images/lagou/part_3/3_4/5_1.png"><br>6.导入Snabbdom<br>·看文档的意义</li>
<li>学习任何一个库都要先看文档</li>
<li>通过文档了解库的作用</li>
<li>看文档中提供的示例，自己快速实现一个 demo</li>
<li>通过文档查看 API 的使用<br>·文档地址</li>
<li><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">https://github.com/snabbdom/snabbdom</a></li>
<li><a href="https://github.com/coconilu/Blog/issues/152" target="_blank" rel="noopener">中文翻译</a><br>·安装 Snabbdom<br><pre><br>yarn add snabbdom //使用npm安装也可以<br></pre><br>·导入 Snabbdom</li>
<li>Snabbdom 的官网 demo 中导入使用的是 commonjs 模块化语法，我们使用更流行的 ES6 模块化的语法 import</li>
<li>关于模块化的语法请参考阮一峰老师的 <a href="https://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module 的语法</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/module-loader%23ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82" target="_blank" rel="noopener">ES6 模块与 CommonJS 模块的差异</a><br><pre><br>import { init, h, thunk } from ‘snabbdom’<br></pre><br>·Snabbdom 的核心仅提供最基本的功能，只导出了三个函数 init()、h()、thunk()</li>
<li>init() 是一个高阶函数，返回 patch()</li>
<li>h() 返回虚拟节点 VNode，这个函数我们在使用 Vue.js 的时候见过<pre>
new Vue({ 
  router, 
  store, 
  render: h => h(App) 
}).$mount('#app')
</pre></li>
<li>thunk() 是一种优化策略，可以在处理不可变数据时使用<br>·注意：导入时候不能使用 import snabbdom from ‘snabbdom’</li>
<li>原因：node_modules/src/snabbdom.ts 末尾导出使用的语法是 export 导出 API，没有使用export default 导出默认输出<br><img src="https://snakexu.github.io/images/lagou/part_3/3_4/6_1.png"><br>7.代码演示</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/拉勾-Virtual-DOM-的实现原理/" data-id="ckeeij2zu000sjoxqx40syzhc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-模拟Vue-js响应式原理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/05/拉勾-模拟Vue-js响应式原理/" class="article-date">
  <time datetime="2020-08-05T15:17:24.000Z" itemprop="datePublished">2020-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/05/拉勾-模拟Vue-js响应式原理/">拉勾-模拟Vue.js响应式原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.课程目标<br><img src="https://snakexu.github.io/images/lagou/part_3/3_3/1_1.png"><br>(其实一开始很不情愿写这个目标来着，但是学一个东西，没个目标，好像根本学不到啥，还是带着目标学，更有意义)<br>2.数据驱动<br>准备工作<br>·数据驱动<br>·响应式的核心原理<br>·发布订阅模式和观察者模式<br>数据驱动<br>·数据响应式、双向绑定、数据驱动<br>·数据响应式<br>++ 数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁<br>++ 琐的 DOM 操作，提高开发效率<br>·双向绑定<br>++ 数据改变，视图改变；视图改变，数据也随之改变<br>++ 我们可以使用 v-model 在表单元素上创建双向数据绑定<br>·数据驱动是 Vue 最独特的特性之一<br>++ 开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图<br>3.数据响应式核心原理-Vue2<br>首先上一段vue官网中关于Vue2.X版本响应式原理的介绍：<br>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p><pre><br>//模拟vue中的data选项<br>let data = {<br>    msg:’hello’<br>}<br>//模拟vue的实例<br>let vm = {}<br>//数据劫持：当访问或者设置vm中的成员的时候，做一些干预操作<br>Object.defineProperty(vm, ‘msg’, {<br>    //可枚举(可遍历)<br>    enumerable: true,<br>    //可配置(可以使用delete删除，可以通过defineproperty重新定义)<br>    configurable: true<br>    //当获取值的时候执行<br>    get () {<br>        console.log(‘get: ‘, data.msg)<br>        return data.msg<br>    }<br>    //当设置值的时候执行<br>    set (newValue) {<br>        console.log(‘set: ‘, newValue)<br>        if (newValue === data.msg) {<br>            return<br>        }<br>        data.msg = newValue<br>        //数据更改，更新DOM值<br>        document.querySelector(‘#app’).textContent = data.msg<br>    }<br>})<br>//测试<br>vm.msg = ‘Hello World’<br>console.log(vm.msg)<br></pre><br>上面我们描述了只有一个对象中一个属性需要转换getter/setter，如果是一个对象中多个属性怎么处理？</p>
<p><pre><br>//模拟vue中的data选项<br>let data = {<br>    msg:’hello’,<br>    count: 10<br>}<br>//模拟vue的实例<br>let vm = {}<br>proxyData(data)<br>function proxyData (data) {<br>    Object.keys(data).forEach(key =&gt; {<br>        Object.defineProperty(vm, key, {<br>            //可枚举(可遍历)<br>            enumerable: true,<br>            //可配置(可以使用delete删除，可以通过defineproperty重新定义)<br>            configurable: true<br>            //当获取值的时候执行<br>            get () {<br>                console.log(‘get: ‘, key, data[key])<br>                return data[key]<br>            }<br>            //当设置值的时候执行<br>            set (newValue) {<br>                console.log(‘set: ‘, key, newValue)<br>                if (newValue === data[key]) {<br>                    return<br>                }<br>                data[key] = newValue<br>                //数据更改，更新DOM值<br>                document.querySelector(‘#app’).textContent = data[key]<br>            }<br>        })<br>    })<br>}<br>//测试<br>vm.msg = ‘Hello World’<br>console.log(vm.msg)<br></pre><br>4.数据响应式核心原理-Vue3<br>Vue3的响应式主要依靠Proxy(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a>)<br>直接监听对象，而非属性。ES6中新增Proxy，IE不支持，性能由浏览器优化</p>
<p><pre><br>// 模拟Vue中的data选项<br>let data = {<br>    msg: ‘hello’,<br>    count: 0<br>}<br>// 模拟Vue实例<br>let vm = new Proxy(data, {<br>    get (target, key) {<br>        console.log(‘get,key: ‘, key, target[key])<br>        return target[key]<br>    },<br>    set (target, key, newValue) {<br>        console.log(‘set, key: ‘, key, newValue)<br>        if (target[key] === newValue) {<br>            return<br>        }<br>        target[key] = newValue<br>        document.querySelector(‘#app’).textContent = target[key]<br>    }<br>})<br>//测试<br>vm.msg = ‘Hello World’<br>console.log(vm.msg)<br></pre><br>5.发布订阅模式<br>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern）<br>Vue 的自定义事件<a href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2</a></p>
<p><pre><br>let vm = new Vue()<br>vm.$on(‘dataChange’, () =&gt; {<br>    console.log(‘dataChange’)<br>})<br>vm.$on(‘dataChange’, () =&gt; {<br>    console.log(‘dataChange1’)<br>})<br>vm.$emit(‘dataChange’)<br></pre><br>兄弟组件通信过程</p>
<p><pre><br>// eventBus.js<br>// 事件中心<br>let eventHub = new Vue()<br>// ComponentA.vue<br>// 发布者<br>addTodo: function () {<br>    // 发布消息(事件)<br>    eventHub.$emit(‘add-todo’, { text: this.newTodoText })<br>    this.newTodoText = ‘’<br>}<br>// ComponentB.vue<br>// 订阅者<br>created: function () {<br>    // 订阅消息(事件)<br>    eventHub.$on(‘add-todo’, this.addTodo)<br>}<br></pre><br>模拟Vue自定义事件的实现</p>
<p><pre><br>class EventEmitter {<br>    construector () {<br>        //{eventType: [handler1,handler2]}<br>        this.subs = {}<br>    }<br>    // 订阅通知<br>    $on (eventType, handler) {<br>        this.subs[eventType] = this.subs[eventType] || []<br>        this.subs[eventType].push(handler)<br>    }<br>    //发布通知<br>    $emit (eventType) {<br>        if (this.subs[eventType]) {<br>            this.subs[eventType].forEach(handler =&gt; {<br>                handler()<br>            })<br>        }<br>    }<br>}<br>//测试<br>var bus = new EventEmitter()<br>//注册事件<br>bus.$on(‘click’, function () {<br>    console.log(‘click’)<br>})<br>bus.$on(‘click’, function () {<br>    console.log(‘click1’)<br>})<br>//触发事件<br>bus.$emit(‘click’)<br></pre><br>6.观察者模式<br>观察者(订阅者) – Watcher<br>++ update()：当事件发生时，具体要做的事情<br>目标(发布者) – Dep<br>++ subs 数组：存储所有的观察者<br>++ addSub()：添加观察者<br>++ notify()：当事件发生，调用所有观察者的 update() 方法<br>没有事件中心</p>
<p><pre><br>// 目标(发布者)<br>// Dependency<br>class Dep {<br>    constructor () {<br>        // 存储所有的观察者<br>        this.subs = []<br>    }<br>    // 添加观察者<br>    addSub (sub) {<br>        if (sub &amp;&amp; sub.update) {<br>            this.subs.push(sub)<br>        }<br>    }<br>    // 通知所有观察者<br>    notify () {<br>        this.subs.forEach(sub =&gt; {<br>            sub.update()<br>        })<br>    }<br>}<br>// 观察者(订阅者)<br>class Watcher {<br>    update () {<br>        console.log(‘update’)<br>    }<br>}<br>// 测试<br>let dep = new Dep()<br>let watcher = new Watcher()<br>dep.addSub(watcher)<br>dep.notify()<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_3/3_3/6_1.png"><br>7.模拟Vue响应式原理-分析<br>简单的了解下Vue的响应机制<br><img src="https://snakexu.github.io/images/lagou/part_3/3_3/7_1.png"><br>Vue</p>
<ul>
<li>把 data 中的成员注入到 Vue 实例，并且把 data 中的成员转成 getter/setter<br>Observer</li>
<li>能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知 Dep<br>Compiler</li>
<li>解析每个元素中的指令/插值表达式，并替换成相应的数据<br>Dep</li>
<li>添加观察者(watcher)，当数据变化通知所有观察者<br>Watcher</li>
<li>数据变化更新视图<br>8.Vue<br>功能</li>
<li>负责接收初始化的参数(选项)</li>
<li>负责把 data 中的属性注入到 Vue 实例，转换成 getter/setter</li>
<li>负责调用 observer 监听 data 中所有属性的变化</li>
<li>负责调用 compiler 解析指令/插值表达式<br>结构<br><img src="https://snakexu.github.io/images/lagou/part_3/3_3/8_1.png"><br>$options:记录构造函数中传入的参数<br>$el:记录构造函数中传入的参数<br>$data:记录构造函数中传入的参数<br>_proxyData():私有方法<br><pre><br>class Vue {<br>  constructor (options) {<pre><code>// 1.通过属性保存选项的数据
this.$options = options || {}
this.$data = options.data || {}
const el = options.el
this.$el = typeof options.el === &apos;string&apos; ? document.querySelector(el) : el
// 2.把data中的成员转换成getter和setter，注入到vue实例中
this._proxyData(this.$data)
// 3.调用observer对象，监听数据的变化
// 4.调用compiler对象，解析指令和差值表达式
</code></pre>  }<br>  _proxyData (data) {<pre><code>Object.keys(data).forEach(key =&gt; {
    Object.defineProperty(this, key, {
        get () {
            return data[key]
        },
        set (newValue) {
            if (data[key] === newValue) {
                return
            }
            data[key] = newValue
        }
    })
})
</code></pre>  }<br>}<br></pre><br>9.Observer<br>功能</li>
<li>负责把 data 选项中的属性转换成响应式数据</li>
<li>data 中的某个属性也是对象，把该属性转换成响应式数据</li>
<li>数据变化发送通知<br>结构<br><img src="https://snakexu.github.io/images/lagou/part_3/3_3/9_1.png"><br>walk(data):遍历data中的所有属性<br>defineReactive(data, key, value):定义响应式数据，也就是通过调用Object.defineproperty把属性转换成getter和setter<br><pre><br>// 负责数据劫持<br>// 把 $data 中的成员转换成 getter/setter<br>class Observer {<br>  constructor (data) {<pre><code>this.walk(data)
</code></pre>  }<br>  // 1.判断数据是否是对象，如果不是对象返回<br>  // 2.如果是对象，遍历对象的所有属性，设置为getter/setter<br>  walk (data) {<pre><code>if (!data || typeof data !== &apos;object&apos;) {
    return 
}
//遍历data所有成员
Object.keys(data).forEach(key =&gt; {
    this.defineReactive(data, key, data[key])
})
</code></pre>  }<br>  //定义响应式成员<br>  defineReactive (data, key, val) {<pre><code>Object.defineProperty(data, key, {
    configurable: true,
    enumerable: true,
    get () {
        // console.log(data)
        return val
    },
    set (newValue) {
        if (newValue === val) {
            return 
        }
        val = newValue
    }
})
</code></pre>  }<br>}<br></pre><br>10.Observer-defineReative1<br>我们注意到在defineReactive (data, key, val)中我们传入了val，从上面defineReactive中我们可以看到其实这里的参数val就是data[key]的值，那为什么还要单独传这个值呢，原因有二：<br>一是当我们调用例如vm.msg(也就是index.html中调用定义的$data中的值)时，如果这里用data[key]取值，按照我们整个代码逻辑，这里会发生死递归<br>二是利用闭包原理扩大val的作用域<br>11.Observer-defineReative2<br>之前我们的代码中，只能使data中定义的基础类型是响应式的，但是如果是对象类型就不是响应式了，这里我们完善这个地方<br><pre><br>//定义响应式成员<br>defineReactive (data, key, val) {<br>  // 如果val是对象，继续设置它下面的成员为响应式数据<br>  this.walk(val)<br>  Object.defineProperty(data, key, {<pre><code>configurable: true,
enumerable: true,
get () {
    // console.log(data)
    return val
},
set (newValue) {
    if (newValue === val) {
        return 
    }
    val = newValue
}
</code></pre>  })<br>}<br></pre><br>另外，如果我们给data中某个值进行重新赋值，那新值会是响应式对象么<br><pre><br>//定义响应式成员<br>defineReactive (data, key, val) {<br>  const that = this<br>  // 如果val是对象，继续设置它下面的成员为响应式数据<br>  this.walk(val)<br>  Object.defineProperty(data, key, {<pre><code>configurable: true,
enumerable: true,
get () {
    // console.log(data)
    return val
},
set (newValue) {
    if (newValue === val) {
        return 
    }
    // 如果newValue是对象，设置newValue的成员为响应式
    that.walk(newValue)
    val = newValue
}
</code></pre>  })<br>}<br></pre><br>12.Compiler<br>13.Compiler-compile<br>14.Compiler-compileText<br>15.Compiler-compileElement<br>16.Compiler 复习<br>这里笔记包含了12-15小节<br>Compiler<br>功能</li>
<li>负责编译模板，解析指令/插值表达式</li>
<li>负责页面的首次渲染</li>
<li>当数据变化后重新渲染视图<br>结构<br>compile(el): 编译模版，处理文本节点和元素节点<br>compileElement(node): 编译属性节点<br>compileText(node): 编译文本节点<br>isDirective(attrName): 判断是否是以 v- 开头的指令<br>isTextNode(node): 判断是否是文本节点<br>isElementNode(node): 判断是否是属性节点<br><pre><br>// 负责解析指令/插值表达式<br>class Compiler {<br>  constructor (vm) {<pre><code>this.vm = vm
this.el = vm.$el
//编译模版
this.compile(this.el)
</code></pre>  }<br>  // 编译模版<br>  // 处理文本节点和元素节点<br>  compile (el) {<pre><code>const nodes = el.childNodes
Array.from(nodes).forEach(node =&gt; {
    //判断是文本节点还是元素节点
    if (this.isTextNode(node)) {
        this.compileText(node)
    } else if (this.isElementNode(node)) {
        this.compileElement(node)
    }
    if (node.childNodes &amp;&amp; node.childNodes.length) {
        // 如果当前节点中还有子节点，递归编译
        this.compile(node)
    }
})
</code></pre>  }<br>  // 判断是否是文本节点<br>  isTextNode (node) {<pre><code>return node.nodeType === 3
</code></pre>  }<br>  // 判断是否是属性节点<br>  isElementNode (node) {<pre><code>return node.nodeType === 1
</code></pre>  }<br>  // 判断是否是以 v- 开头的指令<br>  isDirective (attrName) {<pre><code>return attrName.startsWith(&apos;v-&apos;)
</code></pre>  }<br>  // 编译文本节点<br>  compileText (node) {<pre><code>const reg = /\{\{(.+)\}\}/
//获取文本节点的内容
const value = node.textContent
if (reg.test(value)) {
    // 插值表达式中的值就是我们要的属性名称
    const key = RegExp.$1.trim()
    // 把插值表达式替换成具体的值
    node.textContent = value.replace(reg, this.vm[key])
}
</code></pre>  }<br>  // 编译属性节点<br>  compileElement (node) {<pre><code>// 遍历元素节点中的所有属性，找到指令
Array.from(node.attributes).forEach(attr =&gt; {
    //获取元素属性的名称
    let attrName = attr.name
    //判断当前的属性名称是否是指令
    if (this.isDirective(attrName)) {
        // attrName 的形式 v-text t-model
        // 截取属性的名称，获取 text model
        attrName = attrName.substr(2)
        // 获取属性的名称，属性的名称就是我们数据对象的属性 v-text=&quot;name&quot; ，获取的是name
        const key = attr.value
        // 处理不同的指令
        this.update(node, key, attrName)
    }
})
</code></pre>  }<br>  // 负责更新DOM<br>  // 创建watcher<br>  update (node, key, dir) {<pre><code>// node 节点，key 数据的属性名称，dir 指令的后半部分
const updateFn = this[dir + &apos;Updater&apos;]
updateFn &amp;&amp; updateFn(node, this.vm[key])
</code></pre>  }<br>  // v-text 指令的更新方法<br>  textUpdater (node, value) {<pre><code>node.textContent = value
</code></pre>  }<br>  // v-model 指令的更新方法<br>  modelUpdater (node, value) {<pre><code>node.value = value
</code></pre>  }<br>}<br></pre><br>在vue.js中我们要引用这个方法<br><pre><br>// 4.调用compiler对象，解析指令和差值表达式<br>new Compiler(this)<br></pre><br>17.Dep<br><img src="https://snakexu.github.io/images/lagou/part_3/3_3/17_1.png"><br>功能</li>
<li>收集依赖，添加观察者(watcher)</li>
<li>通知所有观察者<br><pre><br>class Dep {<br>  constructor () { <pre><code>// 存储所有的观察者 
this.subs = [] 
</code></pre>  }<br>  // 添加观察者<br>  addSub (sub) { <pre><code>if (sub &amp;&amp; sub.update) { 
    this.subs.push(sub) 
} 
</code></pre>  }<br>  // 通知所有观察者<br>  notify () { <pre><code>this.subs.forEach(sub =&gt; { 
    sub.update() 
}) 
</code></pre>  }<br>}<br>//在 compiler.js 中收集依赖，发送通知<br>// defineReactive 中<br>// 创建 dep 对象收集依赖<br>const dep = new Dep()<br>// getter 中<br>// get 的过程中收集依赖<br>Dep.target &amp;&amp; dep.addSub(Dep.target)<br>// setter 中<br>// 当数据变化之后，发送通知<br>dep.notify()<br></pre><br>18.watcher<br>19.创建watcher对象1<br>20.创建watcher对象2</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/05/拉勾-模拟Vue-js响应式原理/" data-id="ckeeij34h004qjoxqj5baqzu6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-Vue-Router实现原理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/03/拉勾-Vue-Router实现原理/" class="article-date">
  <time datetime="2020-08-03T00:34:20.000Z" itemprop="datePublished">2020-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/03/拉勾-Vue-Router实现原理/">拉勾-Vue-Router实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.课程介绍<br>略<br>2.Vue Router基础回顾-使用步骤<br>这里简单介绍了vue-router的基本使用。vue.use(参数)，当参数是对象的时候，用install去处理，当参数是函数的时候调用函数创建组件。$route是路由规则，存储了当前的路由数据，也就是路由规则，包括路径和参数等。$router是vuerouter的实例，也就是路由对象，包含各种路由方法和导航守卫、路由模式等。<br>3.动态路由<br>这里介绍了另外一种传递路由参数的办法，利用路由的props传值<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/3_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/3_2.png"><br>4.嵌套路由<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/4_1.png"><br>5.编程式导航<br>主要讲了push、replace、go，其中replace方法不会记录本次历史，会把我们当前的历史改编成replace的参数页面<br>6.Hash模式和History模式的区别<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/6_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/6_2.png"><br>7.History 模式<br>10.Vue Router实现原理<br>前置知识<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/10_1.png"><br>Hash模式<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/10_2.png"><br>History模式<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/10_3.png"><br>11.Vue Router模拟实现-分析<br>回顾核心代码<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/11_1.png"><br>Vue.use(函数/对象)，如果传入函数，Vue.use内部会调用这个函数；如果传入对象，Vue.use内部会调用这个对象的install方法<br>new VueRouter，创建一个VueRouter的实例，所以VueRouter是一个构造函数或者是一个类，并且这个类有一个静态的install方法<br>最后创建一个vue实例，并且传入我们刚才创建好router的对象<br>Vue Router的类图<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/11_2.png"><br>其中前三个是属性后面是方法<br>+options:记录构造函数中传入的对象，在传入对象的时候传入了路由规则，options就记录了传入的这个对象<br>+data:对象，有一个属性current用来记录当前路由地址。这里是因为我们需要一个响应式的对象，因为路由地址发生变化的时候，组件要自动更新，可以调用vue.observable使其变成响应式对象<br>+routeMap:对象，记录路由地址和组件的对应关系，将来会把规则解析到RouteMap中<br>下面的方法中，带加号的是对外公开的方法，下划线是静态的方法<br>+Constructor(Options):VueRouter 构造函数，初始化属性<br>_install(Vue):void 静态方法，用来实现vue的插件机制<br>+init():void 用来调用下面的initEvent、createRouteMap、initComponents方法<br>+initEvent():void 用来注册popState事件，用来监听历史的变化<br>+createRouteMap():void 用来初始化routemap属性，把构造函数中的路由规则转换成键值对的形式存储到routemap中，键就是路由地址，值就是对应组件<br>+initComponents(Vue):void 用来创建router-link、router-view这两个组件<br>12.Vue Router-install<br>13.Vue Router-构造函数<br>14.Vue Router-createRouteMap<br>15.Vue Router-router-link<br>上面几节课的内容合并到这里，主要就是代码</p>
<p><pre><br>// vuerouter/index.js<br>let _Vue = null<br>export default class VueRouter {<br>  static install (Vue) {<br>    // 1.判断当前插件是否已经被安装<br>    if (VueRouter.install.installed) {<br>      return<br>    }<br>    VueRouter.install.installed = true<br>    // 2.把Vue构造函数记录到全局变量(在vue实例中需要使用)<br>    _Vue = Vue<br>    // 3.把创建Vue实例时候传入的router对象注入到Vue实例上<br>    // 混入<br>    _Vue.mixin({ // 拿到Vue实力的时候才写入<br>      beforeCreate () {<br>        if (this.$options.router) { // 判断在不是组件是路由的情况下才用<br>          _Vue.prototype.$router = this.$options.router<br>          this.$options.router.init()<br>        }<br>      }<br>    })<br>  }</pre></p>
<p>  constructor (options) {<br>    this.options = options<br>    this.routeMap = {}<br>    this.data = _Vue.observable({<br>      current: ‘/‘<br>    })<br>  }</p>
<p>  init () {<br>    this.createRouteMap()<br>    this.initComponents(_Vue)<br>  }</p>
<p>  createRouteMap () {<br>    // 遍历所有路由规则，把路由规则解析成键值对的形式，存储到routeMap中<br>    this.options.routes.forEach(route =&gt; {<br>      this.routeMap[route.path] = route.component<br>    })<br>  }</p>
<p>  initComponents (Vue) { // 这里传入Vue是为了减少对外部的依赖<br>    Vue.component(‘router-link’, {<br>      props: {<br>        to: String<br>      },<br>      //这里就是实现把router-link标签中的内容放到a标签中<br>      template: ‘&lt; a :href=”to” &gt;&lt; slot &gt;&lt; /slot &gt;&lt; /a &gt;’<br>    })<br>  }<br>}<br><br>完成上面代码后，我们把router/index.js中引入的import VueRouter from ‘vue-router’替换成我们刚才写的import VueRouter from ‘../vuerouter’。npm run serve后发现报错，其中一个错误是(另外一个错误是因为我们没有实现router-view，这个后续再解决)<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/15_2.png"><br>原因是vue-cli默认采用的运行时代码<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/15_1.png"><br>16.Vue Router-完整版的Vue<br>vue-cli官方文档，切换到配置参考<br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/16_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_3/3_2/16_2.png"><br>到这里，我们知道如何配置完整版的Vue了，也就解决了之前报错的一个内容<br>17.Vue Router-render<br>上节课我们学会使用完整版vue解决手写vuerouter报错的一个问题，这节课用运行时版本解决问题。<br>删除上节课增加的配置文件vue.config.js。既然完整版主要是编译模版template，那么我们这里就不用template去写我们的代码，转而用更接近vue底层的render函数</p>
<p><pre><br>initComponents (Vue) {<br>    Vue.component(‘router-link’, {<br>      props: {<br>        to: String<br>      },<br>      render (h) {<br>          return h(‘a’,{<br>              attrs: {<br>                  href: this.to<br>              }<br>          },[this.$slots.default])<br>      }<br>    })<br>}<br></pre><br>18.Vue Router-rouer-view</p>
<p><pre><br>initComponents (Vue) { // 这里传入Vue是为了减少对外部的依赖<br>    Vue.component(‘router-link’, {<br>      props: {<br>        to: String<br>      },<br>      render (h) {<br>        return h(‘a’, {<br>          attrs: {<br>            href: this.to<br>          }<br>        }, [this.$slots.default])<br>      }<br>    })<br>    const self = this<br>    Vue.component(‘router-view’, {<br>      render (h) {<br>        const component = self.routeMap[self.data.current]<br>        return h(component)<br>      }<br>    })<br>  }<br></pre><br>到这里，基本的路由需求完成的差不多了，但是此时运行项目，会发现点击网页页面链接，页面会闪。想一下，其实页面闪的时候是在向服务器发送请求，请求页面，但是单页应用中我们并不想向服务器发送请求，我们需要给超链接一个点击事件，取消后续内容的执行，不让地址跳转，并且把地址栏中的地址改为超链接的href中的地址，又不让浏览器去请求服务器，于是想到了pushState这个方法，这个方法可以改变路径，又不会发送请求，还会记录到历史记录中，但是页面相应组件还是要我们自己加载。我们代码中的current记录了当前路径，data又是响应式的数据</p>
<p><pre><br>Vue.component(‘router-link’, {<br>  props: {<br>    to: String<br>  },<br>  render (h) {<br>    return h(‘a’, {<br>      attrs: {<br>        href: this.to<br>      },<br>      on: {<br>        click: this.clickHandler<br>      }<br>    }, [this.$slots.default])<br>  },<br>  methods: {<br>    clickHandler (e) {<br>      history.pushState({}, ‘’, this.to)<br>      this.$router.data.current = this.to<br>      e.preventDefault()<br>    }<br>  }<br>})<br></pre><br>19.Vue Router-initEvent<br>虽然上面我们实现了基本功能，但是点击浏览器后退按钮，我们发现页面没有刷新，还是停留在当前页面，所以需要initEvent事件，做这个功能</p>
<p><pre><br>init () {<br>    this.createRouteMap()<br>    this.initComponents(_Vue)<br>    this.initEvent()<br>}<br>initEvent () {<br>    window.addEventListener(‘popstate’, () =&gt; {<br>        this.data.current = window.location.pathname<br>    })<br>}<br></pre><br>这样我们就实现浏览器前进后退的刷新了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/03/拉勾-Vue-Router实现原理/" data-id="ckeeij34e004ijoxqjk2ejojh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-Vue-js基础回顾" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/02/拉勾-Vue-js基础回顾/" class="article-date">
  <time datetime="2020-08-02T15:50:58.000Z" itemprop="datePublished">2020-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/02/拉勾-Vue-js基础回顾/">拉勾-Vue.js基础回顾</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.阶段内容<br>就是主要说了下接下来的课程都讲那些内容，略<br>2.Vue基础结构<br><img src="https://snakexu.github.io/images/lagou/part_3/3_1/2_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_3/3_1/2_2.png"><br>render(h)中h是创建虚拟DOM，render是把h创建的虚拟DOM返回，$mount是把虚拟DOM转换成真实DOM渲染到浏览器<br>3.vue生命周期<br><img src="https://snakexu.github.io/images/lagou/part_3/3_1/3_1.png"><br>其中上面提到的h也是在截图中初始化的阶段的<br><img src="https://snakexu.github.io/images/lagou/part_3/3_1/3_2.png"><br>初始化注入会注入props、data等成员。在created的时候，vue创建完毕<br><img src="https://snakexu.github.io/images/lagou/part_3/3_1/3_3.png"><br>这里会帮我们将模版编译成render函数<br><img src="https://snakexu.github.io/images/lagou/part_3/3_1/3_4.png"><br>挂载与修改过程。这里注意，在befortUpdate中拿到的是更新前的data，在update才能拿到更新后的data<br><img src="https://snakexu.github.io/images/lagou/part_3/3_1/3_5.png"><br>销毁阶段<br>4.vue语法和概念-上<br>5.vue语法和概念-下<br>4&amp;5都是简单串讲了vue的基础，这里不赘述，可以查看vue官方文档</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/02/拉勾-Vue-js基础回顾/" data-id="ckeeij2zu000ujoxq80s7l3js" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-规范化标准" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/29/拉勾-规范化标准/" class="article-date">
  <time datetime="2020-07-29T00:08:35.000Z" itemprop="datePublished">2020-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/29/拉勾-规范化标准/">拉勾-规范化标准</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.规范化介绍<br>(1)为什么要有规范化标准<br>·软件开发需要多人协同<br>·不同开发者具有不同的编码习惯和喜好<br>·不同的喜好增加项目维护成本<br>·每个项目或团队需要明确统一的标准<br>(2)哪里需要规范化标准<br>·代码、文档、甚至是提交日志<br>·开发过程中认为编写的成果<br>·代码标准化规范最为重要<br>(3)实施规范化方法<br>·编码前人为的标准约定<br>·通过工具实现lint(代码规范化检查)<br>常见的规范化实现方式<br>·ESLint工具使用<br>·定制ESLint校验规则<br>·ESLint对TypeScript的支持<br>·ESLint结合自动化工具或者webpack<br>·基于ESLint的衍生工具<br>·Stylelint工具的使用<br>2.ESLint介绍<br>最为主流的JavaScript lint工具，监测js代码质量<br>ESLint很容易统一开发者的编码风格<br>ESLint可以帮开发者提升编码能力<br>3.ESLint 安装<br>安装步骤<br>·初始化项目<br>·安装ESLint模块为开发依赖<br>·通过CLI命令验证安装结果<br>这里老师说道现阶段已经很少有项目需要安装全局依赖，这样别的开发者在拿到项目之后只要npm install就行，不必关心安装了什么全局依赖。在用npm init初始化项目之后，安装eslint依赖，然后我们进入node_modules目录下，找到eslint安装目录的.bin目录，通过前面我们知道通常.bin目录下有该模块可以执行的文件，我们可以通过这个cli程序检测代码。对于这个文件，我们可以通过yarn或者npx去执行<br>4.ESLint快速上手<br>ESLint检查步骤<br>·编写”问题”代码<br>·使用ESLint执行检测<br>·完成ESLint使用配置<br>在我们上节课初始化的项目中编写一段”问题”代码</p>
<p><pre><br>const foo=123<br>function fn() {<br>    console.log(‘hello’)<br>      console.log(‘eslint’)<br>}<br>fn(<br>suyy()<br></pre><br>执行npx eslint ./01-prepare.js 命令之后，命令行会报错，我们跟着命令行的提示执行npx eslint –init，选择你所需要的选项，最后eslint帮我们安装依赖之后，再次执行npx eslint ./01-prepare.js，会报一个错误，就是我们在调用fn时只写了一半括号的语法错误，修正这个语法错误之后，再执行npx eslint ./01-prepare.js会报更多错误，因为eslint在有语法错误的时候是没办法检查问题代码和代码风格的。执行npx eslint ./01-prepare.js –fix 可以修正一部分代码风格上的问题，其余问题需要手工修改<br>5.ESLint配置文件解析<br>npx eslint –init 命令生成的.eslintrc.js文件里的配置会影响当前目录以及所有子目录的文件，正常情况下我们不会手动修改这个配置，但是如果我们需要开启或者关闭某些校验规则的时候，这个配置文件就会非常重要。下面是我们通过npx eslint –init命令生成的.eslintrc.js文件的内容。由于这个文件运行在node环境下，所以可以看到用module.exports导出了配置</p>
<p><pre><br>module.exports = {<br>  env: { // 标记当前代码的运行环境，eslint会根据环境信息判断当前成员是否可用<br>    browser: true, // 这里标记运行在浏览器环境中，可以运行比如document、window这种全局对象，不可以使用global等node对象<br>    es2020: true<br>  },<br>  extends: [ // 继承一些共享的配置，可以配置多个项目共享一些配置，后续会讲到<br>    ‘standard’<br>  ],<br>  parserOptions: { // 设置语法解析器的相关配置，控制是否可以使用某一个es版本的语法<br>    ecmaVersion: 11 // 只是语法检测，不代表某个成员是否可用<br>  },<br>  rules: { // 配置eslint中某些规则的开启或者关闭<br>      ‘no-alert’:’error’ // 这里举例开启no-alert(规则名称是内置的)，值可以取 off 关闭,error 报错,warn 警告<br>  },<br>  globals: { // 在最新版本的默认配置中已经没有体现了，额外生命代码中可以使用的全局成员<br>     “jQuery”: “readonly” // 这样jQuery就可以作为全局成员被使用了<br>     // 项目文件中可以使用例如 jQuery(‘#abc’)<br>  }<br>}<br>// 02-configuration.js<br>document.getElementById(‘#abc’)<br></pre><br>如果我们删除掉env的browser:true，再运行 npx eslint ./02-configuration.js ，并不会报错是因为我们在生成配置文件的时候选择的standard风格，最终这里就继承了standard风格中的配置，而在standard配置中也做了一些额外的具体配置，所以document/window在任何环境都可以使用，看下图，打开了node_modules中eslint-config-standard相关内容，我们的项目继承这里。但是如果我们注释掉document相关，写上alert(1)再运行npx eslint ./02-configuration.js 就会报错，这就证明eslint确实是根据env设置的成员环境判断变量<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/5_1.png"><br>下面是env成员可以设置的变量，另外这些环境并不是互斥的，也就说我们可以选择多个环境并存<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/5_2.png"><br>6.ESLint配置注释<br>ESLint配置注释可以理解为将配置作为注释写在脚本文件中，然后再去执行代码的校验(比如项目中有一两个点必须违反eslint的校验规则)，比如下面违反校验规则的代码。临时禁用eslint校验规则的语法可以参考官方文档<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/6_1.png"><br>一种临时禁用的方式<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/6_2.png"><br>只在当前行忽略校验规则<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/6_3.png"><br>eslint校验规则官网地址<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/6_4.png"><br>7.ESLint结合自动化工具<br>如果有自动化工具，最好还是把eslint结合自动化工具，这样的好处<br>·继承之后，ESLint一定会工作<br>·与项目统一，管理更加方便<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/7_1.png"><br>后续会用到的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/29/拉勾-规范化标准/" data-id="ckeeij2zx000yjoxqbxjkgemo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-其他打包工具" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/拉勾-其他打包工具/" class="article-date">
  <time datetime="2020-07-28T03:39:09.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/28/拉勾-其他打包工具/">拉勾-其他打包工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.Rollup概述<br>Rollup与webpack很类似，但是Rollup更为小巧，相比于webpack能配合各种loader/plugin几乎完成开发过程中所有需求，Rollup仅是ESModules打包器，并没有任何其他额外功能。开发初衷仅仅是提供一个充分利用ESM各项特性的高效打包器<br>2.Rollup快速上手<br>新建一个项目</p>
<p><pre><br>// ./src/index.js<br>import {log} from ‘./logger’<br>import messages from ‘./messages’<br>const msg = messages.hi<br>log(msg)<br>// ./src/logger.js<br>export const log = msg =&gt;{<br>    console.log(‘——INFO——‘)<br>    console.log(msg)<br>    console.log(‘—————-‘)<br>}<br>export const error = msg =&gt;{<br>    console.log(‘——ERROR——‘)<br>    console.log(msg)<br>    console.log(‘—————-‘)<br>}<br>// ./src/messages.js<br>export default {<br>    hi: ‘Hey Guys,I am hapi’<br>}<br></pre><br>安装rollup之后执行yarn rollup 会得到命令提示，执行 yarn rollup ./src/index.js  ，不知道是不是由于版本不同，课程里这样会报错，我自己执行的时候并没有报错，课程里报错的原因是没有指定输出格式，我的rollup版本是2.23.0 。<br>yarn rollup ./src/index.js –format iife  指定输出格式，会在命令行看到立即执行函数式的输出。<br>yarn rollup ./src/index.js –format iife –file dist/bundle.js 指定输出目录。打开输出结果看到</p>
<p><pre><br>(function () {<br>    ‘use strict’;</pre></p>
<pre><code>const log = msg =&gt;{
    console.log(&apos;------INFO------&apos;);
    console.log(msg);
    console.log(&apos;----------------&apos;);
};

var messages = {
    hi: &apos;Hey Guys,I am hapi&apos;
};

const msg = messages.hi;
log(msg);
</code></pre><p>}());<br><br>输出结果非常简单，按照依赖顺序拼接到一起，并且默认开启了tree-shaking<br>3.Rollup配置文件<br>rollup同样支持配置文件rollup.config.js，同样运行在node环境，但是rollup本身会额外处理这个配置文件，所以在这个文件中可以直接使用ESModule。</p>
<p><pre><br>export default {<br>    input: ‘src/index.js’, // 指定入口文件<br>    output: { // 输出相关配置，要求是一个对象<br>        file: ‘dist/bundle.js’, //输出文件名<br>        format: ‘iife’ // 输出格式<br>    }<br>}<br></pre><br>这里执行yarn rollup –config 来告诉rollup，根据配置文件执行，也可以根据这个参数指定配置文件的名称，比如 yarn rollup –config rollup.config.js 或者 yarn rollup –config rollup.development.js等<br>4.Rollup使用插件<br>Rollup自身的功能就只是ESModules模块的合并打包，如果项目有更高级的需求，例如加载其他类型的资源文件、导入commonjs模块、编译ECMAScript新特性等，这些额外的需求，Rollup支持使用插件的方式扩展，插件是Rollup唯一的扩展方式。我们举例一个导入JSON文件的插件，插件名字rollup-plugin-json</p>
<p><pre><br>//rollup.config.js<br>import json from ‘rollup-plugin-json’ //默认导出的是插件函数<br>export default {<br>    input: ‘src/index.js’, // 指定入口文件<br>    output: { // 输出相关配置，要求是一个对象<br>        file: ‘dist/bundle.js’, //输出文件名<br>        format: ‘iife’ // 输出格式<br>    },<br>    plugins: [<br>        json() // 这里是调用的插件结果<br>    ]<br>}<br>//index.js<br>import {log} from ‘./logger’<br>import messages from ‘./messages’<br>import { name, version } from ‘../package.json’<br>const msg = messages.hi<br>log(msg)<br>log(name)<br>log(version)<br></pre><br>执行yarn rollup –config 之后可以在打包结果文件中看到我们打印的package.json文件的信息<br>6.Rollup加载NPM模块<br>rollup只能加载本地模块，不能像webpack一样直接通过模块名称导入node_modules的第三方模块，为了磨平这样一个差异，rollup官方给出了一个rollup-plugin-node-resolve插件，直接在代码中通过名称导入对应模块 </p>
<p><pre><br>//rollup.config.js<br>import json from ‘rollup-plugin-json’ //默认导出的是插件函数<br>import resolve from ‘rollup-plugin-node-resolve’<br>export default {<br>    input: ‘src/index.js’, // 指定入口文件<br>    output: { // 输出相关配置，要求是一个对象<br>        file: ‘dist/bundle.js’, //输出文件名<br>        format: ‘iife’ // 输出格式<br>    },<br>    plugins: [<br>        json(), // 这里是调用的插件结果<br>        resolve()<br>    ]<br>}<br>//index.js<br>import {log} from ‘./logger’<br>import messages from ‘./messages’<br>import { name, version } from ‘../package.json’<br>import _ from ‘lodash-es’<br>//这里使用的是lodash的es版本，如果用lodash的普通版本需要额外的处理。毕竟rollup支持的是ESModules<br>const msg = messages.hi<br>log(msg)<br>log(name)<br>log(version)<br>log(_.camelCase(‘hello world’))<br></pre><br>6.Rollup加载CommonJS模块<br>为了支持commonjs方式导出成员，官方给出了插件rollup-plugin-commonjs</p>
<p><pre><br>//rollup.config.js<br>//这几个import的插件都是需要安装的<br>import json from ‘rollup-plugin-json’ //默认导出的是插件函数<br>import resolve from ‘rollup-plugin-node-resolve’<br>import commonjs from ‘rollup-plugin-commonjs’<br>export default {<br>    input: ‘src/index.js’, // 指定入口文件<br>    output: { // 输出相关配置，要求是一个对象<br>        file: ‘dist/bundle.js’, //输出文件名<br>        format: ‘iife’ // 输出格式<br>    },<br>    plugins: [<br>        json(), // 这里是调用的插件结果<br>        resolve(),<br>        commonjs()<br>    ]<br>}<br>//cjs-module.js<br>module.exports = {<br>    foo: ‘bar’<br>}<br>//index.js<br>import {log} from ‘./logger’<br>import messages from ‘./messages’<br>import { name, version } from ‘../package.json’<br>import _ from ‘lodash-es’<br>import cjs from ‘./cjs-module’<br>const msg = messages.hi<br>log(msg)<br>log(name)<br>log(version)<br>log(_.camelCase(‘hello world’))<br>log(cjs)<br></pre><br>执行打包命令就可以在打包结果中看到cjs-module.js(按commonjs标准写的)的内容了<br>7.rollup代码拆分<br>可以使用符合ESModules的动态导入实现按需加载，rollup内部也会自动处理代码的分包。</p>
<p><pre><br>import(‘./logger’).then(({ log }) =&gt; {<br>    log(‘code splitting’)<br>})<br></pre><br>如果像上面一样直接在index.js中动态导入logger并且按照我们之前在rollup.config.js中设置的output.format:’iife’去打包会报错，因为iife会把所有模块放到同一个函数当中，这样就没法实现代码拆分，所以只能以AMD或者CMD等的标准去输出打包结果，在浏览器环境中只能使用AMD的标准，这里运行yarn rollup –config –format amd把我们之前在配置文件中定义的输出格式覆盖掉，但是这里还是会报错，因为多个输出不能使用file这种配置方式，因为file是指定一个单个文件输出的文件名</p>
<p><pre><br>output: {<br>    dir: ‘dist’,<br>    format: ‘amd’<br>},<br></pre><br>所以rollup是以动态导入的方式实现代码的拆分<br>8.Rollup多入口打包<br>Rollup同样支持多入口打包，而且对于多个入口当中的公共部分也会提取到单个文件当中做独立的bundle</p>
<p><pre><br>// index.js<br>import fetchApi from ‘./fetch’<br>import { log } from ‘./logger’<br>fetchApi(‘/posts’).then(data =&gt; {<br>    data.forEach(item =&gt; {<br>        log(item)<br>    })<br>})<br>// album.js<br>import fetchApi from ‘./fetch’<br>import { log } from ‘./logger’<br>fetchApi(‘/photos?albumId=1’).then(data =&gt; {<br>    data.forEach(item =&gt; {<br>        log(item)<br>    })<br>})<br>// fetch.js<br>export default endpoint =&gt; {<br>    return fetch(<code>https://jsonplaceholder.typicode.com${endpoint}</code>)<br>        .then(response =&gt; response.json())<br>}<br>// logger.js<br>export const log = msg =&gt;{<br>    console.log(‘——INFO——‘)<br>    console.log(msg)<br>    console.log(‘—————-‘)<br>}<br>export const error = msg =&gt;{<br>    console.log(‘——ERROR——‘)<br>    console.log(msg)<br>    console.log(‘—————-‘)<br>}<br></pre><br>至于rollup.config.js根据input的书写方式，可以有两种</p>
<p><pre><br>export default {<br>    input: [‘src/index.js’, ‘src/album.js’],<br>    output: {<br>        dir: ‘dist’,<br>        format: ‘amd’<br>    },<br>}<br>// 或者<br>export default {<br>    input: {<br>        foo:’src/index.js’,<br>        bar:’src/album.js’<br>    },<br>    output: {<br>        dir: ‘dist’,<br>        format: ‘amd’<br>    },<br>}<br></pre><br>但是根据AMD格式打包的文件不能直接引用到页面上，而必须通过实现AMD标准的库去加载，可以手动在dist打包目录写入一个index.html，然后通过requirejs引入打包结果<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/8_1.png"><br>然后通过http服务启动页面就能看到打包结果正常被处理了<br>9.Rollup选用原则<br>相较于webpack，rollup的优势在于：<br>·输出的结果更加扁平一些，执行效率自然就会更高<br>·自动移除未引用的代码<br>·打包结果依然完全可读<br>缺点在于<br>·加载非ESM的第三方模块比较复杂<br>·模块最终都被打包到一个函数中，无法实现HMR<br>·浏览器环境中，代码拆分功能依赖AMD库<br>如果我们开发的是一个应用程序，rollup在满足上会有一些欠缺<br>如果我们正在开发一个框架或者一个类库，很少的在我们的代码中依赖第三方模块。所以大多数知名框架/库都在使用rollup。<br>社区中希望二者并存，即更专业的工具做更专业的事情。webpack大而全，rollup小而美。<br>总结：开发应用程序建议选择webpack，开发类库或者框架建议选择rollup<br>10.Parcel<br>Parcel是一款完全零配置的前端应用打包器<br>首先yarn init初始化一个项目，然后yarn add parcel-bundler –dev,在根目录下创建src目录，在src目录中创建index.html，Parcel官方建议把html文件作为打包入口<br>index.html文件<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_1.png"><br>foo.js文件<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_2.png"><br>main.js文件<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_3.png"><br>执行yarn parcel src/index.html , 其中src/index.html是指定入口文件。发现parcel不仅帮我们打包了应用，还开启了类似于webpack-dev-server的开发服务器。我们更改代码保存过后可以看到浏览器自动刷新<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_4.png"><br>另外parcel还支持模块的热替换，甚至还支持自动安装依赖，如果我们在页面中import jquery，然后直接写jquery的语法，那么parcel在保存代码的时候会帮我们安装依赖<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_5.png"><br>除此之外parcel同样支持加载其他类型的资源模块，相比其他打包器，在parcel中加载其他资源模块依然是零配置的，例如我们加载了一个css文件并且在main.js中引入这个css文件，保存过后样式可以立即生效。还可以随意添加图片。<br>支持动态导入代码拆分<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_6.png"><br>yarn parcel build src/index.html 可以以生产模式进行打包。对于相同体量的打包，parcel的构建速度比webpack快很多，因为parcel内部是使用多进程同时去工作(webpack可以使用happypack插件实现多进程打包)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/28/拉勾-其他打包工具/" data-id="ckeeij34f004kjoxqg5l18aau" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-Webpack打包" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/17/拉勾-Webpack打包/" class="article-date">
  <time datetime="2020-07-17T04:27:15.000Z" itemprop="datePublished">2020-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/17/拉勾-Webpack打包/">拉勾-Webpack打包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.模块打包工具的由来<br>·ES Modules存在环境兼容问题<br>·模块文件过多，网络请求频繁<br>·所有前端资源都需要模块化(css、html等文件)<br>所以模块化是必要的<br>思考下，我们对于模块化的需求总结为<br>·新特性代码编译<br>·模块化JavaScript打包<br>·支持不同类型的资源模块<br>2.模块打包工具概要<br>前端有几个打包工具很好的解决了我们在上一节课中总结出来的模块化的需求，这几个工具主要包括webpack、parcel、rollup。以webpack为例，能很好的满足我们上一节总结的需求。webpack作为一个模块化打包工具，能很好的解决JavaScript打包的问题，可以将零散的模块代码打包到同一个js文件当中，对于代码中有环境兼容问题的代码，我们就可以在打包的过程中通过模块加载器Loader对其进行编译转换；其次，webpack还具备代码拆分(code splitting)能力，能够将应用中所有的代码按照我们的需要进行打包；最后，webpack支持我们在JavaScript当中以模块化方式载入任意类型的文件。剩下两个打包工具功能类似，所有打包工具都是以前端模块化为目标(不仅仅是js模块化)，可以使我们更好的使用模块化带来的优势，而忽略模块化带来的影响<br>3.Webpack快速上手<br>首先创建一个项目，目录结构为<br>|-root<br>|–index.html<br>|–src<br>|—heading.js<br>|—index.js</p>
<pre>
//index.html
< !DOCTYPE html >
< html lang="en" >
< head >
    < meta charset="UTF-8" >
    < title >webpack-快速上手< /title >
    < meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" / >
< /head >
< body >
< script type="module" src="src/index.js" >< /script >
< /body >
< /html >
//heading.js
export default () => {
    const element = document.createElement('h2')
    element.textContent = 'hello world'
    element.addEventListener('click', () => {
        alert('hello webpack')
    })
    return element
}
//index.js
import createHeading from './heading.js'
const heading  = createHeading()
document.body.append(heading)
</pre>
启动服务，就能在浏览器中看到结果了
想要尝试webpack，我们要初始化项目，即npm init / yarn init ，然后安装webpack和webpack-cli，然后执行webpack命令，可以看到在根目录下生成文件夹dist，里面的main.js就是我们打包的结果，在index.html中进行修改，引入我们打包的文件
<pre>
< !DOCTYPE html >
< html lang="en" >
< head >
    < meta charset="UTF-8" >
    < title >webpack-快速上手< /title >
    < meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" / >
< /head >
< body >
< script src="dist/main.js" >< /script >
< /body >
< /html >
</pre>
再次启动服务，可以看到和刚才一样的页面了
4.webpack配置文件
webpack4以后的版本支持0配置启动打包，整个打包过程会按照约定将src/index.js作为打包入口，最终打包结果存放到'dist/main.js'中。但是项目中我们往往需要的是自定义一些东西，比如上节课的项目中，我们将index.js改名为main.js，那么我们的入口文件就是main.js，就需要自定义webpack打包入口。这时候我们就需要给webpack添加配置文件。在根目录下新建文件webpack.config.js，这个文件运行在node环境下的js文件，也就是说我们需要按照CommonJs的方式去编写代码
<pre>
const path = require('path')
module.exports = {
    entry: './src/main.js',//入口文件，如果是相对路径，那么./是不能省略的
    output: { //出口文件
        filename: 'bundle.js',
        path: path.join(__dirname, 'output'),//需要绝对路径
    }
}
</pre>
5.webpack工作模式
可以有三种模式(可以直接在命令行中 webpack --mode development ，即 webpack --mode 打包模式)
默认production会启动优化打包结果(比如压缩打包文件等等)
development模式会优化打包速度，添加一些调试过程中需要的辅助到打包代码
none模式运行最原始状态的打包，不会做任何额外的处理
具体三种模式差异，可以在官方文档 https://webpack.js.org/configuration/mode/ 中找到
或者在配置文件中添加mode属性
<pre>
const path = require('path')
module.exports = {
    mode: 'development',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js',
        path: path.join(__dirname, 'output'),
    }
}
</pre>
6.webpack打包结果运行原理
为了更好理解原理，我们将mode设置为最原始的none方式
<pre>
const path = require('path')
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js',
        path: path.join(__dirname, 'output'),
    }
}
</pre>
我们把打包结果折叠之后看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_1.png">
可以看出来，webpack的打包结果是一个立即执行函数，接收一个modules参数，调用的时候传入一个数组，展开这个数组，数组中每一个元素都是一个参数列表相同的函数，
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_2.png">
这里的函数对应的就是我们源代码中的模块
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_3.png">
我们每一个模块最终都会包裹到这样一个函数当中，从而实现模块的私有作用域。
展开webpack入口函数，看到最开始定义一个对象，用于缓存(存放)已经加载过的模块，
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_4.png">
定义了一个require函数，用来加载模块
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_5.png">
在require上挂载一些其他的数据和一些工具函数，这些并不重要
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_6.png">
后面这个函数调用了require函数，传入了一个0开始去加载模块
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_7.png">
这个模块id就是我们上面元素数组的下标，这里才开始加载源代码中的所谓入口模块。
如果想更细致的了解，那么就启动本地服务，通过打断点的方式单步执行，去了解更细节的内容
7.webpack资源模块加载
我们给项目添加一个css文件并且把webpack的入口文件改成这个css文件，执行webpack命令，会发现报错，因为webpack默认只处理JavaScript文件。但是webpack也给了我们提示，需要配置处理当前类型文件的加载器。那么我们开始安装css-loader，安装之后，还要在配置文件中配置一下
<pre>
module: {
    rules: [
        {
            test: /\.css$/,//正则表达式，匹配打包过程中的文件路径
            use: 'css-loader'//匹配所需要的loader
        }
    ]
}
</pre>
即使我们安装了css-loader，但是依然发现，没有作用，因为css-loader的作用就是将css文件转换成为js模块，具体实现就是将css代码push到一个数组当中，这个数组是css-loader内部一个模块提供的，整个过程并没有任何一个地方用到这个数组。所以这里我们需要安装一个style-loader，这个loader的作用就是将css-loader转换的结果通过style标签的形式追加到页面上
<pre>
module: {
    rules: [
        {
            test: /\.css$/,//正则表达式，匹配打包过程中的文件路径
            use: [
            'style-loader',
            'css-loader'
            ]//匹配所需要的loader
            //注意，如果配置了多个loader，那么是从后往前执行的
        }
    ]
}
</pre>
在我们打包好的文件中可以看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_8.png">
也就是style-loader的作用了，在页面上就可以看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_9.png">
loader是webpack的核心特性，通过loader就可以加载任何类型的资源
8.webpack导入资源模块
虽然我们知道如何处理js意外的文件类型了，但是一般而言，打包入口还是js文件，因为打包入口某种程度上来说就是运行入口。我们先将之前css的入口文件改回main.js，然后在main.js中import(导入)main.css文件，因为只需要去执行css文件，所以直接
<pre>import './main.css</pre>
正常情况下，页面是可以正常运行的。我们在写一个heading.css放到heading.js中
<pre>
//heading.css
.heading{
    padding:20px;
    background: #343a40;
    color: #fff;
}
//heading.js
import './heading.css'
export default () => {
    const element = document.createElement('h2')
    element.textContent = 'hello world'
    element.classList.add('heading') //在这里添加了类名，因为css是用类的
    element.addEventListener('click', () => {
        alert('hello webpack')
    })
    return element
}
</pre>
再次运行，还是能正常加载的
在这里我们需要理解，webpack是鼓励把任何当前代码需要的资源文件引入到当前代码中，也就是根据代码的需要动态导入资源，需要资源的不是应用而是此时编写的代码，也就是你这里的代码想要正常工作就必须去加载的资源。试想一下如果样式等还是单独引入到页面文件当中，如果当前代码更新了，不再需要这个资源，又会怎样。所以通过JavaScript代码去引入资源文件或者说建立js和资源文件中的依赖关系是有很明显优势的。JavaScript驱动了整个前端应用，当我们建立了这些依赖关系，逻辑合理，js确实需要这些资源文件；确保上线资源不缺失，都是必要的。总结一下就是，学习新事物，学习的是它的思想和突破点，因为只是了解新事物，大部分人都能做到，比如照着文档学习各种前端技术。
9.webpack文件资源加载器
webpack的loader非常多，只要合理的需求，都能找到相应的loader，这里我们演示几个有代表性的loader。大部分loader都是类似于css-loader，将资源模块转换为js代码的方式去做，但是字体、图片这些，是没有办法通过js的方式去表示的，对于这类的资源，需要用到文件资源加载器，也就是file-loader
<pre>
//main.js
import createHeading from './heading.js'
import './main.css'
import logo from './logo.png'
const heading  = createHeading()
document.body.append(heading)
const img = new Image()
img.src = logo
document.body.append(img)
//webpack.config.js
module: {
        rules: [
        {
            test: /\.css$/,//正则表达式，匹配打包过程中的文件路径
            use: [
            'style-loader',
            'css-loader'
            ]//匹配所需要的loader
            //注意，如果配置了多个loader，那么是从后往前执行的
        },
        {
            test: /.png$/,
            use: 'file-loader'
        }
    ]
}
</pre>
加载图片原理比较简单，就是把刚刚生成图片的名称导出，并在相应入口模块导入刚刚导出的文件路径。
但是运行之后我们发现，图片并不能正常展示。打开开发人员工具看到图片src直接加载了网站根目录下的图片，但是我们网站根目录下并没有这张图片，正确地址应该在网站根目录下的dist文件夹中，这里是由于index.html并没有生成到dist目录而是放在了项目根目录下，所以把项目根目录作为网站根目录，而webpack默认认为所有打包结果都会在网站根目录下，解决的办法就是告诉webpack打包文件在网站的位置
<pre>
output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist'),//需要绝对路径
    publicPath: 'dist/' //默认值为空字符串，表示网站的根目录，我们放在dist下，这里斜线不能省略
},
</pre>
总结一下文件加载器的工作过程：
webpack在打包时遇到图片文件，然后根据配置文件的配置，匹配到对应的文件加载器，此时文件加载器就开始工作了，先将导入的文件拷贝到输出的目录，然后将文件拷贝到输出目录的路径作为当前模块的返回值返回，我们就可以通过模块拿到这个资源的访问路径
10.webpack URL加载器
除了file-loader这种通过拷贝物理文件形式去处理文件资源以外，通过Data URLs去表示文件的方式也非常常见。Data URLs是一种特殊的URL协议，可以用来直接表示一个文件。传统URL一般要求服务器上有一个对应文件，然后我们通过请求这个地址得到服务器上的对应文件。而Data URLs是一种当前URL就可以直接表示文件内容的方式，也就是说这种url文本就已经包含文件的内容，使用的时候不需要发送http请求。比如
<pre>data:text/html;charset=UTF-8,< h1 >html content< /h1 ></pre>
浏览器能根据这段内容解析出来，这是一段html类型文件内容，编码是utf-8，内容是一段包含h1标签的html代码。
对于图片、字体这种无法直接通过文本表示的二进制类型文件，我们可以通过将文件内容进行base64编码，把编码结果去表示文件的内容。在webpack打包静态资源文件的时候，我们同样可以通过这种方式去实现(通过dataURLs就可以以代码的方式表示任意类型的文件)，需要安装url-loader
<pre>
module: {
    rules: [
        {
            test: /\.css$/,//正则表达式，匹配打包过程中的文件路径
            use: [
            'style-loader',
            'css-loader'
            ]//匹配所需要的loader
            //注意，如果配置了多个loader，那么是从后往前执行的
        },
        {
            test: /.png$/,
            use: 'url-loader'
        }
    ]
}
</pre>
再次打包之后我们发现，dist目录下不再有图片文件，打开bundle.js文件，可以看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/10_1.png">
图片文件被转换为base64编码，base64已经包含了文件的内容，就不再需要独立的物理文件了。这种方式比较适合小的资源，因为大的资源会导致文件体积过大。
最佳实践:
·小文件使用Data URLs，减少请求次数
·大文件单独提取存放，提高加载速度
那么如何通过url-loader实现上面的最佳实践呢
<pre>
{
    test: /.png$/,
    use: {
        loader: 'url-loader',
        options: {
            limit: 10 * 1024 //10kb
        }
    }
}
</pre>
超出10kb文件单独提取存放，小于10kb文件转换为Data URLs嵌入代码中。注意如果按照上面的limit方式使用url-loader，就要安装file-loader，因为超出限制的文件，url-loader会调用file-loader
11.webpack常用加载器分类
编译转换类-把资源模块转换为JavaScript代码，例如css-loader
文件操作类-把资源模块拷贝到输出目录，同时将文件的访问路径向外导出，例如file-loader
代码检查类-对加载的资源代码进行校验
12.webpack与ES2015
因为模块打包需要，所以处理import和export，除此之外，并不会转换es6的其他代码特性。如果我们需要webpack对其他es6的特性进行转换，需要配置额外的编译型loader，npm i babel-loader @babel/core @babel/preset-env --save-dev
<pre>
{
    test: /.js$/,
    use: {
        loader: 'babel-loader',
        options: {
            presets: ['@babel/preset-env'] 
        }
    }
}
</pre>
13.webpack加载资源的方式
除了处理import可以触发模块的加载，webpack还提供了其他几种资源加载的方式：
·遵循ES Modules 标准的 import 声明
·遵循CommonJs标准的require函数(如果通过require函数导入一个module，需要注意对esmodule的默认导出，需要导入结果的default属性去获取)
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/13_1.png">
·遵循AMD标准的define函数和require函数
·样式代码中的@import指令和url函数
·HTML代码中图片标签的src属性
以上标准虽然webpack都支持，但是除非必要情况，否则不要混合使用，因为这会大大降低项目的可维护性。
loader加载的非JavaScript也会触发资源加载，样式代码中的@import指令和url函数也会触发相应模块的资源模块的加载。HTML代码中图片标签的src属性也会触发相应模块的加载
<pre>
//main.js
import './main.css'
//main.css
body{
    min-height: 100vh;
    background: #f4f8fb;
    background-image: url(heart.png);
    background-size: cover;
}
</pre>
webpack会用css-loader去打包css文件，但是上面我们加了背景图片，会把这张图片作为一个资源模块加入到打包过程，webpack根据配置文件当中针对我们遇到的文件找到相应的loader。
重新打包启动服务，看到背景图片已经生效了，证明url确实可以触发模块的加载。
<pre>
//main.css
@import url(reset.css)
body{
    min-height: 100vh;
    background: #f4f8fb;
    background-image: url(heart.png);
    background-size: cover;
}
//reset.css
*{
    margin: 0px;
    padding: 0px;
}
</pre>
重新打包启动服务，看到我们在reset.css中写的样式已经在页面生效了。以上是css-loader在加载样式时，样式文件中触发文件加载的两种方式。
下面看html文件加载额外的资源的一些方式
<pre>
//main.js
import './main.css'
import footerHtml from './footer.html'
document.write(footerHtml)
//footer.html
< footer >
    < img src="good.png" alt="good" width="256" >
< /footer >
</pre>
html文件默认会将html代码作为字符串导出，所以需要接收导出的字符串，然后通过document.write输出到页面当中。还要为html模块配置对应的loader，否则webpack不能识别html文件，安装html-loader
<pre>
{
    test: /.html$/,
    use: {
        loader:  'html-loader'
    }
}
</pre>
然后回到终端，重新执行webpack打包命令，启动服务，可以看到图片都可以正常显示，说明html文件中src属性也可以触发资源模块文件的加载。html文件中不止有img的src需要依赖资源，其他标签也有可能需要一些资源的依赖，例如a标签的href属性
<pre>
//main.js
import './main.css'
import footerHtml from './footer.html'
document.write(footerHtml)
//footer.html
< footer >
    < a href="good.png" download="good" >download ping< /a >
< /footer >
</pre>
重新执行webpack打包命令，启动服务，下载图片居然404，因为html-loader默认只处理img标签的src属性，如果其他标签属性也需要出发打包，可以添加相应的一些配置
<pre>
{
    test: /\.html$/i,
    loader: 'html-loader',
    options: {
        attributes: {
            list: [
                {
                    tag: 'img',
                    attribute: 'src',
                    type: 'src',
                },
                {
                    tag: 'a',
                    attribute: 'href',
                    type: 'src',
                },
            ]
        }
    }
}
</pre>
这里我踩到一个坑：Chrome出于安全考虑，禁止从页面打开 Data URI
14.webpack核心工作原理
我们的项目中散落着各种各样的代码和资源文件(js/css/html/png/scss/json...),webpack会根据配置找到文件作为打包入口，一般这个入口会是js文件，然后顺着入口文件的代码，根据代码中的import/require等解析推断这个文件所依赖的资源模块，然后分别解析每个资源模块对应的依赖，最后形成整个项目之间所有依赖关系的依赖树，webpack递归依赖树，找到每个节点所对应的资源文件，根据配置文件中的rules属性找到对应资源的加载器，把资源加载器加载的结果放到打包生成的文件中。loader是webpack的核心
15.webpack 开发一个loader
我们考虑一个需求：markdown-loader，也就是markdown文件加载器，用这个加载器直接在代码中导入markdown文件。
一点点来，首先了解一下loader的输入输出
<pre>
//main.js
import about from './about.md'
console.log(about)
//markdown-loader.js
module.exports = source => { //参数就是我们所加载到的资源文件的内容
    console.log(source)
    return 'hello ~' //输出，就是加工过后的结果
}
//webpack.config.js
{
    test: /\.md$/,
    use: './markdown-loader' // 这里可以用相对路径
}
</pre>
执行webpack命令后得到结果
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/15_1.png">
可以看到，我的md文件的中文已经打印到控制台了，但是为什么还报错呢？因为webpack要求loader最后的输出必须是JavaScript代码，但是我们返回的是字符串
我们稍微作一些修改
<pre>
//main.js
import about from './about.md'
console.log(about)
//markdown-loader.js
module.exports = source => { 
    console.log(source)
    return 'console.log("hello ~")'
}
//webpack.config.js
{
    test: /\.md$/,
    use: './markdown-loader' 
}
</pre>
再次打包就可以看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/15_2.png">
webpack把我们打包的结果直接拼接了，所以如果不返回js代码，语法就可能不通过。先安装一个md文件解析器 npm i marked --save-dev 
<pre>
const marked = require('marked')
module.exports = source => {
    const html = marked(source) //marked直接返回的是html
    return `module.exports = ${JSON.stringify(html)}`
}
</pre>
或者
<pre>
const marked = require('marked')
module.exports = source => {
    const html = marked(source)
    return `export default ${JSON.stringify(html)}`//改了这行，支持ES Modules导出
}
</pre>
也可以就是返回html，再安装一个html-loader去处理
<pre>
//markdown-loader.js
const marked = require('marked')
module.exports = source => {
    const html = marked(source)
    return html
}
//webpack.config.js
{
    test: /\.md$/,
    use: ['html-loader', ./markdown-loader' ]
}
</pre>
16.webpack插件机制介绍
插件机制是为了增强webpack自动化的能力。loader专注实现各种资源模块的加载，plugin解决除了资源加载以外其他自动化工作，例如自动清除打包前的dist目录等
17.webpack 自动清除输出目录插件
npm i webpack-clean-plugin
<pre>
//webpack.config.js
const {CleanwWbpackPlugin} = require('clean-webpack-plugin')
module.exports = {
    plugins:[
        new CleanwWbpackPlugin()
    ]
}
</pre>
18.webpack 自动生成HTML插件(上)
通过webpack生成HTML能省去我们自己手动改变HTML文件中打包路径等问题。安装html-webpack-plugin插件
<pre>
const HtmlWebpackPlugin = require('html-webpack-plugin');
plugins:[
    new HtmlWebpackPlugin()
]
</pre>
在这里，因为之前课程配置的loader我都没有修改，导致报错，因为和babel-loader产生了冲突，解决方案就是
<pre>
{
    test: /.js$/,
    use: {
        loader: 'babel-loader',
        options: {
            presets: ['@babel/preset-env'] 
        }
    },
        exclude: /node_modules/ //就是这一行，因为提示的报错里有与babel-loader冲突的意思
},
</pre>
另外上面配置打包成功之后我们发现生成的index.html中的bundle.js路径还是dist/bundle.js，实际应该是当前目录下bundle.js。这是因为在webpack.config.js中配置了publicPath: 'dist/'，注释掉即可
19.webpack 自动生成HTML插件(中)
指定html模版和模版中的一些内容
<pre>
// src/index.html
< div class="container" >
        < h1 ><%= htmlwebpackplugin.options.title="" %="">< /h1 >
< /div >
//webpack.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin');
plugins:[
    new HtmlWebpackPlugin({
        title:'webpack sample',
        meta:{
            viewport:'width=device-width'
        },
        template:'./src/index.html'
    })
]
</%=></pre>
20.webpack 自动生成HTML插件(下)
同时输出多个页面文件
<pre>
plugins:[
    new HtmlWebpackPlugin({
        title:'webpack sample',
        meta:{
            viewport:'width=device-width'
        },
        template:'./src/index.html'
    }),
    new HtmlWebpackPlugin({
        filename:'about.html',
    })
]
</pre>
21.webpack 插件使用总结
对于项目中不需要参与构建的文件(例如favicon.ico)一般放在public文件夹中，使用 copy-webpack-plugin 处理
其实我这里遇到了问题
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/21_1.png">
当前我电脑webpack版本4.6.0，copy-webpack-plugin 版本6.0.3 ，查到的这个问题产生的原因给的解释都是由于webpack版本和copy-webpack-plugin不匹配产生的问题，也就是要么升级webpack版本要么降低copy-webpack-plugin版本，但是由为了不给我现在工作中的项目造成困扰(我工作中的项目在node 11 情况下安装的依赖，切换到node14就不能正常工作)先不对webpack本地版本进行修改，此处留坑，先赶进度
22.webpack 开发一个插件
相比loader，plugin拥有更宽的能力范围。plugin通过钩子机制实现，webpack留了很多钩子，具体可以查看官方文档。webpack要求插件必须是函数或者包含apply方法的对象
<pre>
//webpack.config.js
class MyPlugin{
    apply(compiler){ //会在webpack启动时自动被调用
        // compiler就是webpack工作中最核心的一个对象，包含了此次构建对象的所有配置信息
        // 我们也是通过这个对象去注册钩子函数
        // 我们的需求是用这个插件清除webpack打包中生成的注释信息
        // API官网找到emit钩子，在webpack往输出目录输出文件时执行
        console.log('MyPlugin')
        compiler.hooks.emit.tap('MyPlugin', compilation => {
            // compilation 可以理解成我们此次打包过程中的上下文
            // 我们所有打包过程中产生的结果都会放到 compilation 对象中
            // assets 获取即将写入的目录中的资源文件信息 
            for(const name in compilation.assets){
                console.log(name)
            }
        })
    }
}
</pre>
然后在plugins中加入MyPlugin插件
<pre>
new MyPlugin()
</pre>
执行打包命令可以看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/22_1.png">
在打包一开始，我们的文件名都被输出了。稍作修改
<pre>
class MyPlugin{
    apply(compiler){ 
        console.log('MyPlugin')
        compiler.hooks.emit.tap('MyPlugin', compilation => {
            for(const name in compilation.assets){
                console.log(compilation.assets[name].source())
            }
        })
    }
}
</pre>
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/22_2.png">
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/22_3.png">
打包文件的内容和html等相关文件等内容被输出了，我们截取了部分展示在这里。下面是我们这次自己写的全部plugin的内容
<pre>
class MyPlugin{
    apply(compiler){ 
        console.log('MyPlugin')
        compiler.hooks.emit.tap('MyPlugin', compilation => {
            for(const name in compilation.assets){
                if (name.endsWith('.js')) {
                    const content = compilation.assets[name].source()
                    const widthoutComments = content.replace(/\/\*\*+\*\//g,'')
                    compilation.assets[name] = {
                        source: () => widthoutComments,
                        size: () => widthoutComments.length // webpack内部要求的必须的方法
                    }
                }
            }
        })
    }
}
</pre>
再次执行打包命令，bundle.js 的注释就被去掉了。通过这个过程我们了解了插件是通过在生命周期的钩子函数中挂载函数扩展实现的。
23.webpack开发体验问题
理想状态：
·通过http-server去预览
·自动编译+自动刷新
·提供source map 支持
对于以上需求，webpack已经有功能实现了，我们一起了解，增强开发体验
24.webpack自动编译
用watch监听变化，然后重新打包，具体用法就是在启动webpack命令的时候，加入watch参数，即 webpack --watch
25.webpack自动刷新浏览器
在全局安装Browsersync，一边监听一边Browsersync刷新浏览器，但是这样一边不断写入磁盘，一边从磁盘读取，开销略大
26.webpack dev server
提供用于开发的http server ，集成自动编译和自动刷新浏览器等功能。不会每次都生成打包的dist目录，把打包结果缓存到内存中。安装之后直接执行webpack dev server 命令即可，还可以webpack dev server --open ，自动打开浏览器，具体见 https://webpack.docschina.org/guides/development/#choosing-a-development-tool
27.webpack dev server 静态资源访问
只要是webpack打包并输出的文件都可以正常被访问到，但是如果一些静态资源也想被访问到serve，就需要额外告诉webpack，方法就是在配置文件中添加对应配置。虽然之前讲过copy-webpack-plugin 可以复制资源到打包文件目录，但是开发阶段使用这个插件效率较低
28.webpack dev server 代理API
webpack dev server 支持配置代理。
目标：将github API 代理到开发服务器
github的其中一个接口https://api.github.com/users
<pre>
devServer: { //开发阶段
    contentBase: './public',
    proxy: {
        '/api': {//需要被代理的请求路径的前缀
            // https://localhost:8080/api/users -> https://api.github.com/api/users
            target: 'https://api.github.com/',
            pathRewrite: { // 实现代理路径的重写，会以正则替换的方式请求路径
                '^/api': '' //把以 /api 开头的代理为 ''
            },
            // 默认使用发起请求端的主机名，服务器会根据主机名判断这个请求属于哪一个网站，把请求指派到对应网站
            // 这里用changeOrigin为true ，使用实际代理请求主机名去发起请求
            changeOrigin: true 
        }
    }
},
</pre>
29.source map 介绍
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/29_1.png">
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/29_2.png">
简单看一下jquery的map文件
version：当前文件所使用的source-map的版本
sources：转换之前源文件的名称，因为有可能是多个文件合并，所以这里是一个数组
names：源代码当中的成员名称。转换之前的变量名(转换的时候通常把有意义的变量名转换为单个字母等用以压缩代码体积)，这里记录的是原始名称
mappings：核心属性，是一个base64-vlq编码的字符串，记录转换之后代码字符与转换之前的对应关系
source map 解决了源代码与运行代码不一致所产生的问题
在source map文件结尾添加一行 //# sourceMappingURL=jquery-3.4.1.min.map 开启服务在浏览器查看的时候，会引入转换之前的文件 
30.webpack 配置 source map
webpack也可以配置source map，由于模式比较多，导致初学者比较懵。
<pre>
devtool: 'source-map'
</pre>
在webpack.config.js中加入上面一行代码，执行webpack命令，可以看到在生成bundle.js的同时也生成了bundle.js.map文件，并且bundle.js文件末尾有 //# sourceMappingURL=bundle.js.map 也就是指向source-map文件
webpack支持12种不同方式，每种方式的效果和效率各不相同
31.webpack eval模式的source map
下面是几种不同source-map模式从四种角度出发的对比
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/31_1.png">
在eval模式下，将每个模块转换过后的代码都放在eval函数中去执行，并且在eval函数执行的字符串最后，通过sourceURL的方式去说明所对应的文件路径，这样浏览器在执行这段代码的时候就知道这段代码所对应的源文件，但是也只能到源文件的程度，并不知道在文件中的具体位置。在这种模式下并不会生成source-map文件。
32.webpack devtool 模式对比(上)
在webpack的配置对象可以是一个数组，每一个数组都是一个单独的打包模式，这样就可以在一次打包过程中执行多个打包任务
<pre>
module.exports = [
{
    entry: './src/main.js',
    output: {
        filename: 'a.js'
    }
},
{
    entry: './src/main.js',
    output: {
        filename: 'b.js'
    }
}
]
</pre>
执行打包命令，就会有两个子任务同时进行，同时生成两个打包结果。
这样我们就可以把devtool的模式组成一个数组，遍历这个数组，生成多个不同的子任务，最后生成打包结果，这样就可以比较每种打包模式的特点
<pre>
const HtmlWebpackPlugin = requrie('html-webpack-plugin')
const allModes = [
'eval',
'cheap-eval-source-map',
'cheap-module-eval-source-map',
'eval-source-map',
'cheap-source-map',
'cheap-module-source-map',
'inline-cheap-module-source-map',
'source-map',
'inline-source-map',
'hidden-source-map',
'nosources-source-map'
]
module.exports = allModes.map(item => {
    return {
        devtool: item,
        mode: 'none',
        entry: './src/main.js',
        output: {
            filename: `js/${item}.js`
        },
        module: {
            rules: [
                test: /\.js$/,
                use: {
                    loader:'bable-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            ]
        },
        plugins: [
            new HtmlWebpackPlugin({
                filename: `${item}.html`
            })
        ]
    }
})
</pre>
执行webpack打包命令之后，就会生成相应的js文件，由于我们把生成的文件都放在js目录下，会比较直观的看到不同结果打包模式的页面
33.webpack devtool 模式对比(下)
eval:只能定位到文件
cheap-eval-source-map:可以定位到文件的行，生成source-map文件，文件被babel等加工过后的结果
cheap-module-eval-source-map:文件没有被babel等加工的结果
eval-source-map:可以定位到文件的行和列，生成source-map文件
cheap-source-map:
cheap-module-source-map:
inline-cheap-module-source-map:
source-map:
inline-source-map:把source-map文件以dataURL嵌入到代码中
hidden-source-map:看不到source-map
nosources-source-map:提供了行列信息，能看到错误位置，但是点击错误看不到源代码，这是为了保护源代码。
34.webpack 选择source map 模式
在开发环境下可选:
cheap-module-eval-source-map——1.老师编写代码每行不会超过80个字符2.代码经过loader转换过后的差异较大3.首次打包速度慢无所谓，重写打包相对较快
生产模式:none——1.source-map会暴露源代码2.调试是开发阶段的事
选择没有绝对，理解不同模式差异，适配不同环境
35.webpack自动刷新的问题
webpack-dev-server 提供对开发者友好的开发服务器。但是每次都是刷新页面。如何在页面不刷新的前提下，模块也可以及时更新。
36.webpack HMR 体验
Hot Module Replacement 模块热替换，在应用运行过程中实时替换某个模块，应用状态不受影响
37.webpack 开启 HMR
HMR已经集成在webpack-dev-server当中，不需要单独安装，在运行webpack-dev-server --hot 通过hot参数启动hmr
<pre>
const webpack = require('webpack')
devServer: {
    hot: true 
},
plugins: [
new webpack.HotModuleReplacementPlugin()
]
</pre>
经过上面的配置，只需直接执行webpack-dev-server，无需再添加参数。但是这里我们发现，只有样式文件实现了热更新，修改js文件页面还是刷新了
38.webpack HMR疑问
webpack的HMR并不可以开箱即用，也就是说HMR还需要一些额外的操作才可以使用。样式文件可以开箱即用是因为loader(这里可以说是style-loader)帮我们做了处理。而对于js文件非常复杂，所以没有统一规律可循，所以没有统一的HMR，但是在框架下(比如vue react)相当于有了规则，就比较容易做到热更新了。通用脚手架创建的项目内部都集成了HMR方案。
总结：我们需要手动处理JS模块更新后的热替换。
39.webpack 使用 HMR API
由于main.js是入口，所有模块都是从这里导入/更新，所以在这处理热替换
<pre>
// accept用于我们某一个模块更新过后的处理函数
// 参数依次是 依赖模块的路径，依赖更新过后的处理函数
module.hot.accept('./editor', () => {
    console.log('editor模块更新了，需要手动处理热替换逻辑')
})
</pre>
由于这我们手动处理了editor的刷新，就不会再自动触发刷新，否则会触发自动刷新。
40.webpack处理js模块热替换
<pre>
// editor.js
export default () => {
    const editorElement = document.createElement('div')
    editorElement.contentEditable = true
    editorElement.id = 'editor' //添加了一行
    console.log('editor init completed')
    return editorElement
}
// main.js
import createEditor from './editor'
const editor = createEditor()
document.body.appendChild(editor)
let lastEditor = editor
module.hot.accept('./editor', () => {
    const value = lastEditor.innerHTML //保存上次元素中的内容
    document.body.appendChild(lastEditor)
    const newEditor = createEditor()
    newEditor.innerHTML = value // 模块热更新后将元素内容放回到模块中
    document.body.appendChild(newEditor)
    lastEditor = newEditor
})
</pre>
以上仅仅是div元素简单内容的热替换，但是如果元素更多更复杂，那么替换的方式就更不能确定，所以webpack无法提供一个通用的替换方式
41.webpack处理图片模块热替换
<pre>
module.hot.accept('./better.png', () => {
    img.src = background //background就是更新过后的路径
})
</pre>
这里简单介绍了HMR相关的，具体要不要使用要看开发者的需要，但是一般对于需要持续维护的项目，很多时候利大于弊。
42.webpack HMR 注意事项
·处理HMR的代码报错会导致自动刷新
我们代码手误写错了，依旧自动刷新导致我们不能正确发现错误
<pre>
devServer: {
    hotOnly: true // 换一种方式
}
</pre>
·没启用HMR的情况下，HMR API 报错
没有在plugin中开启new webpack.HotModuleReplacementPlugin()
<pre>
if(mdoule.hot){ //判断是否存在
    module.hot.accept('./better.png', () => {
        img.src = background 
    })
}
</pre>
·代码中多了一些与业务无关的代码
不会影响生产环境的状态
43.webpack生产环境优化
上面我们引入越来越多的代码，虽然产生了更好的开发体验，但是也会造成代码的臃肿。webpack为了实现这些特性，会自动往打包结果中添加一些额外的内容，但是这些额外的代码对生产环境来讲，是冗余的，因为生产环境和开发环境有很大差异。生产环境注重运行效率，开发环境只注重开发效率。所以webpack4出现了mode模式的用法，为不同模式设置了一些预设的配置，同时webpack推荐为不同的环境创建不同的配置
44.webpack不同环境下的配置
·配置文件根据环境不同导出不同的配置
·一个环境对应一个配置文件
<pre>
const path = require('path')
const webpack = require('webpack')
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');
module.exports = (env, argv) => { //env是通过cli传递的环境参数，argv是运行cli过程中接收到的所有参数
    const config = {
        // 配置
        mode: 'development',
        entry: './src/main.js',
        output: {
            filename: 'bundle.js',
            path: path.join(__dirname, 'dist'),
        },
        devServer: {
            hot: true 
        },
        devtool: 'source-map',
        module: {
            rules: [
                {
                    test: /.js$/,
                    use: {
                        loader: 'babel-loader',
                        options: {
                            presets: ['@babel/preset-env'] 
                        }
                    },
                       exclude: /node_modules/
                },
                {
                    test: /\.css$/,//正则表达式，匹配打包过程中的文件路径
                    use: [
                    'style-loader',
                    'css-loader'
                    ]//匹配所需要的loader
                    //注意，如果配置了多个loader，那么是从后往前执行的
                },
                {
                    test: /.png$/,
                    use: {
                        loader: 'url-loader',
                        options: {
                            limit: 10 * 1024 //10kb
                        }
                    }
                },
                {
                    test: /\.md$/,
                    use: './markdown-loader' // 这里可以用相对路径
                }
            ]
        },
        plugins:[
            new CleanWebpackPlugin(),
            new HtmlWebpackPlugin({
                title:'webpack sample',
                meta:{
                    viewport:'width=device-width'
                },
                template:'./src/index.html'
            }),
            new webpack.HotModuleReplacementPlugin()
        ]
    }
    if (env === 'production') {
        config.mode = 'production'
        config.devtool = false
        config.plugins = [
            ...config.plugins,
            new CleanWebpackPlugin(),
            //new CopyWebpackPlugin({patterns: [ //这里我自己的文件打包是有问题的
            //        { from: './public', to: 'dist' }
            //    ]
            //})
        ]
    }
    return config
}
</pre>
45.webpack不同环境的配置文件
上面通过不同环境名参数配置不同对象只适用于中小型项目，因为随着项目的变大，配置文件也变得复杂起来。对于大型项目建议使用不同环境对应不同配置文件的方式来实现。一般这种情况会有三个不同文件，一个生产环境、一个开发环境、一个公共文件。对于不同环境的配置文件的合并，建议用webpack-merge
46.webpack DefinePlugin
webpack4新增的production模式下面内部开启了很多通用的优化功能，对于使用者而言非常方便，但是对于学习者就导致我们忽略很多需要了解的东西。我们先从DefinePlugin了解开始
DefinePlugin为代码注入全局成员，在production模式下默认启用，并且往代码中注入了process.env.NODE_ENV
<pre>
//webpack.config.js
const webpack = require('webpack')
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    plugins: [
        new webpack.DefinePlugin({
            // 参数是一个对象，对象中每个键值都会被注入到代码中
            API_BASE_URL: 'https://www.example.com',//定义了API_BASE_URL，为我们代码注入API服务地址
        })
    ]
}
//main.js
console.log(API_BASE_URL)
</pre>
执行webpack打包命令之后可以看到如下结果
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/46_1.png">
看到definePlugin就是直接把我们定义的值注入了代码当中，我们设置的值的内容就是https://www.example.com 这个字符串，字符串中并没有包含引号，所以替换进来是没有引号的，语法上就有问题
<pre>
//webpack.config.js
const webpack = require('webpack')
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    plugins: [
        new webpack.DefinePlugin({
            // 键我们自己定义了，值其实要求是js代码片段，所以https://www.example.com字符串需要加引号
            API_BASE_URL: '"https://www.example.com"',
        })
    ]
}
</pre>
再次打包之后，就可以看到我们想要的结果。这里还有一个小技巧
<pre>
API_BASE_URL: JSON.stringify('https://www.example.com'),
</pre>
这个代码可以为我们注入一些可能会发生变化的值
47.webpack体验Tree Shaking
"摇"掉代码中未引用的部分，也就是"摇掉"未引用代码(dead code)
<pre>
// components.js
export const Button = () => {
    return document.createElement('button');
    console.log('dead-code')
}
export const Link = () => {
    return document.createElement('a');
}
export const Heading = level => {
    return document.createElement('h'+level);
    console.log('dead-code')
}
// main.js
import {Button} from './components'
document.body.appendChild(Button())
</pre>
这里我们在main.js只引用了components.js中的Button，另外的link和heading都没有被引用，执行打包命令之后看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/47_1.png">
未被引用的link和heading代码都没有被输出，这就是tree-shaking的效果，并且tree-shaking会自动在生产模式开启
48.webpack使用Tree Shaking
Tree Shaking不是一个配置选项，是一组功能搭配使用后的优化效果，会在production模式下自动启用。还是我们上节课的例子，我们直接在none模式下打包，可以在打包结果中看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/48_1.png">
不管我们在别的地方是否用到了，components.js中所有组件都被打包到bundle.js中。我们修改一下webpack.config.js
<pre>
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    optimization:{  //在这里集中配置webpack的优化功能
        usedExports: true, //只导出在外部使用的成员
    }
}
</pre>
再次打包
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/48_2.png">
可以看到在main.js没有被引用的Link、Heading组件的变化，就没有被打包了。再加一个压缩功能
<pre>
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    optimization:{  //在这里集中配置webpack的优化功能
        usedExports: true, //只导出在外部使用的成员，负责标记未被使用到的代码
        minimize: true, // 代码压缩，负责去掉未被使用的代码
    }
}
</pre>
再次打包之后，bundle.js中未被引用的代码就都被移除掉了
49.webpack合并模块
除了上节课讲的，我们还可以用concatenateModules来继续优化输出。普通打包结果将每一个模块放到一个单独的函数当中，如果模块很多，输出结果中会有很多模块函数
<pre>
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    optimization:{ 
        usedExports: true,
        concatenateModules: true,
        // minimize: true, // 为了更好的看到结果，这里先注释掉
    }
}
</pre>
concatenateModules的作用是尽可能将所有模块合并到一个输出函数中。 既提升了运行效率，又减少了代码体积。这个特性又被称之为scope hoisting，也就是作用域提升
50.webpack tree shaking与babel
tree shaking 的实现前提就是使用ES Modules，由webpack打包的代码必须使用ESM。webpak在打包之前先是将模块根据不同的配置交给loader去处理，最后将所有loader处理的结果打包到一起。为了转换打包代使用的ES6+的新特性，很多时候需要使用babel-loader，而babel会将ESmodules转换为commonJS，当然这取决于我们有没有使用转换ESModules的插件，例如@babel/preset-env就会将ESModules -> commonJS ，所以这时候tree-shaking就不能生效。这里我们在webpack.config.js中仅开启usedExports: true ，但是打包之后发现tree shaking并没有失效，未被使用的代码并没有被打包进来，这是因为最新的babel-loader中自动帮我们关闭了ESMoudules-commonJS。可以在@babel/preset-env中强制开启esmodules 转commonjs 尝试下
<pre>
module: {
    rules: [
        {
            test: /.js$/,
            use: {
                loader: 'babel-loader',
                options: {
                    presets: [
                        ['@babel/preset-env', {modules: 'commonjs'}]
                    ] 
                }
            },
            exclude: /node_modules/
        }
    ]
}
</pre>
打包之后发现tree-shaking确实失效了，如果想确保tree-shaking不失效，那么
<pre>
presets: [
    ['@babel/preset-env', {modules: false}]
]
</pre>
51.webpack sideEffects
sideEffects 允许我们通过配置的方式标识代码是否有副作用——模块执行时除了导出成员之外所做的事情。sideEffects一般用于npm包标记是否有副作用。在配置的时候，要先在webpack.config.js中设置sideEffects: true开启这个功能，在package.json中配置sideEffects标识代码没有副作用
<pre>
//webpack.config.js
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    optimization:{ 
        usideEffects: true,
    }
}
//package.json
{
    "name": "sideEffects",
    "version": "0.1.0",
    ...
    "sideEffects": false
}
</pre>
52.webpack sideEffects 注意
使用sideEffects的前提就是确定你的代码真的没有副作用，对于一些css模块等都会被看作是副作用，或者原型链添加一些方法等，都会被移除掉。如果不想这些代码被移除。解决办法就是在package.json中关掉副作用，或者标识一下哪些文件有副作用
<pre>
//package.json
{
    "name": "sideEffects",
    "version": "0.1.0",
    ...
    "sideEffects": [
        './src/extend.js',
        '*.css'
    ]
}
</pre>
53.webpack代码分割
webpack将所有代码打包到一起，打包结果bundle体积过大。在实际项目中，并不是所有模块在启动时都是必要的，那么就有一个按需加载的需求。代码分割可以通过多入口的打包方式或者通过动态导入的方式
54.webpack多入口打包
多入口打包一般适用于传统的多页应用程序，最常见的话的规则就是一个页面对应一个打包入口，公共部分单独提取，项目具体就不在这里写了，简单的两个页面，然后在main.js中引入、处理。下面主要写一下webpack.config.js的配置
<pre>
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
    mode: 'none',
    entry: { //注意这里只有写成对象才能打包成多个文件，写成数组只会打包成一个文件
        './src/index.js',
        './src/album.js'
    },
    output: {
        filename: '[name].bundle.js',
        path: path.join(__dirname, 'dist')
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                'style-loader',
                'css-loader'
                ]
            }
        ]
    },
    plugins:[
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'multi entry 1',
            template:'./src/index.html',
            filename: 'index.html'
        }),
        new HtmlWebpackPlugin({
            title:'multi entry 2',
            template:'./src/album.html',
            filename: 'album.html'
        })
    ]
}
</pre>
上面的配置能完成然后执行打包命令，就能在输出文件夹中看到两个打包结果，但是我们会发现，两个打包结果被同时被引入输出的html文件
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/54_1.png">
所以需要对webpack.config.js进行简单的修改
<pre>
plugins:[
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
        title:'multi entry 1',
        template:'./src/index.html',
        filename: 'index.html',
        chunk: ['index']
    }),
    new HtmlWebpackPlugin({
        title:'multi entry 2',
        template:'./src/album.html',
        filename: 'album.html',
        chunk: ['album']
    })
]
</pre>
55.webpack提取公共模块
<pre>
optimization:{ 
    splitChunks: {
        chunks: 'all'
    }
}
</pre>
56.webpack 动态导入
webpack支持动态导入的方式实现按需加载，动态导入的模块会被自动分包。
我们需要注释掉页面一开始就import 模块，而在需要使用模块的地方再执行import
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/56_1.png">
打包结果会有两个动态导入的模块和提取的公共代码
57.webpack 魔法注释
默认通过动态导入产生的bundle文件只是一个序号，如果需要命名，就通过webpack的魔法注释去实现
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/57_1.png">
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/57_2.png">
如果使用了相同的chunkname，那么相同chunkname的模块就会被打包到一起
58.webpack MiniCssExtractPlugin
MiniCssExtractPlugin可以提取css到单个文件，首先安装，然后在webpack.config.js中引入，再注册到plugin中
<pre>
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                //由于使用了MiniCssExtractPlugin，css被单独存放于文件中
                //不需要style标签，而是直接通过link引入，所以不再需要style-loader
                //'style-loader',
                //通过MiniCssExtractPlugin提供的loader去用link引入样式
                MiniCssExtractPlugin.loader,
                'css-loader'
                ]
            }
        ]
    },
    plugins:[
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'multi entry 1',
            template:'./src/index.html',
            filename: 'index.html',
            chunk: ['index']
        }),
        new HtmlWebpackPlugin({
            title:'multi entry 2',
            template:'./src/album.html',
            filename: 'album.html',
            chunk: ['album']
        }),
        new MiniCssExtractPlugin()
    ]
}
</pre>
如果css文件很小，比如小于150kb，那么直接嵌入代码中减少一次请求更好，大于一定值通过link标签加载引入才有价值
59.webpack OptimizeCssAssetsWebpackPlugin
webpack对于生产模式的打包，仅支持js文件的压缩，剩下的压缩都需要额外的插件支持。OptimizeCssAssetsWebpackPlugin压缩输出的css文件
<pre>
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                MiniCssExtractPlugin.loader,
                'css-loader'
                ]
            }
        ]
    },
    plugins:[
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'multi entry 1',
            template:'./src/index.html',
            filename: 'index.html',
            chunk: ['index']
        }),
        new HtmlWebpackPlugin({
            title:'multi entry 2',
            template:'./src/album.html',
            filename: 'album.html',
            chunk: ['album']
        }),
        new MiniCssExtractPlugin(),
        new OptimizeCssAssetsWebpackPlugin()
    ]
}
</pre>
上面我们直接把OptimizeCssAssetsWebpackPlugin放到了plugin中，但是webpack官方的建议是放到optimization.minimizer中，是因为可以通过minimizer统一控制，在生产模式minimizer自动开启
<pre>
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                MiniCssExtractPlugin.loader,
                'css-loader'
                ]
            }
        ]
    },
    optimization: {
        minimizer: [
            new OptimizeCssAssetsWebpackPlugin()
        ]
    },
    plugins:[
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'multi entry 1',
            template:'./src/index.html',
            filename: 'index.html',
            chunk: ['index']
        }),
        new HtmlWebpackPlugin({
            title:'multi entry 2',
            template:'./src/album.html',
            filename: 'album.html',
            chunk: ['album']
        }),
        new MiniCssExtractPlugin()
    ]
}
</pre>
但是这样配置，minimizer认为我们要自定义所使用的插件，没有要求js压缩，内置的js压缩器就会被覆盖掉，所以js文件不会自动被压缩
<pre>
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
const TerserWebpackPlugin = require('terser-webpack-plugin')
module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                MiniCssExtractPlugin.loader,
                'css-loader'
                ]
            }
        ]
    },
    optimization: {
        minimizer: [
            new TerserWebpackPlugin(), //webpack内置js压缩plugin
            new OptimizeCssAssetsWebpackPlugin()
        ]
    },
    plugins:[
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'multi entry 1',
            template:'./src/index.html',
            filename: 'index.html',
            chunk: ['index']
        }),
        new HtmlWebpackPlugin({
            title:'multi entry 2',
            template:'./src/album.html',
            filename: 'album.html',
            chunk: ['album']
        }),
        new MiniCssExtractPlugin()
    ]
}
</pre>
60.webpack输出文件名hash
服务器在部署前端文件的时候，都会启用静态资源缓存，这样对于用户浏览器就能缓存静态资源，后续就不用请求这些资源，提升了响应速度。但是开启了缓存，如果设定缓存时间过长，更新不及时；如果设定时间过短，效果不明显。所以建议在生产模式下，给文件名增加hash值，一旦资源文件发生改变，文件名也发生了变化。对于客户端，全新的文件名就是全新的请求，可以把缓存的时间设置的非常长。
项目级的hash，一旦项目中有任何改动，项目中的hash就会跟着一起改动
<pre>
//本节课的代码重点放在哪里可以带hash，至于文件目录级别是否在一起，并没有特意匹配
output: {
    filename: '[name]-[hash].bundle.js'
}
new MiniCssExtractPlugin({
    filename: '[name]-[hash].bundle.css'
})
</pre>
chunkhash在打包过程中，只要是同一路(比如一个文件的css/js是同一路的)的打包，chunkhash都是相同的
<pre>
output: {
    filename: '[name]-[chunkhash].bundle.js'
}
new MiniCssExtractPlugin({
    filename: '[name]-[chunkhash].bundle.css'
})
</pre>
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/60_1.png">
可以看到同一路的hash名是一致的
contenthash，文件级别的hash，根据输出文件的内容输出的hash，也就是不同的文件就有不同的hash
<pre>
output: {
    filename: '[name]-[contenthash].bundle.js'
}
new MiniCssExtractPlugin({
    filename: '[name]-[contenthash].bundle.css'
})
</pre>
另外，如果觉得默认的20位长度的hash太长，还可以指定hash长度
<pre>
output: {
    filename: '[name]-[contenthash:8].bundle.js'
}
new MiniCssExtractPlugin({
    filename: '[name]-[contenthash:8].bundle.css'
})
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/17/拉勾-Webpack打包/" data-id="ckeeij3d80067joxqty7py4ch" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-模块化开发" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/15/拉勾-模块化开发/" class="article-date">
  <time datetime="2020-07-15T04:16:48.000Z" itemprop="datePublished">2020-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/15/拉勾-模块化开发/">拉勾-模块化开发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.模块化概述<br>内容概要<br>·模块化演变过程<br>·模块化规范<br>·常用的模块化打包工具<br>·基于模块化工具构建现代web应用<br>·打包工具的优化技巧<br>2.模块化演变过程<br>stage-1.文件划分方式<br>每个文件一个功能，通过script标签引入，容易形成全局变量等，早起模块化完全依靠约定<br>stage-2.命名空间方式<br>约定每一个模块暴露一个全局对象，所有模块成员挂载到全局对象上。将每个模块包裹成一个全局对象的方式<br>stage-3.IIFE<br>前两种方式都没有实现私有成员，IIFE的实现方式就是<br><img src="https://snakexu.github.io/images/lagou/part_2/modular/2_1.png"><br>并且可以清楚的看到引用依赖(可以作为参数传入)<br>以上是早起在没有工具和规范的情况下，对模块化的落地方式<br>3.模块化规范的出现<br>虽然有了模块化的雏形，但是还有很多问题，我们依然通过script标签引入，这样就很容易在加载大量文件的时候出现各种问题，比如少引入文件等。这时发现我们需要模块化标准+模块化加载器。<br>在nodejs中模块化标准为commontjs规范，在这个规范中约定<br>·一个文件就是一个模块<br>·每个模块都有单独的作用域<br>·通过module.exports导出成员<br>·通过require函数载入模块<br>commonJs是以同步方式加载模块，这种加载方式在node是没什么问题的，但是前端如果采用同步加载，容易产生很多问题，所以为浏览器端制定了A(Asynchronous)M(Module)D(Definitino)规范，同期推出Require.目前绝大多数第三方库都支持AMD规范。AMD使用起来相对复杂，模块js文件请求频繁。此外还有淘宝团队的sea.js+CMD等<br>4.模块化标准规范<br>目前浏览器统一使用ESModules实现模块化规范，nodeJs使用CommonJs实现模块化规范。但是要注意，ESModules是ECMAScript2015也就是俗称的ES6才被定义的标准，会产生兼容问题，目前一部分浏览器已经兼容了，但是随着webpack等工具的出现，这一规范已经比较普及了。<br>5.ES Modules特性<br>可以从两个维度学习<br>(1)作为一个标准/规范，约定了哪些特性和语法<br>(2)如果通过一些工具/方案解决运行环境中兼容性带来的问题<br>通过给script标签添加type=module的属性就可以以ES Module的标准执行其中的JS代码了</p>
<pre>
< script type="module" >
    console.log('this is es module')
< /script >
< script type="module" >
    var foo = 100;
    console.log(foo)//可以正常打印
< /script >
< script type="module" >
    console.log(foo) //报错
< /script >
</pre>
上面的代码可以正常在浏览器中执行了，但是对于普通js会有一些不同:
(1)ESM 自动采用严格模式，忽略'use strict'(比如在严格模式下不能全局使用this)
(2)每个ESMdoules都是运行在单独的私有作用域中
(3)ESModules是通过CORS方式请求外部  如果js模块不在同源地址下，就需要请求的服务端地址在响应的响应头必须提供有效的CORS标头
(4)ESM的script标签会延迟执行脚本    
6.ES Modules导出
导入:import，导出:export
<pre>
export const name = "xiaoming"
export function hello (){
    console.log('hello')
}
export class Person{}
//or
const name = "xiaoming"
function hello (){
    console.log('hello')
}
class Person{}
export {name, person, hello}
//or 重命名方式
export{
    name as fullName,
    hello as fullHello
}
</pre>
要注意，导出的成员如果定义名称为default，那么这个成员就会作为当前模块默认的导出成员，导入这个成员的时候，就必须给这个成员命名，default是一个关键词，我们不能把它当作变量使用。也可以export default name，在导入时候直接import一个变量名的方式默认导入一个成员
7.ES Modules导入导出的注意事项
<pre>
export { name, age } //不同于字面量，这里只是export的语法
export default { name, age } //这里是对象字面量的范围 export default 可以跟一个变量，也可以跟一个值
</pre>
同样，import 导入的时候，也不是解构，只是一个import的用法
export导出成员的时候导出的是对这个成员的一个引用
<pre>
//module.js
var name = 'jack'
var age = 18
export { name, age }
setTimeout(function(){
    name = 'ben'
},1000)
//app.js
import { name, age } from './module.js'
console.log(name, age) //jack 18
setTimeout(function(){
    console.log(name, age) //age 18
},1500)
</pre>
但是暴露出来的关系是只读的，也就是说不能在模块外部修改成员
<pre>
//module.js
var name = 'jack'
var age = 18
export { name, age }
setTimeout(function(){
    name = 'ben'
},1000)
//app.js
import { name, age } from './module.js'
console.log(name, age) //jack 18
name = 'tom' //报错，因为暴露出来的关系是只读的
setTimeout(function(){
    console.log(name, age)
},1500)
</pre>
8.ES Modules导入用法
原生的import引入文件的时候
(1)不能简写扩展名，比如引入module.js，必须写成 import { name } from './module.js'，不能写成import { name } from './module'
(2)如果引入的是index.js，也不能省略index.js，比如 import {lowercase} from './utils/index.js' 不能写成 import {lowercase} from './utils'
(3)支持文件路径方式 './' '/' 'http://'，也就是说支持相对路径、绝对路径引入
(4)import {} from  './module.js' 是执行模块，不需要提取模块中的成员，简写语法 import './module.js'
(5)import * as mod from './modules'导入模块中所有被导出成员，被放入mod对象中，每一个导出成员都是mod对象的一个属性
(6)需要动态导入模块(就是路径不确定的情况)，不能 import {name} from 变量 。es module 提供了一个全局的函数 import 用来动态导入模块。用法 import(需要导入模块的路径)，这里的import返回一个promise
<img src="https://snakexu.github.io/images/lagou/part_2/modular/8_1.png">
(7)如果在同一个模块中导出了一些命名成员和一个默认成员，可以正常导入命名成员，再用default as 重命名 的方式导入默认成员，或者用逗号分隔，逗号左边是默认成员，右边是命名成员
<pre>
import {name, age, default as title } from './module.js'
import title, {name, age } from './module.js' //用逗号分隔方式引入默认成员，title为默认成员的别名
</pre>
9.ES Modules导入导出成员
直接把导入成员作为当前模块的导出成员，那么在当前作用域中不能访问这些成员，一般用来写index文件，导出成员给外部使用
<pre>
export {foo, bar} from './module.js'
console.log(foo,bar)
</pre>
10.ES Modules 浏览器环境Polyfill
我们可以通过ES Module Loader 去解决浏览器不支持es语法的问题，可以在unpkg.com提供的cdn服务来拿到js文件。ES Module Loader的用法可以看相关介绍，另外由于在最新IE中不支持promise，我们需要引入一个promise的polyfill。如果我们正常在html页面中引入上面提到的polyfill会导致支持esmodule的浏览器执行两遍代码，一遍是浏览器执行的，另外一遍是polyfill执行的，可以用script的nomodule的属性，这个属性只有在不支持esmodule语法的情况下才执行
<pre>
< script type="nomodule" >
alert('123')//只有在不支持esmodule语法的浏览器才会弹出123(IE说，别看我，我不支持我也没办法)
< /script >
但是nomodule属性在运行的时候是动态解析脚本，效率会比较差，不适宜在生产阶段使用
</pre>
11.ES Modules in Node.js 支持情况
node的8.5以上版本已经以实验的特性开始支持ES Module的语法了。要在node环境中使用ES Module，首先要把扩展名的js改为mjs，然后在命令行当前目录下输入node --experimental-modules index.mjs (这里index.mjs为文件名) ，node会提示这是实验特性，不要在生产环境使用
第三方模块都是导出默认成员，不能 import {toLowerCase} from 'lodash'，但是node官方模块因为做了兼容，可以这么使用 
12.ES Modules in Node.js 与commonjs模块交互
<pre>
//按ES Module标准编写的es-module.mjs
import mod from './commonjs.js'
console.log(mod)
//按commonjs标准编写的commonjs.js
module.exports = {
    foo: 'commonjs exports value'
}
</pre>
然后在命令行执行 node --experimental-modules es-module.mjs ，可以看到在命令行中输出 { foo: 'commonjs exports value'} (之前会提示ExperimentalWarning: The ESM module loader is experimental) 。这说明我们可以在ES Module中载入CommonJs的成员。也可以写成
<pre>
//按ES Module标准编写的es-module.mjs
import mod from './commonjs.js'
console.log(mod)
//按commonjs标准编写的commonjs.js
exports.foo = 'commonjs exports value'
</pre>
要注意，在ESModules中引入commonJs标准的成员，commonJs始终只会导出一个默认成员，也就是说如果按照下面的方式是执行，命令行是会报错的
<pre>
//按ES Module标准编写的es-module.mjs
//注意，不能直接提取成员，注意import不是解构导出对象
import {mod} from './commonjs.js'
console.log(mod)
//按commonjs标准编写的commonjs.js
exports.foo = 'commonjs exports value'
</pre>
上面我们用ESModule载入了CommonJs，如果我们用CommonJs载入ESModule呢？try 一下
<pre>
//按ES Module标准编写的es-module.mjs
export const foo = 'es module export value'
//按commonjs标准编写的commonjs.js
const mod = require('./es-module.mjs')
console.log(mod)
</pre>
在命令行中执行 node --experimental-modules commonjs.js ，会报错。可以得出不能在CommonJs模块中通过require载入ESModule
以上都是在node原生环境中执行的，如果用webpack打包工具等，执行结果可能会不一样
结论：
·ES Modules 中可以导入 CommonJs 模块
·CommonJs 中不能导入 ES Modules 模块
·CommonJs 始终只会导出一个默认成员
·注意import不是解构导出对象
13.ES Modules in Node.js 与commonjs模块的差异
<pre>
//cjs.js CommonJs 标准写的 
//单独执行node --experimental-modules cjs.js 是可以执行的
//加载模块函数
console.log(require)
//模块对象
console.log(module)
//导出对象别名
console.log(exports)
//当前文件的绝对路径
console.log(__filename)
//当前文件所在目录
console.log(__dirname)
//esm.mjs ES Modules标准写的
//执行 node --experimental-modules esm.mjs 会报错
console.log(require)
console.log(module)
console.log(exports)
console.log(__filename)
console.log(__dirname)
</pre>
可以看出ESM中没有CommonJs中的那些模块的全局成员了
ESModules中有一个fileURLToPath方法，我们可以通过这个方法去获取文件路径
<pre>
import {fileURLToPath} from 'url'
import {dirname} from 'path'
const __filename = fileURLToPath{import.meata.url}
console.log(__filename)
const __dirname = dirname(__filename)
console.log(__dirname)
</pre>
<img src="https://snakexu.github.io/images/lagou/part_2/modular/13_1.png">
14.ES Modules in Node.js 新版本进一步支持ESM
先把node切换到12.10.0的版本，并且确定没有任何问题，打开项目中的package.json文件，写入
<pre>
{
    "type":"module"
}
</pre>
然后把我们改成.mjs扩展名的文件改会.js扩展名，执行node --experimental-modules index.js 是可以执行的。但是如果我们执行commonjs的文件，需要把扩展名改为.cjs
15.ES Modules in Node.js Babel兼容方案
早日的nodejs版本，我们可以用Babel去实现ESModules的兼容，因为是低版本node，所以我们切换node版本为8.0.0，yarn add @babel/node @babel/core @babel/preset-env --dev，然后就可以通过yarn babel-node去运行这个命令，但是直接运行这个命令会报错，因为babel的preset-env是预设高版本js的转换，所以执行命令的正确姿势是yarn babel-node index.js --presets=@babel/preset-env，如果觉得每次都加入presets比较麻烦，可以在文件中添加.babelrc文件，然后在文件中写入
<pre>
{
    "presets": ["@babel/preset-env"]
}
</pre>
然后就可以直接通过yarn babel-node index.js运行了
或者也可以通过一个单独的插件yarn add @babel/plugin-transform-modules-commonjs --dev，然后修改.babelrc文件
<pre>
{
    "plugins": ["@babel/plugin-transform-modules-commonjs"]
}
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/15/拉勾-模块化开发/" data-id="ckeeij34g004mjoxqhtuw0lj4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-自动化构建" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/08/拉勾-自动化构建/" class="article-date">
  <time datetime="2020-07-07T19:48:07.000Z" itemprop="datePublished">2020-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/08/拉勾-自动化构建/">拉勾-自动化构建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.自动化构建简介(一切重复工作本应自动化)<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/1_1.png"><br>上图中的自动化构建是在自动化构建工作流，作用是运行环境兼容带来的问题，使用提高效率的语法、规范和标准。例如ECMAScript Next、scss、模版引擎等这些好用的工具都不能直接在浏览器中使用，自动化构建工具就可以派上用场了，可以把这些不被支持的代码特性转换为可支持的代码，提高编码效率<br>2.自动化构建初体验<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/2_1.png"><br>从上面的直接编写css代码到下图用scss编写再构建成普通css<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/2_2.png"><br>我们可以按照上面两张图来先创建一个项目，用css编写，再删除css文件，编写scss文件，安装sass模块(yarn add scss –dev)，安装完成后，在node_modules文件夹里就能看到.bin目录，这样我们就可以用sass编译我们刚刚写到scss文件了，在命令行中输入.\node_modules\.bin\sass，执行完这个命令就会看到这条命令的用法，即.\node_modules\.bin\sass 输入路径 输出路径，执行这条命令之后，就可以看到编译过后的scss文件-&gt;css文件，并且文件中还帮我们做了sourcemap。但是如果在开发过程中我们经常这样输入命令，就显得有些麻烦，而且别人也可能不知道你的项目有哪些命令，怎么用这些命令，那么NPM Scripts 就是用来解决这些问题的，在package.json文件中添加如下</p>
<p><pre><br>“scripts”: {<br>    “build”: “sass scss/main.scss css/style.css”<br>},<br></pre><br>scripts 可以自动发现node_modules文件夹中的执行命令，我们不用再写完整路径，然后就可以通过npm/yarn启动这个命令。这里我们再安装一个browser-sync的模块来启动测试服务器运行我们的项目，添加启动服务器的命令</p>
<p><pre><br>“scripts”: {<br>    “build”: “sass scss/main.scss css/style.css”,<br>    “serve”: “browser-sync .”//认真的说这条才是启动服务器的命令<br>},<br></pre><br>这时执行yarn serve命令就可以启动服务打开浏览器，但是我们可以添加preserve命令帮我们先执行build命令，这样更加简化项目执行</p>
<p><pre><br>“scripts”: {<br>    “build”: “sass scss/main.scss css/style.css –watch”,//–watch监听文件的变化，一旦发生变化就自动编译<br>    “preserve”:”yarn build”,//自动在serve执行之前执行<br>    “serve”: “browser-sync .”//认真的说这条才是启动服务器的命令<br>},<br></pre><br>当我们加了–watch之后再启动就发现，sass就阻塞在了监听的地方，去等待文件发生变化，此时我们需要借助npm-run-all去同时执行多个任务，yarn add npm-run-all –dev 安装这个模块</p>
<p><pre><br>“scripts”: {<br>    “build”: “sass scss/main.scss css/style.css –watch”,<br>    “serve”: “browser-sync .”,<br>    “start”: “run-p build serve”//通过run-p去同时执行build和serve，源于安装了npm-run-all<br>},<br></pre><br>再次升级</p>
<p><pre><br>“scripts”: {<br>    “build”: “sass scss/main.scss css/style.css –watch”,<br>    “serve”: “browser-sync . –files \”css/*\””,//–files参数让browser-sync去监听项目文件下的一些变化，一旦文件发生变化，自动同步到浏览器<br>    “start”: “run-p build serve”<br>},<br></pre><br>3.常用的自动化构建工具<br>目前市面上使用最多的自动化构建工具是grunt/gulp/fis等<br>grunt:出现最早，插件生态非常完善，由于工作过程是基于临时文件去实现的(磁盘读写)，所以构建速度比较慢<br>gulp:基于内存，构建速度相对较快，默认支持同时执行多个任务，插件生态比较完善<br>fis:百度内部使用，后来开源，把项目中典型的需求基本都集成在内部<br>4.grunt的基本使用<br>初始化一个项目，安装grunt，添加gruntfile.js文件，这个文件是grunt的入口文件，用于去定义需要grunt自动执行的任务，需要导出一个函数，此函数接收一个grunt的形参，内部提供一些创建任务时可以用到的API</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.registerTask(‘foo’,()=&gt;{//参数 任务名字，任务函数-&gt;任务发生时自动执行的函数<br>        console.log(‘hello grunt’)<br>    })<br>    grunt.registerTask(‘foo’,任务描述(出现在帮助信息中),()=&gt;{<br>        console.log(‘other task’)<br>    })<br>    // grunt.registerTask(‘default’,()=&gt;{//如果注册名字为default，那么将成为grunt的默认任务<br>        // console.log(‘default task’)<br>    // })<br>    grunt.registerTask(‘default’,[‘foo’,’bar’])//一般用default去映射一些其他任务，这里把foo和bar任务串联到了一起<br>    // 这里grunt默认支持同步模式，如果想使用异步操作，要用到this.async得到一个回调函数，在异步操作完成后调用这个回调函数标识一下这个任务已经完成<br>    // grunt.registerTask(‘async-task’,()=&gt;{<br>        // setTimeout(()=&gt;{<br>            // console.log(‘async task working’)<br>        // },1000)<br>    // })<br>    grunt.registerTask(‘async-task’,function (){<br>        const done = this.async()<br>        setTimeout(()=&gt;{<br>            console.log(‘async task working’)<br>            done()//标识一下这个任务已经完成了<br>        },1000)<br>    })<br>}<br></pre><br>然后运行yarn grunt foo 运行foo任务，可以运行grunt –help 去得到帮助信息。<br>5.grunt标记任务失败</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.registerTask(‘bad’,()=&gt;{<br>        console.log(‘bad working’)<br>        return false //构建任务失败的标记<br>        //如果当前任务在任务列表中，当前任务执行失败，那么列表中后续任务都不会再实现<br>    })<br>    grunt.registerTask(‘foo’,()=&gt;{<br>        console.log(‘foo task’)<br>    })<br>    grunt.registerTask(‘bar’,()=&gt;{<br>        console.log(‘bar task’)<br>    })<br>    grunt.registerTask(‘default’,[‘foo’,’bad’,’bar’])//bad执行失败了，bar就不会运行<br>}<br></pre><br>正常执行yarn grunt default 命令，上面的bar任务是不会执行的，但是命令行也提示我们，如果执行yarn grunt default –force，bar任务是可以执行的<br>标记异步任务执行失败</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.registerTask(‘bad-async’,function (){<br>        const done = this.async()<br>        setTimeout(()=&gt;{<br>            console.log(‘bad async’)<br>            done(false)<br>        },1000)<br>    })<br>}<br></pre><br>6.grunt的配置方法</p>
<p><pre><br>module.exports = grunt =&gt; {<br>  // grunt.initConfig() 用于为任务添加一些配置选项<br>  grunt.initConfig({<br>    // 键一般对应任务的名称<br>    // 值可以是任意类型的数据<br>    foo: {<br>      bar: ‘baz’<br>    }<br>  })<br>  grunt.registerTask(‘foo’, () =&gt; {<br>    // 任务中可以使用 grunt.config() 获取配置<br>    console.log(grunt.config(‘foo’))<br>    // 如果属性值是对象的话，config 中可以使用点的方式定位对象中属性的值<br>    console.log(grunt.config(‘foo.bar’))<br>  })<br>}<br></pre><br>7.grunt多目标任务<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_1.png"></p>
<p><pre><br>module.exports = grunt =&gt; {<br>    // 多目标模式，可以让任务根据配置形成多个子任务<br>    grunt.initConfig({//配置多任务的目标<br>      build: {//必须是一个对象<br>          css:’1’,//每一个属性的名称就是我们的目标名称<br>          js: ‘2’<br>        }<br>    })<br>    grunt.registerMultiTask(‘build’, function () {<br>        console.log(<code>build task</code>)<br>    })<br>}<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_2.png"><br>通过yarn grunt build:css 可以只运行指定目标</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        build: {<br>            css:’1’,<br>            js: ‘2’<br>        }<br>    })<br>    grunt.registerMultiTask(‘build’, function () {<br>       console.log(<code>task: build, target: ${this.target}, data: ${this.data}</code>)<br>    })<br>}<br></pre><br>重新用yarn grunt build:css 命令执行上面代码，可以得到<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_3.png"><br>在initConfig每一个被指定的属性都会成为一个目标，除了options</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        build: {<br>            options:{<br>                foo:’bar’,<br>            },<br>            css:’1’,<br>            js: ‘2’<br>        }<br>    })<br>    grunt.registerMultiTask(‘build’, function () {<br>       console.log(<code>task: build, target: ${this.target}, data: ${this.data}</code>)<br>    })<br>}<br></pre><br>再次执行yarn grunt build 命令<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_4.png"><br>可以看到并没有一个target叫options，这个options可以作为一个配置选项出现</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        build: {<br>            options:{<br>                foo:’bar’,<br>            },<br>            css:’1’,<br>            js: ‘2’<br>        }<br>    })<br>    grunt.registerMultiTask(‘build’, function () {<br>        console.log(this.options())<br>        console.log(<code>task: build, target: ${this.target}, data: ${this.data}</code>)<br>    })<br>}<br></pre><br>执行结果如下<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_5.png"></p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        build: {<br>            options:{<br>                foo:’bar’,<br>            },<br>            css:{<br>                options: {<br>                    foo: ‘baz’<br>                }<br>            },<br>            js: ‘2’<br>        }<br>    })<br>    grunt.registerMultiTask(‘build’, function () {<br>        console.log(this.options())<br>        console.log(<code>task: build, target: ${this.target}, data: ${this.data}</code>)<br>    })<br>}<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_6.png"><br>8.Grunt插件的使用<br>插件机制是grunt的核心<br>使用一个插件的大体过程就是首先使用npm安装插件，再到gruntfile中载入这个插件提供的一些任务，最后根据这些插件的文档完成相关的配置选项。这里我们用grunt-contrib-clean来演示，这个插件用来清除项目当中产生的一些临时文件<br>首先安装 yarn add grunt-contrib-clean</p>
<p><pre><br>module.exports = grunt =&gt; {<br>  grunt.loadNpmTasks(‘grunt-contrib-clean’)<br>}<br></pre><br>运行yarn grunt clean，控制台会打印错误信息:clean任务没有配置对应目标，我们需要initConfig去配置不同的目标</p>
<p><pre><br>module.exports = grunt =&gt; {<br>  grunt.initConfig({<br>    clean: {<br>      temp: ‘temp/*<em>‘ //temp/app.js temp/</em>.txt 等都是支持的<br>    }<br>  })<br>  grunt.loadNpmTasks(‘grunt-contrib-clean’)<br>}<br></pre><br>9.Grunt常用插件及总结<br>9-1.grunt-sass<br>grunt官方也提供了一个sass插件，但是这个模块需要本机安装sass环境，使用起来不是很方便。grunt-sass是一个npm的模块，在内部是通过npm的形式去依赖sass，grunt-sass需要一个sass模块的支持，这里我们用grunt官方提供的sass模块，yarn add grunt-sass sass –dev</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        sass: {<br>              main: {<br>                  files: {<br>                      ‘dist/css/main.css’ : ‘src/scss/main.scss’<br>                  }<br>              }<br>        },<br>    })<br>    grunt.loadNpmTasks(‘grunt-sass’)<br>}<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_2/automation/9_1.png"><br>implementation是用来指定在grunt-sass中用哪一个模块去处理sass的编译</p>
<p><pre><br>const sass = require(‘sass’)<br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        sass: {<br>            options: {<br>                sourceMap: true,<br>                implementation: sass //更多选项可以去grunt-sass官方文档查看<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/css/main.css’ : ‘src/scss/main.scss’<br>                  }<br>              }<br>        },<br>    })<br>    grunt.loadNpmTasks(‘grunt-sass’)<br>}<br></pre><br>9-2.grunt-babel<br>安装 yarn add grunt-babel @babel-core @babel/preset-env –dev ，安装之后又需要 loadNpmTasks 去加载任务，随着安装的插件越来越多，社区中有一个模块可以减少loadNpmTasks的使用。同样也需要我们安装一下 yarn add load-grunt-tasks –dev </p>
<p><pre><br>const sass = require(‘sass’)<br>const loadGruntTasks = require(‘load-grunt-tasks’)<br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        sass: {<br>            options: {<br>                sourceMap: true,<br>                implementation: sass //更多选项可以去grunt-sass官方文档查看<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/css/main.css’ : ‘src/scss/main.scss’<br>                  }<br>              }<br>        },<br>        babel: {<br>            options: {<br>                sourceMap: true,<br>                presets: [‘@babel/preset-env’]<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/js/app.js’ : ‘src/js/app.js’<br>                  }<br>              }<br>        },<br>    })<br>    // grunt.loadNpmTasks(‘grunt-sass’)<br>    loadGruntTasks(grunt) // 自动加载grunt所有的插件任务<br>}<br></pre><br>9-3.grunt-contrib-watch<br>文件修改完之后自动编译，安装 yarn add grunt-contrib-watch –dev </p>
<p><pre><br>const sass = require(‘sass’)<br>const loadGruntTasks = reuqire(‘load-grunt-tasks’)<br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        sass: {<br>            options: {<br>                sourceMap: true,<br>                implementation: sass //更多选项可以去grunt-sass官方文档查看<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/css/main.css’ : ‘src/scss/main.scss’<br>                  }<br>              }<br>        },<br>        babel: {<br>            options: {<br>                sourceMap: true,<br>                presets: [‘@babel/preset-env’]<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/js/app.js’ : ‘src/js/app.js’<br>                  }<br>              }<br>        },<br>        watch: {<br>            js: {<br>                files: [‘src/js/<em>.js’],<br>                tasks: [‘babel’]<br>            },<br>            js: {<br>                files: [‘src/scss/</em>.scss’],<br>                tasks: [‘sass’]<br>            },<br>        }<br>    })<br>    // grunt.loadNpmTasks(‘grunt-sass’)<br>    loadGruntTasks(grunt) // 自动加载grunt所有的插件任务<br>}<br></pre><br>由于watch只会在文件发生改变的时候才执行，所以我们增加default任务，保证启动之前先执行一次css、js任务</p>
<p><pre><br>const sass = require(‘sass’)<br>const loadGruntTasks = reuqire(‘load-grunt-tasks’)<br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        sass: {<br>            options: {<br>                sourceMap: true,<br>                implementation: sass //更多选项可以去grunt-sass官方文档查看<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/css/main.css’ : ‘src/scss/main.scss’<br>                  }<br>              }<br>        },<br>        babel: {<br>            options: {<br>                sourceMap: true,<br>                presets: [‘@babel/preset-env’]<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/js/app.js’ : ‘src/js/app.js’<br>                  }<br>              }<br>        },<br>        watch: {<br>            js: {<br>                files: [‘src/js/<em>.js’],<br>                tasks: [‘babel’]<br>            },<br>            js: {<br>                files: [‘src/scss/</em>.scss’],<br>                tasks: [‘sass’]<br>            },<br>        }<br>    })<br>    // grunt.loadNpmTasks(‘grunt-sass’)<br>    loadGruntTasks(grunt) // 自动加载grunt所有的插件任务<br>    grunt.registerTasks(‘default’,[‘css’,’js’,’watch’])<br>}<br></pre><br>10.Gulp的基本使用<br> Gulp作为当下最流行的构建系统，其核心特点就是高效、易用。使用gulp的过程非常简单，大体来说就是现在项目中安装一个gulp的开发依赖，然后在项目的根目录，也就是package.json所在目录去添加gulpfile.js用于去编写一些构建任务<br> <img src="https://snakexu.github.io/images/lagou/part_2/automation/10_1.png"><br>报错是因为最新gulp取消了同步代码模式，约定每个任务都必须是个异步任务<br>纠正上面的问题</p>
<p><pre><br>exports.foo = done =&gt; {<br>  console.log(‘foo task working~’)<br>  done() // 标识任务执行完成<br>}<br>// default 是默认任务<br>// 在运行是可以省略任务名参数<br>exports.default = done =&gt; {<br>  console.log(‘default task working~’)<br>  done()<br>}<br></pre><br>在gulp4.0以前我们去注册gulp任务是要通过gulp模块中的一个方法去实现</p>
<p><pre><br>// v4.0 之前需要通过 gulp.task() 方法注册任务<br>const gulp = require(‘gulp’)<br>gulp.task(‘bar’, done =&gt; {<br>  console.log(‘bar task working~’)<br>  done()<br>})<br></pre><br>11.Gulp的组合任务<br> <pre><br>const { series, parallel } = require(‘gulp’)<br>const task1 = done =&gt; {<br>  setTimeout(() =&gt; {<br>    console.log(‘task1 working~’)<br>    done()<br>  }, 1000)<br>}<br>const task2 = done =&gt; {<br>  setTimeout(() =&gt; {<br>    console.log(‘task2 working~’)<br>    done()<br>  }, 1000)<br>}<br>const task3 = done =&gt; {<br>  setTimeout(() =&gt; {<br>    console.log(‘task3 working~’)<br>    done()<br>  }, 1000)<br>}<br>// 让多个任务按照顺序依次执行<br>exports.foo = series(task1, task2, task3)<br>// 让多个任务同时执行<br>exports.bar = parallel(task1, task2, task3)<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_2/automation/11_1.png"><br>12.Gulp的异步任务<br>Gulp中的任务都是异步任务，异步任务在被调用的时候是无法明确是否完成的，都是在函数内部通过函数回调/事件方式通知外部完成。在gulp中也有这个问题，也有很多解决方式。我们想到的解决方式一，也是通过回调的方式去解决</p>
<p><pre><br>exports.callback = done =&gt; {<br>  console.log(‘callback task’)<br>  done()<br>}<br>exports.callback_error = done =&gt; {<br>  console.log(‘callback task’)<br>  done(new Error(‘task failed’))// 如果发生错误，错误优先<br>}<br></pre><br>方案二，通过promise</p>
<p><pre><br>exports.promise = () =&gt; {<br>  console.log(‘promise task’)<br>  return Promise.resolve() //resolve中不要写东西，gulp会忽略这些东西<br>}<br>exports.promise_error = () =&gt; {<br>  console.log(‘promise task’)<br>  return Promise.reject(new Error(‘task failed’))//如果遇到失败任务，gulp同样会不再执行后面的所有任务<br>}<br></pre><br>方案三，async/await</p>
<p><pre><br>const timeout = time =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(resolve, time)<br>  })<br>}<br>exports.async = async () =&gt; {<br>  await timeout(1000)<br>  console.log(‘async task’)<br>}<br></pre><br>方案四，stream</p>
<p><pre><br>const fs = require(‘fs’)<br>exports.stream = () =&gt; {<br>  const read = fs.createReadStream(‘yarn.lock’)<br>  const write = fs.createWriteStream(‘a.txt’)<br>  read.pipe(write)<br>  return read<br>}<br></pre><br>stream都有end事件，任务完成会触发stream的end事件，从而gulp知道任务完成，简单模拟一下就是</p>
<p><pre><br>exports.stream = done =&gt; {<br>  const read = fs.createReadStream(‘yarn.lock’)<br>  const write = fs.createWriteStream(‘a.txt’)<br>  read.pipe(write)<br>  read.on(‘end’, () =&gt; {<br>    done()<br>  })<br>}<br></pre><br>13.Gulp构建过程核心工作原理<br>我们一个普通文件的处理过程大致如下<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/13_1.png"><br>通过对node底层API去模拟实现这样一个过程</p>
<p><pre><br>const fs = require(‘fs’)<br>const { Transform } = require(‘stream’)<br>exports.default = () =&gt; {<br>  // 文件读取流<br>  const readStream = fs.createReadStream(‘normalize.css’)<br>  // 文件写入流<br>  const writeStream = fs.createWriteStream(‘normalize.min.css’)<br>  // 文件转换流<br>  const transformStream = new Transform({<br>    // 核心转换过程<br>    transform: (chunk, encoding, callback) =&gt; {<br>      const input = chunk.toString()<br>      //替换掉代码中的css注释<br>      const output = input.replace(/\s+/g, ‘’).replace(/\/*.+?*\//g, ‘’)<br>      callback(null, output)<br>    }<br>  })<br>  return readStream<br>    .pipe(transformStream) // 转换<br>    .pipe(writeStream) // 写入<br>}</pre></p>
<p><br>14.Gulp文件操作API<br>创建构建任务的流程：通过src方法去创建一个读取流，再借助插件实现的转换方法来实现文件的加工，再通过gulp提供的dest方法去创建一个写入流</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const cleanCSS = require(‘gulp-clean-css’)//压缩css代码<br>const rename = require(‘gulp-rename’)<br>exports.default = () =&gt; {<br>  return src(‘src/*.css’)<br>    .pipe(cleanCSS())<br>    .pipe(rename({ extname: ‘.min.css’ }))//指定重命名的扩展名<br>    .pipe(dest(‘dist’))<br>}<br></pre><br>15.Gulp案例-样式编译<br>首先准备一个需要自动化构建的项目<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/15_1.png"><br>上面项目目录中public是不需要加工可以直接打包的内容；src放开发阶段代码，这个目录下所有内容都会被构建，里面包含js、scss代码、项目图片(打包的时候压缩删除一些不必要的图片信息)。首先安装gulp，然后创建gulpfile.js文件</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/*.scss’)<br>    .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style<br>}<br></pre><br>执行yarn gulp style ，可以看到多出了dist目录，但是我们看到dist目录下的文件不能按照我们src目录输出，丢失了原来的目录结构，我们可以</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/*.scss’, { base: ‘src’ })// base保存了目录的基准结构<br>    .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style<br>}<br></pre><br>这里我们还没有加文件转换，我们安装 yarn add gulp-sass –dev ，安装开发依赖</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const sass = require(‘gulp-sass’)<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/*.scss’, { base: ‘src’ })<br>    .pipe(sass())<br>    .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style<br>}<br></pre><br>再执行yarn gulp style 会看到有main.css 。顺便，这里之前生成的文件不会被清空，因为我们没有安装相关插件，后续会安装，这里先手动清空一下吧。还有就是我们看到只生成了一个main.css，和我们项目里原来有三个scss相关的文件不同，这里是因为我们之前有三个.scss文件，但是其中两个是以下划线开头命名的，gulp默认下划线开头的是内部依赖文件，会被忽略掉。另外处理后盛出的css会把右半边花括号放到代码旁边，我们需要指定一下才能改成平时我们习惯的新的一行</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const sass = require(‘gulp-sass’)<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/*.scss’, { base: ‘src’ })<br>    .pipe(sass({outputStyle:’expanded’}))<br>    .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style<br>}<br></pre><br>16.Gulp案例-脚本编译<br>在上一节，我们完成了样式编译，现在来编译脚本</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const sass = require(‘gulp-sass’)<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/<em>.scss’, { base: ‘src’ })<br>    .pipe(sass({outputStyle:’expanded’}))<br>    .pipe(dest(‘dist’))<br>}<br>const script = () =&gt; {<br>    return src(‘src/assets/scripts/</em>.js’, { base: ‘src’ })<br>      .pipe(babel())<br>      .pipe(dest(‘dist’))<br>}<br>module.exports = { //这里采用这种导出方式只是因为暂时需要，后面会升级导出方法<br>  style,<br>  script<br>}<br></pre><br>安装 yarn add gulp-babel –dev 这个开发依赖，执行 yarn gulp script ，会发现报错<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/16_1.png"><br>因为这里babel只是帮忙唤醒babel-core模块的转换过程，并没有自动安装核心转换模块，我们要自己手动安装 yarn add @babel/core @babel/preset-env –dev </p>
<p><pre><br>//因为这一节内容是脚本编译，这里先不写样式编译的内容了<br>const { src, dest } = require(‘gulp’)<br>const script = () =&gt; {<br>    return src(‘src/assets/scripts/*.js’, { base: ‘src’ })<br>      .pipe(babel({preset:[‘@babel/preset-env’]}))<br>      .pipe(dest(‘dist’))<br>}<br>module.exports = { //这里采用这种导出方式只是因为暂时需要，后面会升级导出方法<br>  style,<br>  script<br>}<br></pre><br>重新运行 yarn gulp script ，就OK了。如果忘了写 {preset:[‘@babel/preset-env’]} ，可能会造成转换没有效果的感觉<br>17.Gulp案例-页面模版编译<br>页面模版也就是html，这里为了把能重用的部分抽离出来，用了模版引擎swig，首先又是熟悉的安装环节 yarn add gulp-swig –dev </p>
<p><pre><br>const swig = require(‘gulp-swig’)<br>//和上面编译脚本/样式都是在gulpfile.js文件中，这里只抽离写了页面模版相关的<br>const page = () =&gt; {<br>    return src(‘src/*<em>/</em>.html’, { base: ‘src’ })//src文件夹下的任意文件夹下的html文件<br>      .pipe(swig())<br>      .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style,<br>  script,<br>  page<br>}<br></pre><br>我们原来的模版用到了一些数据标记，如下图<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/17_1.png"><br>即原来网站中可能发生变化的地方提取成一些数据，这里我们也模拟准备了一些数据</p>
<p><pre><br>const swig = require(‘gulp-swig’)<br>const data = {<br>  menus: [<br>    {<br>      name: ‘Home’,<br>      icon: ‘aperture’,<br>      link: ‘index.html’<br>    },<br>    {<br>      name: ‘Features’,<br>      link: ‘features.html’<br>    },<br>    {<br>      name: ‘About’,<br>      link: ‘about.html’<br>    },<br>    {<br>      name: ‘Contact’,<br>      link: ‘#’,<br>      children: [<br>        {<br>          name: ‘Twitter’,<br>          link: ‘<a href="https://twitter.com/w_zce&#39;" target="_blank" rel="noopener">https://twitter.com/w_zce&#39;</a><br>        },<br>        {<br>          name: ‘About’,<br>          link: ‘<a href="https://weibo.com/zceme&#39;" target="_blank" rel="noopener">https://weibo.com/zceme&#39;</a><br>        },<br>        {<br>          name: ‘divider’<br>        },<br>        {<br>          name: ‘About’,<br>          link: ‘<a href="https://github.com/zce&#39;" target="_blank" rel="noopener">https://github.com/zce&#39;</a><br>        }<br>      ]<br>    }<br>  ],<br>  pkg: require(‘./package.json’),<br>  date: new Date()<br>}<br>const page = () =&gt; {<br>    return src(‘src/*<em>/</em>.html’, { base: ‘src’ })//src文件夹下的任意文件夹下的html文件<br>      .pipe(swig( {data:data} ))//等价于 .pipe(swig( {data} ))<br>      .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style,<br>  script,<br>  page<br>}<br></pre><br>再执行yarn gulp page 命令，我们可以看到，我们的数据被插入到了页面模版中<br>但是项目中我们不可能为脚本、页面、样式单独执行任务，所以我们要创建一个组合任务</p>
<p><pre><br>////三个任务之间没有什么关联，可以同时执行，所以用parallel<br>const { src, dest, parallel } = require(‘gulp’)<br>const compile = parallel(style,script,page)<br>module.exports = {<br>  compile<br>}<br></pre><br>18.Gulp案例-图片和字体文件转换<br>只写了代码，如果有啥特别的地方再说吧，因为大致流程和上面编译别的文件差不多，安装的插件 yarn add gulp-imagemin –dev</p>
<p><pre><br>const imagemin = require(‘gulp-imagemin’)<br>const image = () =&gt; {<br>  return src(‘src/assets/images/<strong>‘, { base: ‘src’ })<br>    .pipe(imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>//字体文件同理，不再过多讲了<br>const font = () =&gt; {<br>  return src(‘src/assets/fonts/</strong>‘, { base: ‘src’ })<br>    .pipe(imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>const compile = parallel(style,script,page,image,font)<br></pre><br>19.Gulp案例-其他文件及文件清除<br>src下的文件都已经处理完了，再去把public中的文件做一个拷贝</p>
<p><pre><br>const extra = () =&gt; {<br>    return src(‘public/**’, { base: ‘public’ })<br>      .pipe(dest(‘dist’))<br>}<br>//这里没有把任务添加到compile是因为compile是处理src目录下的，容易产生混淆<br>const build = parallel(compile,extra)<br>module.exports = {<br>    build<br>}<br></pre><br>我们安装一个清除插件，清除每次执行yarn gulp XX 的结果(也就是清理dist目录下的文件)，虽然这个插件不属于gulp，但是可以在gulp中使用 yarn add del –dev</p>
<p><pre><br>//引入series，因为clean任务要先于别的任务执行，如果同时执行就可能出现已经生成的文件被删除的情况<br>const { src, dest, parallel, series } = require(‘gulp’)<br>const del = require(‘del’)//del返回的是一个promise<br>const clean = () =&gt; {<br>    return del([‘dist’])<br>}<br>const build =  series(clean,parallel(compile,extra))<br></pre><br>20.Gulp案例-自动加载插件<br>随着项目越来越复杂，如果每次都是这样手动引入插件，require操作会非常多，不利于代码的维护，我们可以通过一个插件解决这个小问题，安装这个插件 yarn add gulp-load-plugins –dev</p>
<p><pre><br>const loadPlugins = require(‘gulp-load-plugins’)//导出的是一个方法<br>//plugins是一个对象，所有插件都会成为这个对象上的一个属性<br>const plugins = loadPlugins()<br>//插件的gulp都会被去掉，剩下的按照驼峰命名，比如gulp-sass-ss变成sassSs<br>//把我们之前所有插件重命名<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/<em>.scss’, { base: ‘src’ })<br>      //用plugins重命名sass，之前引入sass的require(‘gulp-sass’)的定义可以删掉<br>    .pipe(plugins.sass({ outputStyle: ‘expanded’ }))<br>    .pipe(dest(‘dist’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const script = () =&gt; {<br>  return src(‘src/assets/scripts/</em>.js’, { base: ‘src’ })<br>      //用plugins重命名babel，之前引入babel的require(‘gulp-babel’)的定义可以删掉<br>    .pipe(plugins.babel({ presets: [‘@babel/preset-env’] }))<br>    .pipe(dest(‘dist’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const page = () =&gt; {<br>  return src(‘src/*.html’, { base: ‘src’ })<br>      //用swig重命名swig，之前引入swig的require(‘gulp-swig’)的定义可以删掉<br>    .pipe(plugins.swig({ data, defaults: { cache: false } })) // 防止模板缓存导致页面不能及时更新<br>    .pipe(dest(‘dist’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const image = () =&gt; {<br>    //用imagemin重命名imagemin，之前引入imagemin的require(‘gulp-imagemin’)的定义可以删掉<br>  return src(‘src/assets/images/<strong>‘, { base: ‘src’ })<br>    .pipe(plugins.imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>const font = () =&gt; {<br>  return src(‘src/assets/fonts/</strong>‘, { base: ‘src’ })<br>    .pipe(plugins.imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>//还有一些没有需要修改的代码没有写到这里，完整的代码会在后面介绍gulp的最后一节写入<br></pre><br>21.Gulp案例-开发服务器<br>除了对文件的构建意外，我们这里还需要一个开发服务器，用于在开发阶段调试我们的应用，我们可以通过gulp去启动并且管理这个服务器，在后续就可以配合我们的构建任务自动编译并刷新浏览器，可以减少很多重复操作<br>首先，安装插件 yarn add brower-sync –dev </p>
<p><pre><br>const browserSync = require(‘browser-sync’)<br>const bs = browserSync.create()<br>const serve = () =&gt; {<br>    bs.init({<br>        server:{<br>            baseDir:’dist’//指定网站的根目录<br>        }<br>    })<br>}<br></pre><br>运行yarn gulp serve 命令，我们可能看到的网页不是我们想要的，因为css样式等不对，这是因为我们没有处理node_modules目录，也就是构建的代码没有处理路径等问题，这里我们先用一个小的解决办法</p>
<p><pre><br>const browserSync = require(‘browser-sync’)<br>const bs = browserSync.create()<br>const serve = () =&gt; {<br>    bs.init({<br>        notify:false,//关闭是否连接browser-sync提示<br>        port:2080,//改变启动端口<br>        // open:false,//是否在启动时自动打开浏览器<br>        files:’dist/**’,//路径监听启动通配符，监听哪些文件改变后browser-sync更新浏览器<br>        server:{<br>            baseDir:’dist’,<br>            routes:{<br>                ‘/node_modules’:’node_modules’<br>            }<br>        }<br>    })<br>}<br></pre><br>22.Gulp案例-监视变化以及构建优化</p>
<p><pre><br>//watch自动监视文件路径的通配符，根据文件的变化决定是否重新执行某一个任务<br>const { src, dest, parallel, series, watch } = require(‘gulp’)<br>const serve = () =&gt; {<br>    watch(‘src/assets/styles/<em>.scss’, style)<br>    watch(‘src/assets/scripts/</em>.js’, script)<br>    watch(‘src/*.html’, page)<br>    watch(‘src/assets/images/<strong>‘, image)<br>    watch(‘src/assets/fonts/</strong>‘, font)<br>    watch(‘public/<strong>‘, extra)<br>    bs.init({<br>        notify:false,<br>        port:2080,<br>        files:’dist/</strong>‘,<br>        server:{<br>            baseDir:’dist’,<br>            routes:{<br>                ‘/node_modules’:’node_modules’<br>            }<br>        }<br>    })<br>}<br></pre><br>运行 yarn gulp serve 命令，到这里我们尝试修改源代码(src目录下的文件)基本实现了。我们对图片、字体、extra每次都执行构建意义不大(这种文件在上线之前构建一次就OK了)，影响构建效率。所以我们上面watch的image、font、extra都注释掉</p>
<p><pre><br>const serve = () =&gt; {<br>    watch(‘src/assets/styles/<em>.scss’, style)<br>    watch(‘src/assets/scripts/</em>.js’, script)<br>    watch(‘src/*.html’, page)<br>    // watch(‘src/assets/images/<strong>‘, image)<br>    // watch(‘src/assets/fonts/</strong>‘, font)<br>    // watch(‘public/<strong>‘, extra)<br>    watch([<br>        ‘src/assets/images/</strong>‘,<br>        ‘src/assets/fonts/<strong>‘,<br>        ‘public/</strong>‘<br>    ], bs.reload)//文件发生变化之后自动更新，而不是构建<br>    bs.init({<br>        notify:false,<br>        port:2080,<br>        files:’dist/**’,<br>        server:{<br>            //按照数组顺序，从最开始的目录开始找，直到找到文件或者到最后一项都没找到<br>            baseDir:[‘dist’,’src’,’public’] ,<br>            routes:{<br>                ‘/node_modules’:’node_modules’<br>            }<br>        }<br>    })<br>}<br>const compile = parallel(style,script,page)<br>//上线之前build任务<br>const build = series(clean,parallel(compile,image,font,extra))<br>const develop = series(compile,serve)<br>module.exports = {<br>    clean,<br>    compile,<br>    build,<br>    develop<br>}<br></pre><br>23.Gulp案例-useref文件引用处理<br>这里主要就是要处理我们之前发现构建的文件中有node_modules文件夹中的依赖的，因为我们并不会把node_modules文件夹放到线上，首先安装 yarn add gulp-useref –dev</p>
<p><pre><br>const useref = () =&gt; {<br>    return src(‘dist/*.html’,{base:’dist’})<br>      .pipe(plugins.useref({searchPath:[‘dist’,’.’]}))<br>      .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>    clean,<br>    compile,<br>    build,<br>    develop,<br>    useref<br>}<br></pre><br>24.Gulp案例-文件压缩<br>分别压缩HTML、CSS、JavaScript，安装相关插件 yarn add gulp-htmlmin gulp-uglify gulp-clean-css –dev ，之前我们都是对一种文件进行一种操作，现在我们分别要对三种文件进行三种不同的操作，我们需要一个插件来识别 yarn add gulp-if –dev </p>
<p><pre><br>const useref = () =&gt; {<br>  return src(‘dist/*.html’, { base: ‘dist’ })<br>    .pipe(plugins.useref({ searchPath: [‘dist’, ‘.’] }))<br>    // html js css<br>    // if会自动创建一个转换流，会在转换流内部通过if指定的条件去决定是否要去执行具体的转换流<br>    .pipe(plugins.if(/.js$/, plugins.uglify()))<br>    .pipe(plugins.if(/.css$/, plugins.cleanCss()))<br>    .pipe(plugins.if(/.html$/, plugins.htmlmin()))<br>    .pipe(dest(‘dist’))<br>}<br></pre><br>这里执行yarn gulp useref 之前，先要执行 yarn gulp compile ，但是还有一个问题，src()中的是读取流，pipe(dest(‘dist’))是写入流，会产生读写冲突，我们不写入dist目录了，换个目录名试试</p>
<p><pre><br>const useref = () =&gt; {<br>  return src(‘dist/*.html’, { base: ‘dist’ })<br>    .pipe(plugins.useref({ searchPath: [‘dist’, ‘.’] }))<br>    // html js css<br>    // if会自动创建一个转换流，会在转换流内部通过if指定的条件去决定是否要去执行具体的转换流<br>    .pipe(plugins.if(/.js$/, plugins.uglify()))<br>    .pipe(plugins.if(/.css$/, plugins.cleanCss()))<br>    .pipe(plugins.if(/.html$/, plugins.htmlmin({<br>      //默认不是处理所有的空白字符，就是只是删除一些空格，需要指定额外的参数才能去掉所有换行符、空白字符<br>      collapseWhitespace: true,<br>      minifyCSS: true,//压缩html内的css代码<br>      minifyJS: true //压缩html中的js代码<br>    })))<br>    .pipe(dest(‘release’))<br>}<br></pre><br>25.Gulp案例-重新规划构建过程<br>上一节我们为了解决读写冲突，为useref指定了新的生成目录release，显然这样是不行的。我们先为各种类型的文件进行了转换，在上线之前又用useref进行了转换，那么我们之前为html、js、css文件转换直接写入最终要上线的dist目录就有问题了，我们应该先把这些转换结果放入一个临时的文件目录中，然后在useref转换的时候通过临时目录把文件拿出来做转换操作，最后再放入dist目录，这样更合适一些(也就是把处理css/js/html过程中的dest变为temp临时文件夹，clean的时候记得也清除temp目录；把serve中的baseDir的数组中dist改为temp；再把useref中dest(‘release’)，改为dest(‘dist’)，把src的base改为temp，searchPath的dist改为temp)</p>
<p><pre><br>const { src, dest, parallel, series, watch } = require(‘gulp’)<br>const del = require(‘del’)<br>const browserSync = require(‘browser-sync’)<br>const loadPlugins = require(‘gulp-load-plugins’)<br>const plugins = loadPlugins()<br>const bs = browserSync.create()<br>const data = {<br>  menus: [<br>    {<br>      name: ‘Home’,<br>      icon: ‘aperture’,<br>      link: ‘index.html’<br>    },<br>    {<br>      name: ‘Features’,<br>      link: ‘features.html’<br>    },<br>    {<br>      name: ‘About’,<br>      link: ‘about.html’<br>    },<br>    {<br>      name: ‘Contact’,<br>      link: ‘#’,<br>      children: [<br>        {<br>          name: ‘Twitter’,<br>          link: ‘<a href="https://twitter.com/w_zce&#39;" target="_blank" rel="noopener">https://twitter.com/w_zce&#39;</a><br>        },<br>        {<br>          name: ‘About’,<br>          link: ‘<a href="https://weibo.com/zceme&#39;" target="_blank" rel="noopener">https://weibo.com/zceme&#39;</a><br>        },<br>        {<br>          name: ‘divider’<br>        },<br>        {<br>          name: ‘About’,<br>          link: ‘<a href="https://github.com/zce&#39;" target="_blank" rel="noopener">https://github.com/zce&#39;</a><br>        }<br>      ]<br>    }<br>  ],<br>  pkg: require(‘./package.json’),<br>  date: new Date()<br>}<br>const clean = () =&gt; {<br>  return del([‘dist’, ‘temp’])<br>}<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/<em>.scss’, { base: ‘src’ })<br>    .pipe(plugins.sass({ outputStyle: ‘expanded’ }))<br>    .pipe(dest(‘temp’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const script = () =&gt; {<br>  return src(‘src/assets/scripts/</em>.js’, { base: ‘src’ })<br>    .pipe(plugins.babel({ presets: [‘@babel/preset-env’] }))<br>    .pipe(dest(‘temp’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const page = () =&gt; {<br>  return src(‘src/<em>.html’, { base: ‘src’ })<br>    .pipe(plugins.swig({ data, defaults: { cache: false } })) // 防止模板缓存导致页面不能及时更新<br>    .pipe(dest(‘temp’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const image = () =&gt; {<br>  return src(‘src/assets/images/<strong>‘, { base: ‘src’ })<br>    .pipe(plugins.imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>const font = () =&gt; {<br>  return src(‘src/assets/fonts/</strong>‘, { base: ‘src’ })<br>    .pipe(plugins.imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>const extra = () =&gt; {<br>  return src(‘public/**’, { base: ‘public’ })<br>    .pipe(dest(‘dist’))<br>}<br>const serve = () =&gt; {<br>  watch(‘src/assets/styles/</em>.scss’, style)<br>  watch(‘src/assets/scripts/<em>.js’, script)<br>  watch(‘src/</em>.html’, page)<br>  // watch(‘src/assets/images/<strong>‘, image)<br>  // watch(‘src/assets/fonts/</strong>‘, font)<br>  // watch(‘public/<strong>‘, extra)<br>  watch([<br>    ‘src/assets/images/</strong>‘,<br>    ‘src/assets/fonts/<strong>‘,<br>    ‘public/</strong>‘<br>  ], bs.reload)<br>  bs.init({<br>    notify: false,<br>    port: 2080,<br>    // open: false,<br>    // files: ‘dist/*<em>‘,<br>    server: {<br>      baseDir: [‘temp’, ‘src’, ‘public’],<br>      routes: {<br>        ‘/node_modules’: ‘node_modules’<br>      }<br>    }<br>  })<br>}<br>const useref = () =&gt; {<br>  return src(‘temp/</em>.html’, { base: ‘temp’ })<br>    .pipe(plugins.useref({ searchPath: [‘temp’, ‘.’] }))<br>    // html js css<br>    .pipe(plugins.if(/.js$/, plugins.uglify()))<br>    .pipe(plugins.if(/.css$/, plugins.cleanCss()))<br>    .pipe(plugins.if(/.html$/, plugins.htmlmin({<br>      collapseWhitespace: true,<br>      minifyCSS: true,<br>      minifyJS: true<br>    })))<br>    .pipe(dest(‘dist’))<br>}<br>const compile = parallel(style, script, page)<br>// 上线之前执行的任务<br>const build =  series(<br>  clean,<br>  parallel(<br>    //这里compile和useref是有依赖关系的，所以用series执行<br>    series(compile, useref),<br>    image,<br>    font,<br>    extra<br>  )<br>)<br>const develop = series(compile, serve)<br>module.exports = {<br>  clean,<br>  build,<br>  develop<br>}<br></pre><br>26.Gulp案例-补充<br>通过观察我们发现，我们只需要将clean、build、develop导出，并且在package.json文件中定义scripts</p>
<p><pre><br>“scripts”: {<br>    “clean”: “gulp clean”,<br>    “build”: “gulp build”,<br>    “develop”: “gulp develop”<br>}<br></pre><br>另外还要记得在.gitignore中忽略我们生成的dist、temp目录<br>另外虽然这个代码已经完成了基本项目中的需求，但是依然不建议直接保存以后使用。原因在于有可能以后各种依赖会有改变，或者项目需求不同等等，其实最主要的是不利于个人的学习，不多做一些联系不能更加熟练的掌握<br>27.封装工作流-准备<br>如果我们开发多个同类型项目，那么多个项目的自动化工作流有可能是一样的，我们有可能需要在多个项目中重复去使用这些构建任务，这些构建任务在大多数情况下是相同的，那么就需要复用相同的gulpfile，我们可以把gulpfile作为代码段保存起来，在不同的项目中去使用。先做一些准备工作：我们在git上创建一个仓库用来存放我们的代码。在本地初始化一个项目，这里老师自己写的脚手架是zce-cli，安装之后通过zce init 模版名称 去创建项目，然后通过git init去初始化仓库，git remote add origin 远端仓库地址 ，然后提交我们初始化的仓库<br>28.封装工作流-提取<br>首先将gulpfile文件整体移动到我们刚创建的项目中(作为index.js)，再将package.json中的devDependencies中的内容放到我们刚才创建的项目的dependencies中，因为dependencies才会自动安装，而devDependencies是开发依赖，不会自动安装。正常是将包发布到npm，但是这里我们是本地调试，故先进入到我们刚修改的项目中，在项目文件夹下执行npm link命令，再到我们要使用这个包的项目目录下执行npm link 要link的包的包名。在使用目录的gulpfile文件中</p>
<p><pre><br>module.exports = require(‘包名’)<br></pre><br>另外，我们之前写gulp的时候定义了data给模版使用，但是这里是不合理的，我们应该定义一个读取data文件的过程<br>29.封装工作流-解决模块中的问题<br>在项目根目录下创建一个配置文件pages.config.js，在这个文件里存放我们需要的数据，然后在我们抽取的包的index.js中添加读取操作</p>
<p><pre><br>const cwd = process.cwd()<br>let config = {}<br>try{<br>    const loadConfig = require(<code>${cwd}/pages.config.js</code>)<br>    config = Object.assign({},config,loadConfig)<br>}cache(e){}<br></pre><br>把代码中读取data的地方换成我们刚读取的config.data，并且把{ presets: [‘@babel/preset-env’] }改成{ presets: [require(‘@babel/preset-env’)] }<br>30.封装工作流-抽象路径配置<br>项目中的目录都是我们指定的，比如src文件夹，这样不够灵活，我们可以考虑把其改成可配置的</p>
<p><pre><br>let config = {<br>    build:{<br>        src:’src’,<br>        dist:’dist’,<br>        temp:’temp’,<br>        public:’public’,<br>        paths:{<br>            styles:’assets/styles/<em>.scss’,<br>            scripts:’assets/scripts/</em>.js’,<br>            pages:’<em>.html’,<br>            images:’asset/images/<strong>‘,<br>            fonts:’asset/fonts/</strong>‘,<br>        }<br>    },<br>}<br>const style = () =&gt; {<br>    //从’src/assets/styles/</em>.scss’变成config.build.paths.styles肯定会有一些问题<br>    //cwd指定在哪个路径去找，默认是当前项目所在目录<br>  return src(config.build.paths.styles, { base: config.build.src, cwd: config.build.src })<br>    .pipe(plugins.sass({ outputStyle: ‘expanded’ }))<br>    .pipe(dest(config.build.temp))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const font = () =&gt; {<br>  return src(config.build.paths.fonts, { base: config.build.src, cwd: config.build.src })<br>    .pipe(plugins.imagemin())<br>    .pipe(dest(config.build.dist))<br>}<br>const serve = () =&gt; {<br>  watch(config.build.paths.styles, {cwd: config.build.src},style)<br>  watch(config.build.paths.scripts, {cwd: config.build.src},script)<br>  watch(config.build.paths.pages, {cwd: config.build.src},page)<br>  watch([<br>    config.build.paths.images,<br>    config.build.paths.fonts,<br>    //‘public/<strong>‘//public因为和images等路径不一样，我们把public单独拆出来再做一个任务<br>  ],{cwd: config.build.src}, bs.reload)<br>  watch(‘</strong>‘,{cwd: config.build.public}, bs.reload)<br>  bs.init({<br>    notify: false,<br>    port: 2080,<br>    server: {<br>      baseDir: [‘temp’, ‘src’, ‘public’],<br>      routes: {<br>        ‘/node_modules’: ‘node_modules’<br>      }<br>    }<br>  })<br>}<br></pre><br>把我们之前写的config相关的目录换成config对象里的属性，我们已经把style修改作为例子放在这里了，剩下的按照例子修改就好。都修改完成后我们输入命令yarn serve来尝试下是不是都修改正确，都修改正确后，我们可以把config对象放到pages.config.js文件中，这样我们就可以按照自己的想法配置文件目录名称了<br>31.封装工作流-包装Gulp CLI</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/08/拉勾-自动化构建/" data-id="ckeeij3by0061joxqbco892u1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-脚手架工具" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/03/拉勾-脚手架工具/" class="article-date">
  <time datetime="2020-07-03T09:00:29.000Z" itemprop="datePublished">2020-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/03/拉勾-脚手架工具/">拉勾-脚手架工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.脚手架工具概要<br>脚手架的本质作用：创建项目基础结构、提供项目规范和约定<br>·相同的组织结构<br>·相同的代码开发范式<br>·相同的模块依赖<br>·相同的工具配置<br>·相同的基础代码<br>2.常用的脚手架工具<br>Yeoman、plop<br>3.Yeoman简介<br>相比vue-cli等这类专门的脚手架，Yeoman是一款非常通用的脚手架<br>4.Yeoman基础使用<br>首先要安装Yeoman，可以yarn global add yo或者npm install -g yo<br>使用Yeoman去创建项目，要找到对应类型的Generator，假设我们要生成一个node项目，我们需要generator-node这样一个模块，那么就需要把这个generator-node模块全局安装到本地。<br>安装成功后，可以创建一个目录，通过yo命令去运行我们安装的generator-node去创建项目，只不过这时候我们的命令要去掉generator，yo node这个命令就可以了，Yeoman会问我们一系列问题，正常回答就好<br>另外如果在生成过程中，让你在travis-cli上启动这个项目，命令行会卡死在这儿，敲一下回车结束这个流程<br>5.Sub Generator<br>有时候我们可能并不需要创建完整的项目，只需要在已有的项目基础上去创建一些文件，例如给一个已经存在的项目创建readme，或者创建一个配置文件等，可以用yeoman提供的sub generator这样一个特性来实现。在项目目录下用特定的命令去生成对应的文件，比如我们在项目中用generator-node子集的一个生成器去生成一个cli应用:yo node:cli，先提问是不是覆盖原来的package.json文件，我们选择是，然后本地模块可以通过npm link到全局范围，重新通过npm i 安装依赖<br>这里需要注意的是，并不是每个generator都生成子集生成器，我们要去官网去确定是不是有子集生成器<br>6.Yeoman 使用步骤总结<br><img src="https://snakexu.github.io/images/lagou/part_2/tools/6_1.png"><br>比如创建webapp的时候，有一些二进制的文件需要安装，npm处理起来会比较缓慢，我们可以用淘宝镜像源。一些淘宝镜像源<br><img src="https://snakexu.github.io/images/lagou/part_2/tools/6_2.png"><br>7.自定义Generator(基于Yeoman搭建自己的脚手架)<br>Yeoman是一款通用的脚手架，我们可以通过Yeoman去创建自己的项目。一些通用的cli只会创建基础的公共代码，而我们实际项目中会出现一些基础代码/业务代码，在相同类型项目时还是会重复的。我们可以通过自定义Generator来实现这些功能<br>8.创建Generator模块(本质上就是创建一个NPM模块)<br>Generator基本结构<br><img src="https://snakexu.github.io/images/lagou/part_2/tools/8_1.png"><br>另外generator的名称需要固定为generator-&lt; name &gt;(尖括号内无空格，尖括号内代表可修改项)这种格式<br>我们通过npm init / yarn init 的命令初始化一个项目，安装yeoman-generator模块，提供了生存generator的基类，在基类中提供了一些工具函数，让我们可以在创建生成器时更加便捷<br>然后我们按照之前介绍的基本结构创建文件夹，其中generators/app/index.js会作为generator的核心入口，需要导出继承自Yeoman Generator的类型。Yeoman Generator 在工作时会自动调用我们在此类型中定义的一些生命周期方法，我们在这些方法中可以通过调用父类提供的一些工具方法实现一些功能，例如文件写入</p>
<p><pre><br>const Generator = require(‘yeoman-generator’)<br>module.exports = class extends Generator {<br>    riting () {<br>        // Yeoman 自动在生成文件阶段调用此方法<br>        // 我们这里尝试往项目目录中写入文件<br>        this.fs.write(<br>           this.destinationPath(‘temp.txt’),<br>           Math.random().toString()<br>        )<br>    }<br>}<br></pre><br>以上一个简单的generator就完成了，通过npm link / yarn link 使之成为一个全局的模块包，这样yeoman在工作的时候就能找到我们写的工具，然后通过yo 工具名 来使用了<br>9.根据模版创建文件<br>我们可以创建一个templates目录，并且把我们想要生成的文件的都放入这个目录作为模板。例如我们创建templates/foo.txt</p>
<p><pre><br>这是一个模板文件<br>//下面说的都是真的，简单介绍了一下generator template的支持语法等<br>内部可以使用 EJS 模板标记输出数据<br>例如：&lt;%= title %&gt;<br>其他的 EJS 语法也支持<br>&lt;% if (success) { %&gt;<br>哈哈哈<br>&lt;% }%&gt;<br></pre><br>然后在generators/app/index.js中通过模板方式写入文件到目标目录</p>
<p><pre><br>const Generator = require(‘yeoman-generator’)<br>module.exports = class extends Generator {<br>    riting () {<br>        // Yeoman 自动在生成文件阶段调用此方法<br>        // 通过模板方式写入文件到目标目录<br>        // 模板文件路径<br>        const tmpl = this.templatePath(‘foo.txt’)<br>        // 输出目标路径<br>        const output = this.destinationPath(‘foo.txt’)<br>        // 模板数据上下文<br>        const context = { title: ‘Hello zce~’, success: false }<br>        this.fs.copyTpl(tmpl, output, context)<br>    }<br>}<br></pre><br>然后在命令行运行yo generatorname命令，yeoman就会使用模板引擎自动渲染模板。相对于手动创建每一个文件，模版的方式大大提高了效率<br>10.接收用户输入</p>
<p><pre><br>module.exports = class extends Generator {<br>    prompting () {<br>        // Yeoman 在询问用户环节会自动调用此方法<br>        // 在此方法中可以调用父类的 prompt() 方法发出对用户的命令行询问<br>        return this.prompt([<br>              {<br>                type: ‘input’,//采用用户输入的方式来得到信息<br>                name: ‘name’,//我们用来得到用户输入的键<br>                message: ‘Your project name’,//给用户的提示<br>                default: this.appname // appname 为项目生成目录名称，作为这个问题的默认值<br>              }<br>        ])<br>        .then(answers =&gt; {<br>              // answers =&gt; { name: ‘user input value’ }<br>              this.answers = answers<br>        })<br>    }<br>    riting () {<br>        // Yeoman 自动在生成文件阶段调用此方法<br>        // 模板文件路径<br>        //这里bar.html就是模版，里面简单的写了一些简单的html内容<br>        const tmpl = this.templatePath(‘bar.html’)<br>        // 输出目标路径<br>        const output = this.destinationPath(‘bar.html’)<br>        // 模板数据上下文<br>        const context = this.answers<br>        this.fs.copyTpl(tmpl, output, context)<br>    }<br>}<br></pre><br>11.Vue Generator案例<br>首先我们先按照原始方式创建一个理想的项目结构，里面有我们所有需要重复使用的项目基础代码，然后我们去封装一个generator去生成我们理想的项目结构<br>首先创建一个generator目录，比如我们叫generator-zce-vue，进入这个目录，通过yarn init / npm init 去初始化一个package.json，安装yeoman-generator依赖。打开项目，把我们之前生成的项目结构目录整体拷贝到templates目录下作为模板，并且把需要发生变化的地方可以替换成EJS(&lt;%= 变量名 %&gt; )模版标记，用用户输入等方式获取，比如我们替换项目名称</p>
<p><pre><br>//README.md文件</pre></p>
<h1 id="lt-name-gt"><a href="#lt-name-gt" class="headerlink" title="&lt;%= name %&gt;"></a>&lt;%= name %&gt;</h1><h2 id="Project-setup"><a href="#Project-setup" class="headerlink" title="Project setup"></a>Project setup</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure>
<h3 id="Compiles-and-hot-reloads-for-development"><a href="#Compiles-and-hot-reloads-for-development" class="headerlink" title="Compiles and hot-reloads for development"></a>Compiles and hot-reloads for development</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run serve</span><br></pre></td></tr></table></figure>
<h3 id="Compiles-and-minifies-for-production"><a href="#Compiles-and-minifies-for-production" class="headerlink" title="Compiles and minifies for production"></a>Compiles and minifies for production</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run build</span><br></pre></td></tr></table></figure>
<h3 id="Run-your-tests"><a href="#Run-your-tests" class="headerlink" title="Run your tests"></a>Run your tests</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run test</span><br></pre></td></tr></table></figure>
<h3 id="Lints-and-fixes-files"><a href="#Lints-and-fixes-files" class="headerlink" title="Lints and fixes files"></a>Lints and fixes files</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run lint</span><br></pre></td></tr></table></figure>
<h3 id="Customize-configuration"><a href="#Customize-configuration" class="headerlink" title="Customize configuration"></a>Customize configuration</h3><p>See <a href="https://cli.vuejs.org/config/" target="_blank" rel="noopener">Configuration Reference</a>.<br>//package.json<br>{<br>  “name”: “&lt;%= name %&gt;”,<br>  “version”: “0.1.0”,<br>  “private”: true,<br>  “scripts”: {<br>    “serve”: “vue-cli-service serve”,<br>    “build”: “vue-cli-service build”,<br>    “lint”: “vue-cli-service lint”<br>  },<br>  “dependencies”: {<br>    “axios”: “^0.19.0”,<br>    “core-js”: “^3.2.1”,<br>    “vue”: “^2.6.10”,<br>    “vue-router”: “^3.0.3”,<br>    “vuex”: “^3.0.1”<br>  },<br>  “devDependencies”: {<br>    “@vue/cli-plugin-babel”: “^3.11.0”,<br>    “@vue/cli-plugin-eslint”: “^3.11.0”,<br>    “@vue/cli-service”: “^3.11.0”,<br>    “@vue/eslint-config-standard”: “^4.0.0”,<br>    “babel-eslint”: “^10.0.1”,<br>    “eslint”: “^6.2.2”,<br>    “eslint-plugin-vue”: “^5.0.0”,<br>    “sass”: “^1.18.0”,<br>    “sass-loader”: “^7.1.0”,<br>    “vue-template-compiler”: “^2.6.10”<br>  }<br>}<br>//index.html<br>&lt; title &gt;&lt;%= name %&gt;&lt; /title &gt;<br><br>然后修改入口文件代码</p>
<p><pre><br>const Generator = require(‘yeoman-generator’)</pre></p>
<p>module.exports = class extends Generator {<br>  prompting () {<br>    return this.prompt([<br>      {<br>        type: ‘input’,<br>        name: ‘name’,<br>        message: ‘Your project name’,<br>        default: this.appname<br>      }<br>    ])<br>    .then(answers =&gt; {<br>      this.answers = answers<br>    })<br>  }<br>  writing () {<br>    // 把每一个文件都通过模板转换到目标路径<br>    const templates = [<br>      ‘.browserslistrc’,<br>      ‘.editorconfig’,<br>      ‘.env.development’,<br>      ‘.env.production’,<br>      ‘.eslintrc.js’,<br>      ‘.gitignore’,<br>      ‘babel.config.js’,<br>      ‘package.json’,<br>      ‘postcss.config.js’,<br>      ‘README.md’,<br>      ‘public/favicon.ico’,<br>      ‘public/index.html’,<br>      ‘src/App.vue’,<br>      ‘src/main.js’,<br>      ‘src/router.js’,<br>      ‘src/assets/logo.png’,<br>      ‘src/components/HelloWorld.vue’,<br>      ‘src/store/actions.js’,<br>      ‘src/store/getters.js’,<br>      ‘src/store/index.js’,<br>      ‘src/store/mutations.js’,<br>      ‘src/store/state.js’,<br>      ‘src/utils/request.js’,<br>      ‘src/views/About.vue’,<br>      ‘src/views/Home.vue’<br>    ]<br>    templates.forEach(item =&gt; {<br>      // item =&gt; 每个文件路径<br>      this.fs.copyTpl(<br>        this.templatePath(item),<br>        this.destinationPath(item),<br>        this.answers<br>      )<br>    })<br>  }<br>}<br><br>然后npm link / yarn link 到全局，然后创建项目文件夹，在我们的项目文件夹运行yo generator-name命令，输入交互信息，而我们发现会报错，是因为我们在index.html文件中用到了和EJS模版标记一样的标记，但是我们需要原样输出，那么我们就多加一个%就好</p>
<p><pre> &lt; link rel=”icon” href=”&lt;%%= BASE_URL %&gt;favicon.ico” &gt; </pre><br>12.发布Generator<br>实际上就是发布一个npm模块，只需要将自己写好的generator模块通过npm publish这样一个命令去发布一个公开模块就好。在发布之前，我们需要将源代码托管到源代码仓库。先创建一个本地仓库，创建gitignore去忽略一些文件，然后通过git init初始化一个本地空仓库。通过git add . 去添加，git commit，打开github，创建一个新仓库，通过git remote add origin 远端仓库地址 ，git push -u origin master， npm publish 。这里要注意了，如果你使用的是淘宝镜像，就需要发布到官方镜像:yarn publish –registry=<a href="https://registry.yarnpkg.com" target="_blank" rel="noopener">https://registry.yarnpkg.com</a><br>13.Plop简介<br>一个小而美的脚手架工具。主要用于创建项目中特定类型文件。自动化创建指定类型文件，提高工作效率。<br>14.Plop的基本使用<br>首先，将plop作为开发依赖安装到项目中yarn add plop –dev(这里老师创建了一个基本的react项目，把plop作为依赖安装到这个项目中)。在项目的根目录下创建plopfile.js文件，这个文件是plop工作的入口文件，导出一个函数，并且这个函数接收一个叫plop的对象，这个对象提供了一系列工具函数帮我们创建生成器的任务</p>
<p><pre><br>module.exports = plop =&gt; {<br>  plop.setGenerator(‘component’, { //plop.setGenerator(生成器名字,生成器配置选项)<br>    description: ‘application component’,//描述<br>    prompts: [ // 命令行交互问题<br>      {<br>        type: ‘input’,<br>        name: ‘name’,<br>        message: ‘component name’ //屏幕提示，如果有默认答案，还可以写default:默认答案内容<br>      }<br>    ],<br>    actions: [ // 完成命令行交互之后执行的动作<br>      {<br>        type: ‘add’,<br>        //双花括号，得到命令行交互的答案，但是由于hexo对双花括号报错，这里将双花括号中间添加空格<br>        path: ‘src/components/{ { name } }/{ { name } }.js’,<br>        templateFile: ‘plop-templates/component.js.hbs’//本次添加文件的模板文件，一般放在项目根目录的plop-templates文件夹下面<br>      },<br>      {<br>        type: ‘add’,<br>        path: ‘src/components/{ { name } }/{ { name } }.css’,<br>        templateFile: ‘plop-templates/component.css.hbs’<br>      },<br>      {<br>        type: ‘add’,<br>        path: ‘src/components/{ { name } }/{ { name } }.test.js’,<br>        templateFile: ‘plop-templates/component.test.js.hbs’<br>      }<br>    ]<br>  })<br>}<br></pre><br>component.test.js.hbs</p>
<p><pre><br>import React from ‘react’;<br>import ReactDOM from ‘react-dom’;<br>import  from ‘./‘;</pre></p>
<p>it(‘renders without crashing’, () =&gt; {<br>  const div = document.createElement(‘div’);<br>  ReactDOM.render(&lt; { { name } } /&gt;, div);<br>  ReactDOM.unmountComponentAtNode(div);<br>});<br><br>component.js.hbs</p>
<p><pre><br>import React from ‘react’;<br>import ‘./{ { name } }.css’;<br>export default () =&gt; (<br>  &lt; div className=”{ { name } }” &gt;</pre></p>
<p>  &lt; /div &gt;<br>)<br><br>component.css.hbs</p>
<p><pre><br>. {</pre></p>
<p>}<br><br>安装plop的时候，plop提供了一个cli程序，可以通过yarn去启动这个plop程序即yarn plop 生成器名字 (生成器名字就是我们刚才在plop.setGenerator中指定的)<br>总结，在项目中使用plop的步骤<br><img src="https://snakexu.github.io/images/lagou/part_2/tools/14_1.png"><br>15.脚手架的工作原理<br>本节通过创建一个小型脚手架工具来体会工作原理，主要是node的cli的应用，创建一个目录，在目录中用npm init / yarn init 初始化一个项目<br>package.json</p>
<p><pre><br>{<br>  “name”: “sample-scaffolding”,<br>  “version”: “0.1.0”,<br>  “main”: “index.js”,<br>  “bin”: “cli.js”,//指定执行cli应用的入口文件<br>  “author”: “zce &lt; <a href="mailto:w@zce.me" target="_blank" rel="noopener">w@zce.me</a> &gt; (<a href="https://zce.me)&quot;" target="_blank" rel="noopener">https://zce.me)&quot;</a>,<br>  “license”: “MIT”,<br>  “dependencies”: {<br>    “ejs”: “^2.6.2”,<br>    “inquirer”: “^7.0.0”<br>  }<br>}<br></pre><br>cli.js</p>
<p><pre></pre></p>
<p>#!/usr/bin/env node<br>// Node CLI 应用入口文件必须要有这样的文件头<br>// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755<br>// 具体就是通过 chmod 755 cli.js 实现修改<br>// 脚手架的工作过程：<br>// 1. 通过命令行交互询问用户问题<br>// 2. 根据用户回答的结果生成文件<br>const fs = require(‘fs’)<br>const path = require(‘path’)<br>// 发起命令行交互需要安装inquirer<br>const inquirer = require(‘inquirer’)<br>// 模版引擎，需要安装<br>const ejs = require(‘ejs’)<br>inquirer.prompt([ //发起命令行询问<br>  {<br>    type: ‘input’,<br>    name: ‘name’,<br>    message: ‘Project name?’<br>  }<br>])<br>.then(anwsers =&gt; { // 在then中拿到用户答案<br>  // console.log(anwsers)<br>  // 根据用户回答的结果生成文件<br>  // 模板目录<br>  const tmplDir = path.join(__dirname, ‘templates’)<br>  // 目标目录<br>  const destDir = process.cwd()<br>  // 将模板下的文件全部转换到目标目录<br>  fs.readdir(tmplDir, (err, files) =&gt; {<br>    if (err) throw err<br>    files.forEach(file =&gt; {<br>      // 通过模板引擎渲染文件<br>      ejs.renderFile(path.join(tmplDir, file), anwsers, (err, result) =&gt; { //参数 模版引擎路径，工作环境上下文，回调函数<br>        if (err) throw err<br>        // 将结果写入目标文件路径<br>        fs.writeFileSync(path.join(destDir, file), result)<br>      })<br>    })<br>  })<br>})<br><br>通过yarn link 的方式把这样一个模块link到全局，然后可以通过sample-scaffolding这样一个命令</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/03/拉勾-脚手架工具/" data-id="ckeeij34g004ojoxq4svgzfw2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/拉勾/">拉勾</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾/">拉勾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业/">网易微专业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECMAScript新特性/" style="font-size: 10px;">ECMAScript新特性</a> <a href="/tags/JavaScript异步编程/" style="font-size: 10px;">JavaScript异步编程</a> <a href="/tags/TypeScript语言/" style="font-size: 10px;">TypeScript语言</a> <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/函数式编程范式/" style="font-size: 10px;">函数式编程范式</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/手写Promise源码/" style="font-size: 10px;">手写Promise源码</a> <a href="/tags/拉勾/" style="font-size: 20px;">拉勾</a> <a href="/tags/拉勾，自动化构建/" style="font-size: 10px;">拉勾，自动化构建</a> <a href="/tags/数据结构/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 17.5px;">算法</a> <a href="/tags/网易微专业/" style="font-size: 10px;">网易微专业</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/10/拉勾-Virtual-DOM-的实现原理/">拉勾-Virtual DOM 的实现原理</a>
          </li>
        
          <li>
            <a href="/2020/08/05/拉勾-模拟Vue-js响应式原理/">拉勾-模拟Vue.js响应式原理</a>
          </li>
        
          <li>
            <a href="/2020/08/03/拉勾-Vue-Router实现原理/">拉勾-Vue-Router实现原理</a>
          </li>
        
          <li>
            <a href="/2020/08/02/拉勾-Vue-js基础回顾/">拉勾-Vue.js基础回顾</a>
          </li>
        
          <li>
            <a href="/2020/07/29/拉勾-规范化标准/">拉勾-规范化标准</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>