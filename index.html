<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="喵小喵的窝">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="喵小喵的窝">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-拉勾-规范化标准" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/29/拉勾-规范化标准/" class="article-date">
  <time datetime="2020-07-29T00:08:35.000Z" itemprop="datePublished">2020-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/29/拉勾-规范化标准/">拉勾-规范化标准</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.规范化介绍<br>(1)为什么要有规范化标准<br>·软件开发需要多人协同<br>·不同开发者具有不同的编码习惯和喜好<br>·不同的喜好增加项目维护成本<br>·每个项目或团队需要明确统一的标准<br>(2)哪里需要规范化标准<br>·代码、文档、甚至是提交日志<br>·开发过程中认为编写的成果<br>·代码标准化规范最为重要<br>(3)实施规范化方法<br>·编码前人为的标准约定<br>·通过工具实现lint(代码规范化检查)<br>常见的规范化实现方式<br>·ESLint工具使用<br>·定制ESLint校验规则<br>·ESLint对TypeScript的支持<br>·ESLint结合自动化工具或者webpack<br>·基于ESLint的衍生工具<br>·Stylelint工具的使用<br>2.ESLint介绍<br>最为主流的JavaScript lint工具，监测js代码质量<br>ESLint很容易统一开发者的编码风格<br>ESLint可以帮开发者提升编码能力<br>3.ESLint 安装<br>安装步骤<br>·初始化项目<br>·安装ESLint模块为开发依赖<br>·通过CLI命令验证安装结果<br>这里老师说道现阶段已经很少有项目需要安装全局依赖，这样别的开发者在拿到项目之后只要npm install就行，不必关心安装了什么全局依赖。在用npm init初始化项目之后，安装eslint依赖，然后我们进入node_modules目录下，找到eslint安装目录的.bin目录，通过前面我们知道通常.bin目录下有该模块可以执行的文件，我们可以通过这个cli程序检测代码。对于这个文件，我们可以通过yarn或者npx去执行<br>4.ESLint快速上手<br>ESLint检查步骤<br>·编写”问题”代码<br>·使用ESLint执行检测<br>·完成ESLint使用配置<br>在我们上节课初始化的项目中编写一段”问题”代码</p>
<p><pre><br>const foo=123<br>function fn() {<br>    console.log(‘hello’)<br>      console.log(‘eslint’)<br>}<br>fn(<br>suyy()<br></pre><br>执行npx eslint ./01-prepare.js 命令之后，命令行会报错，我们跟着命令行的提示执行npx eslint –init，选择你所需要的选项，最后eslint帮我们安装依赖之后，再次执行npx eslint ./01-prepare.js，会报一个错误，就是我们在调用fn时只写了一半括号的语法错误，修正这个语法错误之后，再执行npx eslint ./01-prepare.js会报更多错误，因为eslint在有语法错误的时候是没办法检查问题代码和代码风格的。执行npx eslint ./01-prepare.js –fix 可以修正一部分代码风格上的问题，其余问题需要手工修改<br>5.ESLint配置文件解析<br>npx eslint –init 命令生成的.eslintrc.js文件里的配置会影响当前目录以及所有子目录的文件，正常情况下我们不会手动修改这个配置，但是如果我们需要开启或者关闭某些校验规则的时候，这个配置文件就会非常重要。下面是我们通过npx eslint –init命令生成的.eslintrc.js文件的内容。由于这个文件运行在node环境下，所以可以看到用module.exports导出了配置</p>
<p><pre><br>module.exports = {<br>  env: { // 标记当前代码的运行环境，eslint会根据环境信息判断当前成员是否可用<br>    browser: true, // 这里标记运行在浏览器环境中，可以运行比如document、window这种全局对象，不可以使用global等node对象<br>    es2020: true<br>  },<br>  extends: [ // 继承一些共享的配置，可以配置多个项目共享一些配置，后续会讲到<br>    ‘standard’<br>  ],<br>  parserOptions: { // 设置语法解析器的相关配置，控制是否可以使用某一个es版本的语法<br>    ecmaVersion: 11 // 只是语法检测，不代表某个成员是否可用<br>  },<br>  rules: { // 配置eslint中某些规则的开启或者关闭<br>      ‘no-alert’:’error’ // 这里举例开启no-alert(规则名称是内置的)，值可以取 off 关闭,error 报错,warn 警告<br>  },<br>  globals: { // 在最新版本的默认配置中已经没有体现了，额外生命代码中可以使用的全局成员<br>     “jQuery”: “readonly” // 这样jQuery就可以作为全局成员被使用了<br>     // 项目文件中可以使用例如 jQuery(‘#abc’)<br>  }<br>}<br>// 02-configuration.js<br>document.getElementById(‘#abc’)<br></pre><br>如果我们删除掉env的browser:true，再运行 npx eslint ./02-configuration.js ，并不会报错是因为我们在生成配置文件的时候选择的standard风格，最终这里就继承了standard风格中的配置，而在standard配置中也做了一些额外的具体配置，所以document/window在任何环境都可以使用，看下图，打开了node_modules中eslint-config-standard相关内容，我们的项目继承这里。但是如果我们注释掉document相关，写上alert(1)再运行npx eslint ./02-configuration.js 就会报错，这就证明eslint确实是根据env设置的成员环境判断变量<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/5_1.png"><br>下面是env成员可以设置的变量，另外这些环境并不是互斥的，也就说我们可以选择多个环境并存<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/5_2.png"><br>6.ESLint配置注释<br>ESLint配置注释可以理解为将配置作为注释写在脚本文件中，然后再去执行代码的校验(比如项目中有一两个点必须违反eslint的校验规则)，比如下面违反校验规则的代码。临时禁用eslint校验规则的语法可以参考官方文档<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/6_1.png"><br>一种临时禁用的方式<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/6_2.png"><br>只在当前行忽略校验规则<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/6_3.png"><br>eslint校验规则官网地址<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/6_4.png"><br>7.ESLint结合自动化工具<br>如果有自动化工具，最好还是把eslint结合自动化工具，这样的好处<br>·继承之后，ESLint一定会工作<br>·与项目统一，管理更加方便<br><img src="https://snakexu.github.io/images/lagou/part_2/eslint/7_1.png"><br>后续会用到的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/29/拉勾-规范化标准/" data-id="ckdbzsih3000wjrxqo7qsy7iz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-其他打包工具" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/拉勾-其他打包工具/" class="article-date">
  <time datetime="2020-07-28T03:39:09.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/28/拉勾-其他打包工具/">拉勾-其他打包工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.Rollup概述<br>Rollup与webpack很类似，但是Rollup更为小巧，相比于webpack能配合各种loader/plugin几乎完成开发过程中所有需求，Rollup仅是ESModules打包器，并没有任何其他额外功能。开发初衷仅仅是提供一个充分利用ESM各项特性的高效打包器<br>2.Rollup快速上手<br>新建一个项目</p>
<p><pre><br>// ./src/index.js<br>import {log} from ‘./logger’<br>import messages from ‘./messages’<br>const msg = messages.hi<br>log(msg)<br>// ./src/logger.js<br>export const log = msg =&gt;{<br>    console.log(‘——INFO——‘)<br>    console.log(msg)<br>    console.log(‘—————-‘)<br>}<br>export const error = msg =&gt;{<br>    console.log(‘——ERROR——‘)<br>    console.log(msg)<br>    console.log(‘—————-‘)<br>}<br>// ./src/messages.js<br>export default {<br>    hi: ‘Hey Guys,I am hapi’<br>}<br></pre><br>安装rollup之后执行yarn rollup 会得到命令提示，执行 yarn rollup ./src/index.js  ，不知道是不是由于版本不同，课程里这样会报错，我自己执行的时候并没有报错，课程里报错的原因是没有指定输出格式，我的rollup版本是2.23.0 。<br>yarn rollup ./src/index.js –format iife  指定输出格式，会在命令行看到立即执行函数式的输出。<br>yarn rollup ./src/index.js –format iife –file dist/bundle.js 指定输出目录。打开输出结果看到</p>
<p><pre><br>(function () {<br>    ‘use strict’;</pre></p>
<pre><code>const log = msg =&gt;{
    console.log(&apos;------INFO------&apos;);
    console.log(msg);
    console.log(&apos;----------------&apos;);
};

var messages = {
    hi: &apos;Hey Guys,I am hapi&apos;
};

const msg = messages.hi;
log(msg);
</code></pre><p>}());<br><br>输出结果非常简单，按照依赖顺序拼接到一起，并且默认开启了tree-shaking<br>3.Rollup配置文件<br>rollup同样支持配置文件rollup.config.js，同样运行在node环境，但是rollup本身会额外处理这个配置文件，所以在这个文件中可以直接使用ESModule。</p>
<p><pre><br>export default {<br>    input: ‘src/index.js’, // 指定入口文件<br>    output: { // 输出相关配置，要求是一个对象<br>        file: ‘dist/bundle.js’, //输出文件名<br>        format: ‘iife’ // 输出格式<br>    }<br>}<br></pre><br>这里执行yarn rollup –config 来告诉rollup，根据配置文件执行，也可以根据这个参数指定配置文件的名称，比如 yarn rollup –config rollup.config.js 或者 yarn rollup –config rollup.development.js等<br>4.Rollup使用插件<br>Rollup自身的功能就只是ESModules模块的合并打包，如果项目有更高级的需求，例如加载其他类型的资源文件、导入commonjs模块、编译ECMAScript新特性等，这些额外的需求，Rollup支持使用插件的方式扩展，插件是Rollup唯一的扩展方式。我们举例一个导入JSON文件的插件，插件名字rollup-plugin-json</p>
<p><pre><br>//rollup.config.js<br>import json from ‘rollup-plugin-json’ //默认导出的是插件函数<br>export default {<br>    input: ‘src/index.js’, // 指定入口文件<br>    output: { // 输出相关配置，要求是一个对象<br>        file: ‘dist/bundle.js’, //输出文件名<br>        format: ‘iife’ // 输出格式<br>    },<br>    plugins: [<br>        json() // 这里是调用的插件结果<br>    ]<br>}<br>//index.js<br>import {log} from ‘./logger’<br>import messages from ‘./messages’<br>import { name, version } from ‘../package.json’<br>const msg = messages.hi<br>log(msg)<br>log(name)<br>log(version)<br></pre><br>执行yarn rollup –config 之后可以在打包结果文件中看到我们打印的package.json文件的信息<br>6.Rollup加载NPM模块<br>rollup只能加载本地模块，不能像webpack一样直接通过模块名称导入node_modules的第三方模块，为了磨平这样一个差异，rollup官方给出了一个rollup-plugin-node-resolve插件，直接在代码中通过名称导入对应模块 </p>
<p><pre><br>//rollup.config.js<br>import json from ‘rollup-plugin-json’ //默认导出的是插件函数<br>import resolve from ‘rollup-plugin-node-resolve’<br>export default {<br>    input: ‘src/index.js’, // 指定入口文件<br>    output: { // 输出相关配置，要求是一个对象<br>        file: ‘dist/bundle.js’, //输出文件名<br>        format: ‘iife’ // 输出格式<br>    },<br>    plugins: [<br>        json(), // 这里是调用的插件结果<br>        resolve()<br>    ]<br>}<br>//index.js<br>import {log} from ‘./logger’<br>import messages from ‘./messages’<br>import { name, version } from ‘../package.json’<br>import _ from ‘lodash-es’<br>//这里使用的是lodash的es版本，如果用lodash的普通版本需要额外的处理。毕竟rollup支持的是ESModules<br>const msg = messages.hi<br>log(msg)<br>log(name)<br>log(version)<br>log(_.camelCase(‘hello world’))<br></pre><br>6.Rollup加载CommonJS模块<br>为了支持commonjs方式导出成员，官方给出了插件rollup-plugin-commonjs</p>
<p><pre><br>//rollup.config.js<br>//这几个import的插件都是需要安装的<br>import json from ‘rollup-plugin-json’ //默认导出的是插件函数<br>import resolve from ‘rollup-plugin-node-resolve’<br>import commonjs from ‘rollup-plugin-commonjs’<br>export default {<br>    input: ‘src/index.js’, // 指定入口文件<br>    output: { // 输出相关配置，要求是一个对象<br>        file: ‘dist/bundle.js’, //输出文件名<br>        format: ‘iife’ // 输出格式<br>    },<br>    plugins: [<br>        json(), // 这里是调用的插件结果<br>        resolve(),<br>        commonjs()<br>    ]<br>}<br>//cjs-module.js<br>module.exports = {<br>    foo: ‘bar’<br>}<br>//index.js<br>import {log} from ‘./logger’<br>import messages from ‘./messages’<br>import { name, version } from ‘../package.json’<br>import _ from ‘lodash-es’<br>import cjs from ‘./cjs-module’<br>const msg = messages.hi<br>log(msg)<br>log(name)<br>log(version)<br>log(_.camelCase(‘hello world’))<br>log(cjs)<br></pre><br>执行打包命令就可以在打包结果中看到cjs-module.js(按commonjs标准写的)的内容了<br>7.rollup代码拆分<br>可以使用符合ESModules的动态导入实现按需加载，rollup内部也会自动处理代码的分包。</p>
<p><pre><br>import(‘./logger’).then(({ log }) =&gt; {<br>    log(‘code splitting’)<br>})<br></pre><br>如果像上面一样直接在index.js中动态导入logger并且按照我们之前在rollup.config.js中设置的output.format:’iife’去打包会报错，因为iife会把所有模块放到同一个函数当中，这样就没法实现代码拆分，所以只能以AMD或者CMD等的标准去输出打包结果，在浏览器环境中只能使用AMD的标准，这里运行yarn rollup –config –format amd把我们之前在配置文件中定义的输出格式覆盖掉，但是这里还是会报错，因为多个输出不能使用file这种配置方式，因为file是指定一个单个文件输出的文件名</p>
<p><pre><br>output: {<br>    dir: ‘dist’,<br>    format: ‘amd’<br>},<br></pre><br>所以rollup是以动态导入的方式实现代码的拆分<br>8.Rollup多入口打包<br>Rollup同样支持多入口打包，而且对于多个入口当中的公共部分也会提取到单个文件当中做独立的bundle</p>
<p><pre><br>// index.js<br>import fetchApi from ‘./fetch’<br>import { log } from ‘./logger’<br>fetchApi(‘/posts’).then(data =&gt; {<br>    data.forEach(item =&gt; {<br>        log(item)<br>    })<br>})<br>// album.js<br>import fetchApi from ‘./fetch’<br>import { log } from ‘./logger’<br>fetchApi(‘/photos?albumId=1’).then(data =&gt; {<br>    data.forEach(item =&gt; {<br>        log(item)<br>    })<br>})<br>// fetch.js<br>export default endpoint =&gt; {<br>    return fetch(<code>https://jsonplaceholder.typicode.com${endpoint}</code>)<br>        .then(response =&gt; response.json())<br>}<br>// logger.js<br>export const log = msg =&gt;{<br>    console.log(‘——INFO——‘)<br>    console.log(msg)<br>    console.log(‘—————-‘)<br>}<br>export const error = msg =&gt;{<br>    console.log(‘——ERROR——‘)<br>    console.log(msg)<br>    console.log(‘—————-‘)<br>}<br></pre><br>至于rollup.config.js根据input的书写方式，可以有两种</p>
<p><pre><br>export default {<br>    input: [‘src/index.js’, ‘src/album.js’],<br>    output: {<br>        dir: ‘dist’,<br>        format: ‘amd’<br>    },<br>}<br>// 或者<br>export default {<br>    input: {<br>        foo:’src/index.js’,<br>        bar:’src/album.js’<br>    },<br>    output: {<br>        dir: ‘dist’,<br>        format: ‘amd’<br>    },<br>}<br></pre><br>但是根据AMD格式打包的文件不能直接引用到页面上，而必须通过实现AMD标准的库去加载，可以手动在dist打包目录写入一个index.html，然后通过requirejs引入打包结果<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/8_1.png"><br>然后通过http服务启动页面就能看到打包结果正常被处理了<br>9.Rollup选用原则<br>相较于webpack，rollup的优势在于：<br>·输出的结果更加扁平一些，执行效率自然就会更高<br>·自动移除未引用的代码<br>·打包结果依然完全可读<br>缺点在于<br>·加载非ESM的第三方模块比较复杂<br>·模块最终都被打包到一个函数中，无法实现HMR<br>·浏览器环境中，代码拆分功能依赖AMD库<br>如果我们开发的是一个应用程序，rollup在满足上会有一些欠缺<br>如果我们正在开发一个框架或者一个类库，很少的在我们的代码中依赖第三方模块。所以大多数知名框架/库都在使用rollup。<br>社区中希望二者并存，即更专业的工具做更专业的事情。webpack大而全，rollup小而美。<br>总结：开发应用程序建议选择webpack，开发类库或者框架建议选择rollup<br>10.Parcel<br>Parcel是一款完全零配置的前端应用打包器<br>首先yarn init初始化一个项目，然后yarn add parcel-bundler –dev,在根目录下创建src目录，在src目录中创建index.html，Parcel官方建议把html文件作为打包入口<br>index.html文件<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_1.png"><br>foo.js文件<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_2.png"><br>main.js文件<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_3.png"><br>执行yarn parcel src/index.html , 其中src/index.html是指定入口文件。发现parcel不仅帮我们打包了应用，还开启了类似于webpack-dev-server的开发服务器。我们更改代码保存过后可以看到浏览器自动刷新<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_4.png"><br>另外parcel还支持模块的热替换，甚至还支持自动安装依赖，如果我们在页面中import jquery，然后直接写jquery的语法，那么parcel在保存代码的时候会帮我们安装依赖<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_5.png"><br>除此之外parcel同样支持加载其他类型的资源模块，相比其他打包器，在parcel中加载其他资源模块依然是零配置的，例如我们加载了一个css文件并且在main.js中引入这个css文件，保存过后样式可以立即生效。还可以随意添加图片。<br>支持动态导入代码拆分<br><img src="https://snakexu.github.io/images/lagou/part_2/otherpacktool/10_6.png"><br>yarn parcel build src/index.html 可以以生产模式进行打包。对于相同体量的打包，parcel的构建速度比webpack快很多，因为parcel内部是使用多进程同时去工作(webpack可以使用happypack插件实现多进程打包)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/28/拉勾-其他打包工具/" data-id="ckdbzsils004gjrxqgogpkzad" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-Webpack打包" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/17/拉勾-Webpack打包/" class="article-date">
  <time datetime="2020-07-17T04:27:15.000Z" itemprop="datePublished">2020-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/17/拉勾-Webpack打包/">拉勾-Webpack打包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.模块打包工具的由来<br>·ES Modules存在环境兼容问题<br>·模块文件过多，网络请求频繁<br>·所有前端资源都需要模块化(css、html等文件)<br>所以模块化是必要的<br>思考下，我们对于模块化的需求总结为<br>·新特性代码编译<br>·模块化JavaScript打包<br>·支持不同类型的资源模块<br>2.模块打包工具概要<br>前端有几个打包工具很好的解决了我们在上一节课中总结出来的模块化的需求，这几个工具主要包括webpack、parcel、rollup。以webpack为例，能很好的满足我们上一节总结的需求。webpack作为一个模块化打包工具，能很好的解决JavaScript打包的问题，可以将零散的模块代码打包到同一个js文件当中，对于代码中有环境兼容问题的代码，我们就可以在打包的过程中通过模块加载器Loader对其进行编译转换；其次，webpack还具备代码拆分(code splitting)能力，能够将应用中所有的代码按照我们的需要进行打包；最后，webpack支持我们在JavaScript当中以模块化方式载入任意类型的文件。剩下两个打包工具功能类似，所有打包工具都是以前端模块化为目标(不仅仅是js模块化)，可以使我们更好的使用模块化带来的优势，而忽略模块化带来的影响<br>3.Webpack快速上手<br>首先创建一个项目，目录结构为<br>|-root<br>|–index.html<br>|–src<br>|—heading.js<br>|—index.js</p>
<pre>
//index.html
< !DOCTYPE html >
< html lang="en" >
< head >
    < meta charset="UTF-8" >
    < title >webpack-快速上手< /title >
    < meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" / >
< /head >
< body >
< script type="module" src="src/index.js" >< /script >
< /body >
< /html >
//heading.js
export default () => {
    const element = document.createElement('h2')
    element.textContent = 'hello world'
    element.addEventListener('click', () => {
        alert('hello webpack')
    })
    return element
}
//index.js
import createHeading from './heading.js'
const heading  = createHeading()
document.body.append(heading)
</pre>
启动服务，就能在浏览器中看到结果了
想要尝试webpack，我们要初始化项目，即npm init / yarn init ，然后安装webpack和webpack-cli，然后执行webpack命令，可以看到在根目录下生成文件夹dist，里面的main.js就是我们打包的结果，在index.html中进行修改，引入我们打包的文件
<pre>
< !DOCTYPE html >
< html lang="en" >
< head >
    < meta charset="UTF-8" >
    < title >webpack-快速上手< /title >
    < meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" / >
< /head >
< body >
< script src="dist/main.js" >< /script >
< /body >
< /html >
</pre>
再次启动服务，可以看到和刚才一样的页面了
4.webpack配置文件
webpack4以后的版本支持0配置启动打包，整个打包过程会按照约定将src/index.js作为打包入口，最终打包结果存放到'dist/main.js'中。但是项目中我们往往需要的是自定义一些东西，比如上节课的项目中，我们将index.js改名为main.js，那么我们的入口文件就是main.js，就需要自定义webpack打包入口。这时候我们就需要给webpack添加配置文件。在根目录下新建文件webpack.config.js，这个文件运行在node环境下的js文件，也就是说我们需要按照CommonJs的方式去编写代码
<pre>
const path = require('path')
module.exports = {
    entry: './src/main.js',//入口文件，如果是相对路径，那么./是不能省略的
    output: { //出口文件
        filename: 'bundle.js',
        path: path.join(__dirname, 'output'),//需要绝对路径
    }
}
</pre>
5.webpack工作模式
可以有三种模式(可以直接在命令行中 webpack --mode development ，即 webpack --mode 打包模式)
默认production会启动优化打包结果(比如压缩打包文件等等)
development模式会优化打包速度，添加一些调试过程中需要的辅助到打包代码
none模式运行最原始状态的打包，不会做任何额外的处理
具体三种模式差异，可以在官方文档 https://webpack.js.org/configuration/mode/ 中找到
或者在配置文件中添加mode属性
<pre>
const path = require('path')
module.exports = {
    mode: 'development',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js',
        path: path.join(__dirname, 'output'),
    }
}
</pre>
6.webpack打包结果运行原理
为了更好理解原理，我们将mode设置为最原始的none方式
<pre>
const path = require('path')
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js',
        path: path.join(__dirname, 'output'),
    }
}
</pre>
我们把打包结果折叠之后看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_1.png">
可以看出来，webpack的打包结果是一个立即执行函数，接收一个modules参数，调用的时候传入一个数组，展开这个数组，数组中每一个元素都是一个参数列表相同的函数，
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_2.png">
这里的函数对应的就是我们源代码中的模块
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_3.png">
我们每一个模块最终都会包裹到这样一个函数当中，从而实现模块的私有作用域。
展开webpack入口函数，看到最开始定义一个对象，用于缓存(存放)已经加载过的模块，
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_4.png">
定义了一个require函数，用来加载模块
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_5.png">
在require上挂载一些其他的数据和一些工具函数，这些并不重要
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_6.png">
后面这个函数调用了require函数，传入了一个0开始去加载模块
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_7.png">
这个模块id就是我们上面元素数组的下标，这里才开始加载源代码中的所谓入口模块。
如果想更细致的了解，那么就启动本地服务，通过打断点的方式单步执行，去了解更细节的内容
7.webpack资源模块加载
我们给项目添加一个css文件并且把webpack的入口文件改成这个css文件，执行webpack命令，会发现报错，因为webpack默认只处理JavaScript文件。但是webpack也给了我们提示，需要配置处理当前类型文件的加载器。那么我们开始安装css-loader，安装之后，还要在配置文件中配置一下
<pre>
module: {
    rules: [
        {
            test: /\.css$/,//正则表达式，匹配打包过程中的文件路径
            use: 'css-loader'//匹配所需要的loader
        }
    ]
}
</pre>
即使我们安装了css-loader，但是依然发现，没有作用，因为css-loader的作用就是将css文件转换成为js模块，具体实现就是将css代码push到一个数组当中，这个数组是css-loader内部一个模块提供的，整个过程并没有任何一个地方用到这个数组。所以这里我们需要安装一个style-loader，这个loader的作用就是将css-loader转换的结果通过style标签的形式追加到页面上
<pre>
module: {
    rules: [
        {
            test: /\.css$/,//正则表达式，匹配打包过程中的文件路径
            use: [
            'style-loader',
            'css-loader'
            ]//匹配所需要的loader
            //注意，如果配置了多个loader，那么是从后往前执行的
        }
    ]
}
</pre>
在我们打包好的文件中可以看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_8.png">
也就是style-loader的作用了，在页面上就可以看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/6_9.png">
loader是webpack的核心特性，通过loader就可以加载任何类型的资源
8.webpack导入资源模块
虽然我们知道如何处理js意外的文件类型了，但是一般而言，打包入口还是js文件，因为打包入口某种程度上来说就是运行入口。我们先将之前css的入口文件改回main.js，然后在main.js中import(导入)main.css文件，因为只需要去执行css文件，所以直接
<pre>import './main.css</pre>
正常情况下，页面是可以正常运行的。我们在写一个heading.css放到heading.js中
<pre>
//heading.css
.heading{
    padding:20px;
    background: #343a40;
    color: #fff;
}
//heading.js
import './heading.css'
export default () => {
    const element = document.createElement('h2')
    element.textContent = 'hello world'
    element.classList.add('heading') //在这里添加了类名，因为css是用类的
    element.addEventListener('click', () => {
        alert('hello webpack')
    })
    return element
}
</pre>
再次运行，还是能正常加载的
在这里我们需要理解，webpack是鼓励把任何当前代码需要的资源文件引入到当前代码中，也就是根据代码的需要动态导入资源，需要资源的不是应用而是此时编写的代码，也就是你这里的代码想要正常工作就必须去加载的资源。试想一下如果样式等还是单独引入到页面文件当中，如果当前代码更新了，不再需要这个资源，又会怎样。所以通过JavaScript代码去引入资源文件或者说建立js和资源文件中的依赖关系是有很明显优势的。JavaScript驱动了整个前端应用，当我们建立了这些依赖关系，逻辑合理，js确实需要这些资源文件；确保上线资源不缺失，都是必要的。总结一下就是，学习新事物，学习的是它的思想和突破点，因为只是了解新事物，大部分人都能做到，比如照着文档学习各种前端技术。
9.webpack文件资源加载器
webpack的loader非常多，只要合理的需求，都能找到相应的loader，这里我们演示几个有代表性的loader。大部分loader都是类似于css-loader，将资源模块转换为js代码的方式去做，但是字体、图片这些，是没有办法通过js的方式去表示的，对于这类的资源，需要用到文件资源加载器，也就是file-loader
<pre>
//main.js
import createHeading from './heading.js'
import './main.css'
import logo from './logo.png'
const heading  = createHeading()
document.body.append(heading)
const img = new Image()
img.src = logo
document.body.append(img)
//webpack.config.js
module: {
        rules: [
        {
            test: /\.css$/,//正则表达式，匹配打包过程中的文件路径
            use: [
            'style-loader',
            'css-loader'
            ]//匹配所需要的loader
            //注意，如果配置了多个loader，那么是从后往前执行的
        },
        {
            test: /.png$/,
            use: 'file-loader'
        }
    ]
}
</pre>
加载图片原理比较简单，就是把刚刚生成图片的名称导出，并在相应入口模块导入刚刚导出的文件路径。
但是运行之后我们发现，图片并不能正常展示。打开开发人员工具看到图片src直接加载了网站根目录下的图片，但是我们网站根目录下并没有这张图片，正确地址应该在网站根目录下的dist文件夹中，这里是由于index.html并没有生成到dist目录而是放在了项目根目录下，所以把项目根目录作为网站根目录，而webpack默认认为所有打包结果都会在网站根目录下，解决的办法就是告诉webpack打包文件在网站的位置
<pre>
output: {
    filename: 'bundle.js',
    path: path.join(__dirname, 'dist'),//需要绝对路径
    publicPath: 'dist/' //默认值为空字符串，表示网站的根目录，我们放在dist下，这里斜线不能省略
},
</pre>
总结一下文件加载器的工作过程：
webpack在打包时遇到图片文件，然后根据配置文件的配置，匹配到对应的文件加载器，此时文件加载器就开始工作了，先将导入的文件拷贝到输出的目录，然后将文件拷贝到输出目录的路径作为当前模块的返回值返回，我们就可以通过模块拿到这个资源的访问路径
10.webpack URL加载器
除了file-loader这种通过拷贝物理文件形式去处理文件资源以外，通过Data URLs去表示文件的方式也非常常见。Data URLs是一种特殊的URL协议，可以用来直接表示一个文件。传统URL一般要求服务器上有一个对应文件，然后我们通过请求这个地址得到服务器上的对应文件。而Data URLs是一种当前URL就可以直接表示文件内容的方式，也就是说这种url文本就已经包含文件的内容，使用的时候不需要发送http请求。比如
<pre>data:text/html;charset=UTF-8,< h1 >html content< /h1 ></pre>
浏览器能根据这段内容解析出来，这是一段html类型文件内容，编码是utf-8，内容是一段包含h1标签的html代码。
对于图片、字体这种无法直接通过文本表示的二进制类型文件，我们可以通过将文件内容进行base64编码，把编码结果去表示文件的内容。在webpack打包静态资源文件的时候，我们同样可以通过这种方式去实现(通过dataURLs就可以以代码的方式表示任意类型的文件)，需要安装url-loader
<pre>
module: {
    rules: [
        {
            test: /\.css$/,//正则表达式，匹配打包过程中的文件路径
            use: [
            'style-loader',
            'css-loader'
            ]//匹配所需要的loader
            //注意，如果配置了多个loader，那么是从后往前执行的
        },
        {
            test: /.png$/,
            use: 'url-loader'
        }
    ]
}
</pre>
再次打包之后我们发现，dist目录下不再有图片文件，打开bundle.js文件，可以看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/10_1.png">
图片文件被转换为base64编码，base64已经包含了文件的内容，就不再需要独立的物理文件了。这种方式比较适合小的资源，因为大的资源会导致文件体积过大。
最佳实践:
·小文件使用Data URLs，减少请求次数
·大文件单独提取存放，提高加载速度
那么如何通过url-loader实现上面的最佳实践呢
<pre>
{
    test: /.png$/,
    use: {
        loader: 'url-loader',
        options: {
            limit: 10 * 1024 //10kb
        }
    }
}
</pre>
超出10kb文件单独提取存放，小于10kb文件转换为Data URLs嵌入代码中。注意如果按照上面的limit方式使用url-loader，就要安装file-loader，因为超出限制的文件，url-loader会调用file-loader
11.webpack常用加载器分类
编译转换类-把资源模块转换为JavaScript代码，例如css-loader
文件操作类-把资源模块拷贝到输出目录，同时将文件的访问路径向外导出，例如file-loader
代码检查类-对加载的资源代码进行校验
12.webpack与ES2015
因为模块打包需要，所以处理import和export，除此之外，并不会转换es6的其他代码特性。如果我们需要webpack对其他es6的特性进行转换，需要配置额外的编译型loader，npm i babel-loader @babel/core @babel/preset-env --save-dev
<pre>
{
    test: /.js$/,
    use: {
        loader: 'babel-loader',
        options: {
            presets: ['@babel/preset-env'] 
        }
    }
}
</pre>
13.webpack加载资源的方式
除了处理import可以触发模块的加载，webpack还提供了其他几种资源加载的方式：
·遵循ES Modules 标准的 import 声明
·遵循CommonJs标准的require函数(如果通过require函数导入一个module，需要注意对esmodule的默认导出，需要导入结果的default属性去获取)
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/13_1.png">
·遵循AMD标准的define函数和require函数
·样式代码中的@import指令和url函数
·HTML代码中图片标签的src属性
以上标准虽然webpack都支持，但是除非必要情况，否则不要混合使用，因为这会大大降低项目的可维护性。
loader加载的非JavaScript也会触发资源加载，样式代码中的@import指令和url函数也会触发相应模块的资源模块的加载。HTML代码中图片标签的src属性也会触发相应模块的加载
<pre>
//main.js
import './main.css'
//main.css
body{
    min-height: 100vh;
    background: #f4f8fb;
    background-image: url(heart.png);
    background-size: cover;
}
</pre>
webpack会用css-loader去打包css文件，但是上面我们加了背景图片，会把这张图片作为一个资源模块加入到打包过程，webpack根据配置文件当中针对我们遇到的文件找到相应的loader。
重新打包启动服务，看到背景图片已经生效了，证明url确实可以触发模块的加载。
<pre>
//main.css
@import url(reset.css)
body{
    min-height: 100vh;
    background: #f4f8fb;
    background-image: url(heart.png);
    background-size: cover;
}
//reset.css
*{
    margin: 0px;
    padding: 0px;
}
</pre>
重新打包启动服务，看到我们在reset.css中写的样式已经在页面生效了。以上是css-loader在加载样式时，样式文件中触发文件加载的两种方式。
下面看html文件加载额外的资源的一些方式
<pre>
//main.js
import './main.css'
import footerHtml from './footer.html'
document.write(footerHtml)
//footer.html
< footer >
    < img src="good.png" alt="good" width="256" >
< /footer >
</pre>
html文件默认会将html代码作为字符串导出，所以需要接收导出的字符串，然后通过document.write输出到页面当中。还要为html模块配置对应的loader，否则webpack不能识别html文件，安装html-loader
<pre>
{
    test: /.html$/,
    use: {
        loader:  'html-loader'
    }
}
</pre>
然后回到终端，重新执行webpack打包命令，启动服务，可以看到图片都可以正常显示，说明html文件中src属性也可以触发资源模块文件的加载。html文件中不止有img的src需要依赖资源，其他标签也有可能需要一些资源的依赖，例如a标签的href属性
<pre>
//main.js
import './main.css'
import footerHtml from './footer.html'
document.write(footerHtml)
//footer.html
< footer >
    < a href="good.png" download="good" >download ping< /a >
< /footer >
</pre>
重新执行webpack打包命令，启动服务，下载图片居然404，因为html-loader默认只处理img标签的src属性，如果其他标签属性也需要出发打包，可以添加相应的一些配置
<pre>
{
    test: /\.html$/i,
    loader: 'html-loader',
    options: {
        attributes: {
            list: [
                {
                    tag: 'img',
                    attribute: 'src',
                    type: 'src',
                },
                {
                    tag: 'a',
                    attribute: 'href',
                    type: 'src',
                },
            ]
        }
    }
}
</pre>
这里我踩到一个坑：Chrome出于安全考虑，禁止从页面打开 Data URI
14.webpack核心工作原理
我们的项目中散落着各种各样的代码和资源文件(js/css/html/png/scss/json...),webpack会根据配置找到文件作为打包入口，一般这个入口会是js文件，然后顺着入口文件的代码，根据代码中的import/require等解析推断这个文件所依赖的资源模块，然后分别解析每个资源模块对应的依赖，最后形成整个项目之间所有依赖关系的依赖树，webpack递归依赖树，找到每个节点所对应的资源文件，根据配置文件中的rules属性找到对应资源的加载器，把资源加载器加载的结果放到打包生成的文件中。loader是webpack的核心
15.webpack 开发一个loader
我们考虑一个需求：markdown-loader，也就是markdown文件加载器，用这个加载器直接在代码中导入markdown文件。
一点点来，首先了解一下loader的输入输出
<pre>
//main.js
import about from './about.md'
console.log(about)
//markdown-loader.js
module.exports = source => { //参数就是我们所加载到的资源文件的内容
    console.log(source)
    return 'hello ~' //输出，就是加工过后的结果
}
//webpack.config.js
{
    test: /\.md$/,
    use: './markdown-loader' // 这里可以用相对路径
}
</pre>
执行webpack命令后得到结果
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/15_1.png">
可以看到，我的md文件的中文已经打印到控制台了，但是为什么还报错呢？因为webpack要求loader最后的输出必须是JavaScript代码，但是我们返回的是字符串
我们稍微作一些修改
<pre>
//main.js
import about from './about.md'
console.log(about)
//markdown-loader.js
module.exports = source => { 
    console.log(source)
    return 'console.log("hello ~")'
}
//webpack.config.js
{
    test: /\.md$/,
    use: './markdown-loader' 
}
</pre>
再次打包就可以看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/15_2.png">
webpack把我们打包的结果直接拼接了，所以如果不返回js代码，语法就可能不通过。先安装一个md文件解析器 npm i marked --save-dev 
<pre>
const marked = require('marked')
module.exports = source => {
    const html = marked(source) //marked直接返回的是html
    return `module.exports = ${JSON.stringify(html)}`
}
</pre>
或者
<pre>
const marked = require('marked')
module.exports = source => {
    const html = marked(source)
    return `export default ${JSON.stringify(html)}`//改了这行，支持ES Modules导出
}
</pre>
也可以就是返回html，再安装一个html-loader去处理
<pre>
//markdown-loader.js
const marked = require('marked')
module.exports = source => {
    const html = marked(source)
    return html
}
//webpack.config.js
{
    test: /\.md$/,
    use: ['html-loader', ./markdown-loader' ]
}
</pre>
16.webpack插件机制介绍
插件机制是为了增强webpack自动化的能力。loader专注实现各种资源模块的加载，plugin解决除了资源加载以外其他自动化工作，例如自动清除打包前的dist目录等
17.webpack 自动清除输出目录插件
npm i webpack-clean-plugin
<pre>
//webpack.config.js
const {CleanwWbpackPlugin} = require('clean-webpack-plugin')
module.exports = {
    plugins:[
        new CleanwWbpackPlugin()
    ]
}
</pre>
18.webpack 自动生成HTML插件(上)
通过webpack生成HTML能省去我们自己手动改变HTML文件中打包路径等问题。安装html-webpack-plugin插件
<pre>
const HtmlWebpackPlugin = require('html-webpack-plugin');
plugins:[
    new HtmlWebpackPlugin()
]
</pre>
在这里，因为之前课程配置的loader我都没有修改，导致报错，因为和babel-loader产生了冲突，解决方案就是
<pre>
{
    test: /.js$/,
    use: {
        loader: 'babel-loader',
        options: {
            presets: ['@babel/preset-env'] 
        }
    },
        exclude: /node_modules/ //就是这一行，因为提示的报错里有与babel-loader冲突的意思
},
</pre>
另外上面配置打包成功之后我们发现生成的index.html中的bundle.js路径还是dist/bundle.js，实际应该是当前目录下bundle.js。这是因为在webpack.config.js中配置了publicPath: 'dist/'，注释掉即可
19.webpack 自动生成HTML插件(中)
指定html模版和模版中的一些内容
<pre>
// src/index.html
< div class="container" >
        < h1 ><%= htmlwebpackplugin.options.title="" %="">< /h1 >
< /div >
//webpack.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin');
plugins:[
    new HtmlWebpackPlugin({
        title:'webpack sample',
        meta:{
            viewport:'width=device-width'
        },
        template:'./src/index.html'
    })
]
</%=></pre>
20.webpack 自动生成HTML插件(下)
同时输出多个页面文件
<pre>
plugins:[
    new HtmlWebpackPlugin({
        title:'webpack sample',
        meta:{
            viewport:'width=device-width'
        },
        template:'./src/index.html'
    }),
    new HtmlWebpackPlugin({
        filename:'about.html',
    })
]
</pre>
21.webpack 插件使用总结
对于项目中不需要参与构建的文件(例如favicon.ico)一般放在public文件夹中，使用 copy-webpack-plugin 处理
其实我这里遇到了问题
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/21_1.png">
当前我电脑webpack版本4.6.0，copy-webpack-plugin 版本6.0.3 ，查到的这个问题产生的原因给的解释都是由于webpack版本和copy-webpack-plugin不匹配产生的问题，也就是要么升级webpack版本要么降低copy-webpack-plugin版本，但是由为了不给我现在工作中的项目造成困扰(我工作中的项目在node 11 情况下安装的依赖，切换到node14就不能正常工作)先不对webpack本地版本进行修改，此处留坑，先赶进度
22.webpack 开发一个插件
相比loader，plugin拥有更宽的能力范围。plugin通过钩子机制实现，webpack留了很多钩子，具体可以查看官方文档。webpack要求插件必须是函数或者包含apply方法的对象
<pre>
//webpack.config.js
class MyPlugin{
    apply(compiler){ //会在webpack启动时自动被调用
        // compiler就是webpack工作中最核心的一个对象，包含了此次构建对象的所有配置信息
        // 我们也是通过这个对象去注册钩子函数
        // 我们的需求是用这个插件清除webpack打包中生成的注释信息
        // API官网找到emit钩子，在webpack往输出目录输出文件时执行
        console.log('MyPlugin')
        compiler.hooks.emit.tap('MyPlugin', compilation => {
            // compilation 可以理解成我们此次打包过程中的上下文
            // 我们所有打包过程中产生的结果都会放到 compilation 对象中
            // assets 获取即将写入的目录中的资源文件信息 
            for(const name in compilation.assets){
                console.log(name)
            }
        })
    }
}
</pre>
然后在plugins中加入MyPlugin插件
<pre>
new MyPlugin()
</pre>
执行打包命令可以看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/22_1.png">
在打包一开始，我们的文件名都被输出了。稍作修改
<pre>
class MyPlugin{
    apply(compiler){ 
        console.log('MyPlugin')
        compiler.hooks.emit.tap('MyPlugin', compilation => {
            for(const name in compilation.assets){
                console.log(compilation.assets[name].source())
            }
        })
    }
}
</pre>
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/22_2.png">
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/22_3.png">
打包文件的内容和html等相关文件等内容被输出了，我们截取了部分展示在这里。下面是我们这次自己写的全部plugin的内容
<pre>
class MyPlugin{
    apply(compiler){ 
        console.log('MyPlugin')
        compiler.hooks.emit.tap('MyPlugin', compilation => {
            for(const name in compilation.assets){
                if (name.endsWith('.js')) {
                    const content = compilation.assets[name].source()
                    const widthoutComments = content.replace(/\/\*\*+\*\//g,'')
                    compilation.assets[name] = {
                        source: () => widthoutComments,
                        size: () => widthoutComments.length // webpack内部要求的必须的方法
                    }
                }
            }
        })
    }
}
</pre>
再次执行打包命令，bundle.js 的注释就被去掉了。通过这个过程我们了解了插件是通过在生命周期的钩子函数中挂载函数扩展实现的。
23.webpack开发体验问题
理想状态：
·通过http-server去预览
·自动编译+自动刷新
·提供source map 支持
对于以上需求，webpack已经有功能实现了，我们一起了解，增强开发体验
24.webpack自动编译
用watch监听变化，然后重新打包，具体用法就是在启动webpack命令的时候，加入watch参数，即 webpack --watch
25.webpack自动刷新浏览器
在全局安装Browsersync，一边监听一边Browsersync刷新浏览器，但是这样一边不断写入磁盘，一边从磁盘读取，开销略大
26.webpack dev server
提供用于开发的http server ，集成自动编译和自动刷新浏览器等功能。不会每次都生成打包的dist目录，把打包结果缓存到内存中。安装之后直接执行webpack dev server 命令即可，还可以webpack dev server --open ，自动打开浏览器，具体见 https://webpack.docschina.org/guides/development/#choosing-a-development-tool
27.webpack dev server 静态资源访问
只要是webpack打包并输出的文件都可以正常被访问到，但是如果一些静态资源也想被访问到serve，就需要额外告诉webpack，方法就是在配置文件中添加对应配置。虽然之前讲过copy-webpack-plugin 可以复制资源到打包文件目录，但是开发阶段使用这个插件效率较低
28.webpack dev server 代理API
webpack dev server 支持配置代理。
目标：将github API 代理到开发服务器
github的其中一个接口https://api.github.com/users
<pre>
devServer: { //开发阶段
    contentBase: './public',
    proxy: {
        '/api': {//需要被代理的请求路径的前缀
            // https://localhost:8080/api/users -> https://api.github.com/api/users
            target: 'https://api.github.com/',
            pathRewrite: { // 实现代理路径的重写，会以正则替换的方式请求路径
                '^/api': '' //把以 /api 开头的代理为 ''
            },
            // 默认使用发起请求端的主机名，服务器会根据主机名判断这个请求属于哪一个网站，把请求指派到对应网站
            // 这里用changeOrigin为true ，使用实际代理请求主机名去发起请求
            changeOrigin: true 
        }
    }
},
</pre>
29.source map 介绍
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/29_1.png">
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/29_2.png">
简单看一下jquery的map文件
version：当前文件所使用的source-map的版本
sources：转换之前源文件的名称，因为有可能是多个文件合并，所以这里是一个数组
names：源代码当中的成员名称。转换之前的变量名(转换的时候通常把有意义的变量名转换为单个字母等用以压缩代码体积)，这里记录的是原始名称
mappings：核心属性，是一个base64-vlq编码的字符串，记录转换之后代码字符与转换之前的对应关系
source map 解决了源代码与运行代码不一致所产生的问题
在source map文件结尾添加一行 //# sourceMappingURL=jquery-3.4.1.min.map 开启服务在浏览器查看的时候，会引入转换之前的文件 
30.webpack 配置 source map
webpack也可以配置source map，由于模式比较多，导致初学者比较懵。
<pre>
devtool: 'source-map'
</pre>
在webpack.config.js中加入上面一行代码，执行webpack命令，可以看到在生成bundle.js的同时也生成了bundle.js.map文件，并且bundle.js文件末尾有 //# sourceMappingURL=bundle.js.map 也就是指向source-map文件
webpack支持12种不同方式，每种方式的效果和效率各不相同
31.webpack eval模式的source map
下面是几种不同source-map模式从四种角度出发的对比
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/31_1.png">
在eval模式下，将每个模块转换过后的代码都放在eval函数中去执行，并且在eval函数执行的字符串最后，通过sourceURL的方式去说明所对应的文件路径，这样浏览器在执行这段代码的时候就知道这段代码所对应的源文件，但是也只能到源文件的程度，并不知道在文件中的具体位置。在这种模式下并不会生成source-map文件。
32.webpack devtool 模式对比(上)
在webpack的配置对象可以是一个数组，每一个数组都是一个单独的打包模式，这样就可以在一次打包过程中执行多个打包任务
<pre>
module.exports = [
{
    entry: './src/main.js',
    output: {
        filename: 'a.js'
    }
},
{
    entry: './src/main.js',
    output: {
        filename: 'b.js'
    }
}
]
</pre>
执行打包命令，就会有两个子任务同时进行，同时生成两个打包结果。
这样我们就可以把devtool的模式组成一个数组，遍历这个数组，生成多个不同的子任务，最后生成打包结果，这样就可以比较每种打包模式的特点
<pre>
const HtmlWebpackPlugin = requrie('html-webpack-plugin')
const allModes = [
'eval',
'cheap-eval-source-map',
'cheap-module-eval-source-map',
'eval-source-map',
'cheap-source-map',
'cheap-module-source-map',
'inline-cheap-module-source-map',
'source-map',
'inline-source-map',
'hidden-source-map',
'nosources-source-map'
]
module.exports = allModes.map(item => {
    return {
        devtool: item,
        mode: 'none',
        entry: './src/main.js',
        output: {
            filename: `js/${item}.js`
        },
        module: {
            rules: [
                test: /\.js$/,
                use: {
                    loader:'bable-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            ]
        },
        plugins: [
            new HtmlWebpackPlugin({
                filename: `${item}.html`
            })
        ]
    }
})
</pre>
执行webpack打包命令之后，就会生成相应的js文件，由于我们把生成的文件都放在js目录下，会比较直观的看到不同结果打包模式的页面
33.webpack devtool 模式对比(下)
eval:只能定位到文件
cheap-eval-source-map:可以定位到文件的行，生成source-map文件，文件被babel等加工过后的结果
cheap-module-eval-source-map:文件没有被babel等加工的结果
eval-source-map:可以定位到文件的行和列，生成source-map文件
cheap-source-map:
cheap-module-source-map:
inline-cheap-module-source-map:
source-map:
inline-source-map:把source-map文件以dataURL嵌入到代码中
hidden-source-map:看不到source-map
nosources-source-map:提供了行列信息，能看到错误位置，但是点击错误看不到源代码，这是为了保护源代码。
34.webpack 选择source map 模式
在开发环境下可选:
cheap-module-eval-source-map——1.老师编写代码每行不会超过80个字符2.代码经过loader转换过后的差异较大3.首次打包速度慢无所谓，重写打包相对较快
生产模式:none——1.source-map会暴露源代码2.调试是开发阶段的事
选择没有绝对，理解不同模式差异，适配不同环境
35.webpack自动刷新的问题
webpack-dev-server 提供对开发者友好的开发服务器。但是每次都是刷新页面。如何在页面不刷新的前提下，模块也可以及时更新。
36.webpack HMR 体验
Hot Module Replacement 模块热替换，在应用运行过程中实时替换某个模块，应用状态不受影响
37.webpack 开启 HMR
HMR已经集成在webpack-dev-server当中，不需要单独安装，在运行webpack-dev-server --hot 通过hot参数启动hmr
<pre>
const webpack = require('webpack')
devServer: {
    hot: true 
},
plugins: [
new webpack.HotModuleReplacementPlugin()
]
</pre>
经过上面的配置，只需直接执行webpack-dev-server，无需再添加参数。但是这里我们发现，只有样式文件实现了热更新，修改js文件页面还是刷新了
38.webpack HMR疑问
webpack的HMR并不可以开箱即用，也就是说HMR还需要一些额外的操作才可以使用。样式文件可以开箱即用是因为loader(这里可以说是style-loader)帮我们做了处理。而对于js文件非常复杂，所以没有统一规律可循，所以没有统一的HMR，但是在框架下(比如vue react)相当于有了规则，就比较容易做到热更新了。通用脚手架创建的项目内部都集成了HMR方案。
总结：我们需要手动处理JS模块更新后的热替换。
39.webpack 使用 HMR API
由于main.js是入口，所有模块都是从这里导入/更新，所以在这处理热替换
<pre>
// accept用于我们某一个模块更新过后的处理函数
// 参数依次是 依赖模块的路径，依赖更新过后的处理函数
module.hot.accept('./editor', () => {
    console.log('editor模块更新了，需要手动处理热替换逻辑')
})
</pre>
由于这我们手动处理了editor的刷新，就不会再自动触发刷新，否则会触发自动刷新。
40.webpack处理js模块热替换
<pre>
// editor.js
export default () => {
    const editorElement = document.createElement('div')
    editorElement.contentEditable = true
    editorElement.id = 'editor' //添加了一行
    console.log('editor init completed')
    return editorElement
}
// main.js
import createEditor from './editor'
const editor = createEditor()
document.body.appendChild(editor)
let lastEditor = editor
module.hot.accept('./editor', () => {
    const value = lastEditor.innerHTML //保存上次元素中的内容
    document.body.appendChild(lastEditor)
    const newEditor = createEditor()
    newEditor.innerHTML = value // 模块热更新后将元素内容放回到模块中
    document.body.appendChild(newEditor)
    lastEditor = newEditor
})
</pre>
以上仅仅是div元素简单内容的热替换，但是如果元素更多更复杂，那么替换的方式就更不能确定，所以webpack无法提供一个通用的替换方式
41.webpack处理图片模块热替换
<pre>
module.hot.accept('./better.png', () => {
    img.src = background //background就是更新过后的路径
})
</pre>
这里简单介绍了HMR相关的，具体要不要使用要看开发者的需要，但是一般对于需要持续维护的项目，很多时候利大于弊。
42.webpack HMR 注意事项
·处理HMR的代码报错会导致自动刷新
我们代码手误写错了，依旧自动刷新导致我们不能正确发现错误
<pre>
devServer: {
    hotOnly: true // 换一种方式
}
</pre>
·没启用HMR的情况下，HMR API 报错
没有在plugin中开启new webpack.HotModuleReplacementPlugin()
<pre>
if(mdoule.hot){ //判断是否存在
    module.hot.accept('./better.png', () => {
        img.src = background 
    })
}
</pre>
·代码中多了一些与业务无关的代码
不会影响生产环境的状态
43.webpack生产环境优化
上面我们引入越来越多的代码，虽然产生了更好的开发体验，但是也会造成代码的臃肿。webpack为了实现这些特性，会自动往打包结果中添加一些额外的内容，但是这些额外的代码对生产环境来讲，是冗余的，因为生产环境和开发环境有很大差异。生产环境注重运行效率，开发环境只注重开发效率。所以webpack4出现了mode模式的用法，为不同模式设置了一些预设的配置，同时webpack推荐为不同的环境创建不同的配置
44.webpack不同环境下的配置
·配置文件根据环境不同导出不同的配置
·一个环境对应一个配置文件
<pre>
const path = require('path')
const webpack = require('webpack')
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');
module.exports = (env, argv) => { //env是通过cli传递的环境参数，argv是运行cli过程中接收到的所有参数
    const config = {
        // 配置
        mode: 'development',
        entry: './src/main.js',
        output: {
            filename: 'bundle.js',
            path: path.join(__dirname, 'dist'),
        },
        devServer: {
            hot: true 
        },
        devtool: 'source-map',
        module: {
            rules: [
                {
                    test: /.js$/,
                    use: {
                        loader: 'babel-loader',
                        options: {
                            presets: ['@babel/preset-env'] 
                        }
                    },
                       exclude: /node_modules/
                },
                {
                    test: /\.css$/,//正则表达式，匹配打包过程中的文件路径
                    use: [
                    'style-loader',
                    'css-loader'
                    ]//匹配所需要的loader
                    //注意，如果配置了多个loader，那么是从后往前执行的
                },
                {
                    test: /.png$/,
                    use: {
                        loader: 'url-loader',
                        options: {
                            limit: 10 * 1024 //10kb
                        }
                    }
                },
                {
                    test: /\.md$/,
                    use: './markdown-loader' // 这里可以用相对路径
                }
            ]
        },
        plugins:[
            new CleanWebpackPlugin(),
            new HtmlWebpackPlugin({
                title:'webpack sample',
                meta:{
                    viewport:'width=device-width'
                },
                template:'./src/index.html'
            }),
            new webpack.HotModuleReplacementPlugin()
        ]
    }
    if (env === 'production') {
        config.mode = 'production'
        config.devtool = false
        config.plugins = [
            ...config.plugins,
            new CleanWebpackPlugin(),
            //new CopyWebpackPlugin({patterns: [ //这里我自己的文件打包是有问题的
            //        { from: './public', to: 'dist' }
            //    ]
            //})
        ]
    }
    return config
}
</pre>
45.webpack不同环境的配置文件
上面通过不同环境名参数配置不同对象只适用于中小型项目，因为随着项目的变大，配置文件也变得复杂起来。对于大型项目建议使用不同环境对应不同配置文件的方式来实现。一般这种情况会有三个不同文件，一个生产环境、一个开发环境、一个公共文件。对于不同环境的配置文件的合并，建议用webpack-merge
46.webpack DefinePlugin
webpack4新增的production模式下面内部开启了很多通用的优化功能，对于使用者而言非常方便，但是对于学习者就导致我们忽略很多需要了解的东西。我们先从DefinePlugin了解开始
DefinePlugin为代码注入全局成员，在production模式下默认启用，并且往代码中注入了process.env.NODE_ENV
<pre>
//webpack.config.js
const webpack = require('webpack')
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    plugins: [
        new webpack.DefinePlugin({
            // 参数是一个对象，对象中每个键值都会被注入到代码中
            API_BASE_URL: 'https://www.example.com',//定义了API_BASE_URL，为我们代码注入API服务地址
        })
    ]
}
//main.js
console.log(API_BASE_URL)
</pre>
执行webpack打包命令之后可以看到如下结果
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/46_1.png">
看到definePlugin就是直接把我们定义的值注入了代码当中，我们设置的值的内容就是https://www.example.com 这个字符串，字符串中并没有包含引号，所以替换进来是没有引号的，语法上就有问题
<pre>
//webpack.config.js
const webpack = require('webpack')
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    plugins: [
        new webpack.DefinePlugin({
            // 键我们自己定义了，值其实要求是js代码片段，所以https://www.example.com字符串需要加引号
            API_BASE_URL: '"https://www.example.com"',
        })
    ]
}
</pre>
再次打包之后，就可以看到我们想要的结果。这里还有一个小技巧
<pre>
API_BASE_URL: JSON.stringify('https://www.example.com'),
</pre>
这个代码可以为我们注入一些可能会发生变化的值
47.webpack体验Tree Shaking
"摇"掉代码中未引用的部分，也就是"摇掉"未引用代码(dead code)
<pre>
// components.js
export const Button = () => {
    return document.createElement('button');
    console.log('dead-code')
}
export const Link = () => {
    return document.createElement('a');
}
export const Heading = level => {
    return document.createElement('h'+level);
    console.log('dead-code')
}
// main.js
import {Button} from './components'
document.body.appendChild(Button())
</pre>
这里我们在main.js只引用了components.js中的Button，另外的link和heading都没有被引用，执行打包命令之后看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/47_1.png">
未被引用的link和heading代码都没有被输出，这就是tree-shaking的效果，并且tree-shaking会自动在生产模式开启
48.webpack使用Tree Shaking
Tree Shaking不是一个配置选项，是一组功能搭配使用后的优化效果，会在production模式下自动启用。还是我们上节课的例子，我们直接在none模式下打包，可以在打包结果中看到
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/48_1.png">
不管我们在别的地方是否用到了，components.js中所有组件都被打包到bundle.js中。我们修改一下webpack.config.js
<pre>
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    optimization:{  //在这里集中配置webpack的优化功能
        usedExports: true, //只导出在外部使用的成员
    }
}
</pre>
再次打包
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/48_2.png">
可以看到在main.js没有被引用的Link、Heading组件的变化，就没有被打包了。再加一个压缩功能
<pre>
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    optimization:{  //在这里集中配置webpack的优化功能
        usedExports: true, //只导出在外部使用的成员，负责标记未被使用到的代码
        minimize: true, // 代码压缩，负责去掉未被使用的代码
    }
}
</pre>
再次打包之后，bundle.js中未被引用的代码就都被移除掉了
49.webpack合并模块
除了上节课讲的，我们还可以用concatenateModules来继续优化输出。普通打包结果将每一个模块放到一个单独的函数当中，如果模块很多，输出结果中会有很多模块函数
<pre>
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    optimization:{ 
        usedExports: true,
        concatenateModules: true,
        // minimize: true, // 为了更好的看到结果，这里先注释掉
    }
}
</pre>
concatenateModules的作用是尽可能将所有模块合并到一个输出函数中。 既提升了运行效率，又减少了代码体积。这个特性又被称之为scope hoisting，也就是作用域提升
50.webpack tree shaking与babel
tree shaking 的实现前提就是使用ES Modules，由webpack打包的代码必须使用ESM。webpak在打包之前先是将模块根据不同的配置交给loader去处理，最后将所有loader处理的结果打包到一起。为了转换打包代使用的ES6+的新特性，很多时候需要使用babel-loader，而babel会将ESmodules转换为commonJS，当然这取决于我们有没有使用转换ESModules的插件，例如@babel/preset-env就会将ESModules -> commonJS ，所以这时候tree-shaking就不能生效。这里我们在webpack.config.js中仅开启usedExports: true ，但是打包之后发现tree shaking并没有失效，未被使用的代码并没有被打包进来，这是因为最新的babel-loader中自动帮我们关闭了ESMoudules-commonJS。可以在@babel/preset-env中强制开启esmodules 转commonjs 尝试下
<pre>
module: {
    rules: [
        {
            test: /.js$/,
            use: {
                loader: 'babel-loader',
                options: {
                    presets: [
                        ['@babel/preset-env', {modules: 'commonjs'}]
                    ] 
                }
            },
            exclude: /node_modules/
        }
    ]
}
</pre>
打包之后发现tree-shaking确实失效了，如果想确保tree-shaking不失效，那么
<pre>
presets: [
    ['@babel/preset-env', {modules: false}]
]
</pre>
51.webpack sideEffects
sideEffects 允许我们通过配置的方式标识代码是否有副作用——模块执行时除了导出成员之外所做的事情。sideEffects一般用于npm包标记是否有副作用。在配置的时候，要先在webpack.config.js中设置sideEffects: true开启这个功能，在package.json中配置sideEffects标识代码没有副作用
<pre>
//webpack.config.js
module.exports = {
    mode: 'none',
    entry: './src/main.js',
    output: {
        filename: 'bundle.js'
    },
    optimization:{ 
        usideEffects: true,
    }
}
//package.json
{
    "name": "sideEffects",
    "version": "0.1.0",
    ...
    "sideEffects": false
}
</pre>
52.webpack sideEffects 注意
使用sideEffects的前提就是确定你的代码真的没有副作用，对于一些css模块等都会被看作是副作用，或者原型链添加一些方法等，都会被移除掉。如果不想这些代码被移除。解决办法就是在package.json中关掉副作用，或者标识一下哪些文件有副作用
<pre>
//package.json
{
    "name": "sideEffects",
    "version": "0.1.0",
    ...
    "sideEffects": [
        './src/extend.js',
        '*.css'
    ]
}
</pre>
53.webpack代码分割
webpack将所有代码打包到一起，打包结果bundle体积过大。在实际项目中，并不是所有模块在启动时都是必要的，那么就有一个按需加载的需求。代码分割可以通过多入口的打包方式或者通过动态导入的方式
54.webpack多入口打包
多入口打包一般适用于传统的多页应用程序，最常见的话的规则就是一个页面对应一个打包入口，公共部分单独提取，项目具体就不在这里写了，简单的两个页面，然后在main.js中引入、处理。下面主要写一下webpack.config.js的配置
<pre>
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
    mode: 'none',
    entry: { //注意这里只有写成对象才能打包成多个文件，写成数组只会打包成一个文件
        './src/index.js',
        './src/album.js'
    },
    output: {
        filename: '[name].bundle.js',
        path: path.join(__dirname, 'dist')
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                'style-loader',
                'css-loader'
                ]
            }
        ]
    },
    plugins:[
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'multi entry 1',
            template:'./src/index.html',
            filename: 'index.html'
        }),
        new HtmlWebpackPlugin({
            title:'multi entry 2',
            template:'./src/album.html',
            filename: 'album.html'
        })
    ]
}
</pre>
上面的配置能完成然后执行打包命令，就能在输出文件夹中看到两个打包结果，但是我们会发现，两个打包结果被同时被引入输出的html文件
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/54_1.png">
所以需要对webpack.config.js进行简单的修改
<pre>
plugins:[
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
        title:'multi entry 1',
        template:'./src/index.html',
        filename: 'index.html',
        chunk: ['index']
    }),
    new HtmlWebpackPlugin({
        title:'multi entry 2',
        template:'./src/album.html',
        filename: 'album.html',
        chunk: ['album']
    })
]
</pre>
55.webpack提取公共模块
<pre>
optimization:{ 
    splitChunks: {
        chunks: 'all'
    }
}
</pre>
56.webpack 动态导入
webpack支持动态导入的方式实现按需加载，动态导入的模块会被自动分包。
我们需要注释掉页面一开始就import 模块，而在需要使用模块的地方再执行import
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/56_1.png">
打包结果会有两个动态导入的模块和提取的公共代码
57.webpack 魔法注释
默认通过动态导入产生的bundle文件只是一个序号，如果需要命名，就通过webpack的魔法注释去实现
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/57_1.png">
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/57_2.png">
如果使用了相同的chunkname，那么相同chunkname的模块就会被打包到一起
58.webpack MiniCssExtractPlugin
MiniCssExtractPlugin可以提取css到单个文件，首先安装，然后在webpack.config.js中引入，再注册到plugin中
<pre>
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                //由于使用了MiniCssExtractPlugin，css被单独存放于文件中
                //不需要style标签，而是直接通过link引入，所以不再需要style-loader
                //'style-loader',
                //通过MiniCssExtractPlugin提供的loader去用link引入样式
                MiniCssExtractPlugin.loader,
                'css-loader'
                ]
            }
        ]
    },
    plugins:[
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'multi entry 1',
            template:'./src/index.html',
            filename: 'index.html',
            chunk: ['index']
        }),
        new HtmlWebpackPlugin({
            title:'multi entry 2',
            template:'./src/album.html',
            filename: 'album.html',
            chunk: ['album']
        }),
        new MiniCssExtractPlugin()
    ]
}
</pre>
如果css文件很小，比如小于150kb，那么直接嵌入代码中减少一次请求更好，大于一定值通过link标签加载引入才有价值
59.webpack OptimizeCssAssetsWebpackPlugin
webpack对于生产模式的打包，仅支持js文件的压缩，剩下的压缩都需要额外的插件支持。OptimizeCssAssetsWebpackPlugin压缩输出的css文件
<pre>
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                MiniCssExtractPlugin.loader,
                'css-loader'
                ]
            }
        ]
    },
    plugins:[
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'multi entry 1',
            template:'./src/index.html',
            filename: 'index.html',
            chunk: ['index']
        }),
        new HtmlWebpackPlugin({
            title:'multi entry 2',
            template:'./src/album.html',
            filename: 'album.html',
            chunk: ['album']
        }),
        new MiniCssExtractPlugin(),
        new OptimizeCssAssetsWebpackPlugin()
    ]
}
</pre>
上面我们直接把OptimizeCssAssetsWebpackPlugin放到了plugin中，但是webpack官方的建议是放到optimization.minimizer中，是因为可以通过minimizer统一控制，在生产模式minimizer自动开启
<pre>
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                MiniCssExtractPlugin.loader,
                'css-loader'
                ]
            }
        ]
    },
    optimization: {
        minimizer: [
            new OptimizeCssAssetsWebpackPlugin()
        ]
    },
    plugins:[
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'multi entry 1',
            template:'./src/index.html',
            filename: 'index.html',
            chunk: ['index']
        }),
        new HtmlWebpackPlugin({
            title:'multi entry 2',
            template:'./src/album.html',
            filename: 'album.html',
            chunk: ['album']
        }),
        new MiniCssExtractPlugin()
    ]
}
</pre>
但是这样配置，minimizer认为我们要自定义所使用的插件，没有要求js压缩，内置的js压缩器就会被覆盖掉，所以js文件不会自动被压缩
<pre>
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
const TerserWebpackPlugin = require('terser-webpack-plugin')
module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                MiniCssExtractPlugin.loader,
                'css-loader'
                ]
            }
        ]
    },
    optimization: {
        minimizer: [
            new TerserWebpackPlugin(), //webpack内置js压缩plugin
            new OptimizeCssAssetsWebpackPlugin()
        ]
    },
    plugins:[
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'multi entry 1',
            template:'./src/index.html',
            filename: 'index.html',
            chunk: ['index']
        }),
        new HtmlWebpackPlugin({
            title:'multi entry 2',
            template:'./src/album.html',
            filename: 'album.html',
            chunk: ['album']
        }),
        new MiniCssExtractPlugin()
    ]
}
</pre>
60.webpack输出文件名hash
服务器在部署前端文件的时候，都会启用静态资源缓存，这样对于用户浏览器就能缓存静态资源，后续就不用请求这些资源，提升了响应速度。但是开启了缓存，如果设定缓存时间过长，更新不及时；如果设定时间过短，效果不明显。所以建议在生产模式下，给文件名增加hash值，一旦资源文件发生改变，文件名也发生了变化。对于客户端，全新的文件名就是全新的请求，可以把缓存的时间设置的非常长。
项目级的hash，一旦项目中有任何改动，项目中的hash就会跟着一起改动
<pre>
//本节课的代码重点放在哪里可以带hash，至于文件目录级别是否在一起，并没有特意匹配
output: {
    filename: '[name]-[hash].bundle.js'
}
new MiniCssExtractPlugin({
    filename: '[name]-[hash].bundle.css'
})
</pre>
chunkhash在打包过程中，只要是同一路(比如一个文件的css/js是同一路的)的打包，chunkhash都是相同的
<pre>
output: {
    filename: '[name]-[chunkhash].bundle.js'
}
new MiniCssExtractPlugin({
    filename: '[name]-[chunkhash].bundle.css'
})
</pre>
<img src="https://snakexu.github.io/images/lagou/part_2/webpack/60_1.png">
可以看到同一路的hash名是一致的
contenthash，文件级别的hash，根据输出文件的内容输出的hash，也就是不同的文件就有不同的hash
<pre>
output: {
    filename: '[name]-[contenthash].bundle.js'
}
new MiniCssExtractPlugin({
    filename: '[name]-[contenthash].bundle.css'
})
</pre>
另外，如果觉得默认的20位长度的hash太长，还可以指定hash长度
<pre>
output: {
    filename: '[name]-[contenthash:8].bundle.js'
}
new MiniCssExtractPlugin({
    filename: '[name]-[contenthash:8].bundle.css'
})
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/17/拉勾-Webpack打包/" data-id="ckdbzsiui0062jrxq24k2alou" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-模块化开发" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/15/拉勾-模块化开发/" class="article-date">
  <time datetime="2020-07-15T04:16:48.000Z" itemprop="datePublished">2020-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/15/拉勾-模块化开发/">拉勾-模块化开发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.模块化概述<br>内容概要<br>·模块化演变过程<br>·模块化规范<br>·常用的模块化打包工具<br>·基于模块化工具构建现代web应用<br>·打包工具的优化技巧<br>2.模块化演变过程<br>stage-1.文件划分方式<br>每个文件一个功能，通过script标签引入，容易形成全局变量等，早起模块化完全依靠约定<br>stage-2.命名空间方式<br>约定每一个模块暴露一个全局对象，所有模块成员挂载到全局对象上。将每个模块包裹成一个全局对象的方式<br>stage-3.IIFE<br>前两种方式都没有实现私有成员，IIFE的实现方式就是<br><img src="https://snakexu.github.io/images/lagou/part_2/modular/2_1.png"><br>并且可以清楚的看到引用依赖(可以作为参数传入)<br>以上是早起在没有工具和规范的情况下，对模块化的落地方式<br>3.模块化规范的出现<br>虽然有了模块化的雏形，但是还有很多问题，我们依然通过script标签引入，这样就很容易在加载大量文件的时候出现各种问题，比如少引入文件等。这时发现我们需要模块化标准+模块化加载器。<br>在nodejs中模块化标准为commontjs规范，在这个规范中约定<br>·一个文件就是一个模块<br>·每个模块都有单独的作用域<br>·通过module.exports导出成员<br>·通过require函数载入模块<br>commonJs是以同步方式加载模块，这种加载方式在node是没什么问题的，但是前端如果采用同步加载，容易产生很多问题，所以为浏览器端制定了A(Asynchronous)M(Module)D(Definitino)规范，同期推出Require.目前绝大多数第三方库都支持AMD规范。AMD使用起来相对复杂，模块js文件请求频繁。此外还有淘宝团队的sea.js+CMD等<br>4.模块化标准规范<br>目前浏览器统一使用ESModules实现模块化规范，nodeJs使用CommonJs实现模块化规范。但是要注意，ESModules是ECMAScript2015也就是俗称的ES6才被定义的标准，会产生兼容问题，目前一部分浏览器已经兼容了，但是随着webpack等工具的出现，这一规范已经比较普及了。<br>5.ES Modules特性<br>可以从两个维度学习<br>(1)作为一个标准/规范，约定了哪些特性和语法<br>(2)如果通过一些工具/方案解决运行环境中兼容性带来的问题<br>通过给script标签添加type=module的属性就可以以ES Module的标准执行其中的JS代码了</p>
<pre>
< script type="module" >
    console.log('this is es module')
< /script >
< script type="module" >
    var foo = 100;
    console.log(foo)//可以正常打印
< /script >
< script type="module" >
    console.log(foo) //报错
< /script >
</pre>
上面的代码可以正常在浏览器中执行了，但是对于普通js会有一些不同:
(1)ESM 自动采用严格模式，忽略'use strict'(比如在严格模式下不能全局使用this)
(2)每个ESMdoules都是运行在单独的私有作用域中
(3)ESModules是通过CORS方式请求外部  如果js模块不在同源地址下，就需要请求的服务端地址在响应的响应头必须提供有效的CORS标头
(4)ESM的script标签会延迟执行脚本    
6.ES Modules导出
导入:import，导出:export
<pre>
export const name = "xiaoming"
export function hello (){
    console.log('hello')
}
export class Person{}
//or
const name = "xiaoming"
function hello (){
    console.log('hello')
}
class Person{}
export {name, person, hello}
//or 重命名方式
export{
    name as fullName,
    hello as fullHello
}
</pre>
要注意，导出的成员如果定义名称为default，那么这个成员就会作为当前模块默认的导出成员，导入这个成员的时候，就必须给这个成员命名，default是一个关键词，我们不能把它当作变量使用。也可以export default name，在导入时候直接import一个变量名的方式默认导入一个成员
7.ES Modules导入导出的注意事项
<pre>
export { name, age } //不同于字面量，这里只是export的语法
export default { name, age } //这里是对象字面量的范围 export default 可以跟一个变量，也可以跟一个值
</pre>
同样，import 导入的时候，也不是解构，只是一个import的用法
export导出成员的时候导出的是对这个成员的一个引用
<pre>
//module.js
var name = 'jack'
var age = 18
export { name, age }
setTimeout(function(){
    name = 'ben'
},1000)
//app.js
import { name, age } from './module.js'
console.log(name, age) //jack 18
setTimeout(function(){
    console.log(name, age) //age 18
},1500)
</pre>
但是暴露出来的关系是只读的，也就是说不能在模块外部修改成员
<pre>
//module.js
var name = 'jack'
var age = 18
export { name, age }
setTimeout(function(){
    name = 'ben'
},1000)
//app.js
import { name, age } from './module.js'
console.log(name, age) //jack 18
name = 'tom' //报错，因为暴露出来的关系是只读的
setTimeout(function(){
    console.log(name, age)
},1500)
</pre>
8.ES Modules导入用法
原生的import引入文件的时候
(1)不能简写扩展名，比如引入module.js，必须写成 import { name } from './module.js'，不能写成import { name } from './module'
(2)如果引入的是index.js，也不能省略index.js，比如 import {lowercase} from './utils/index.js' 不能写成 import {lowercase} from './utils'
(3)支持文件路径方式 './' '/' 'http://'，也就是说支持相对路径、绝对路径引入
(4)import {} from  './module.js' 是执行模块，不需要提取模块中的成员，简写语法 import './module.js'
(5)import * as mod from './modules'导入模块中所有被导出成员，被放入mod对象中，每一个导出成员都是mod对象的一个属性
(6)需要动态导入模块(就是路径不确定的情况)，不能 import {name} from 变量 。es module 提供了一个全局的函数 import 用来动态导入模块。用法 import(需要导入模块的路径)，这里的import返回一个promise
<img src="https://snakexu.github.io/images/lagou/part_2/modular/8_1.png">
(7)如果在同一个模块中导出了一些命名成员和一个默认成员，可以正常导入命名成员，再用default as 重命名 的方式导入默认成员，或者用逗号分隔，逗号左边是默认成员，右边是命名成员
<pre>
import {name, age, default as title } from './module.js'
import title, {name, age } from './module.js' //用逗号分隔方式引入默认成员，title为默认成员的别名
</pre>
9.ES Modules导入导出成员
直接把导入成员作为当前模块的导出成员，那么在当前作用域中不能访问这些成员，一般用来写index文件，导出成员给外部使用
<pre>
export {foo, bar} from './module.js'
console.log(foo,bar)
</pre>
10.ES Modules 浏览器环境Polyfill
我们可以通过ES Module Loader 去解决浏览器不支持es语法的问题，可以在unpkg.com提供的cdn服务来拿到js文件。ES Module Loader的用法可以看相关介绍，另外由于在最新IE中不支持promise，我们需要引入一个promise的polyfill。如果我们正常在html页面中引入上面提到的polyfill会导致支持esmodule的浏览器执行两遍代码，一遍是浏览器执行的，另外一遍是polyfill执行的，可以用script的nomodule的属性，这个属性只有在不支持esmodule语法的情况下才执行
<pre>
< script type="nomodule" >
alert('123')//只有在不支持esmodule语法的浏览器才会弹出123(IE说，别看我，我不支持我也没办法)
< /script >
但是nomodule属性在运行的时候是动态解析脚本，效率会比较差，不适宜在生产阶段使用
</pre>
11.ES Modules in Node.js 支持情况
node的8.5以上版本已经以实验的特性开始支持ES Module的语法了。要在node环境中使用ES Module，首先要把扩展名的js改为mjs，然后在命令行当前目录下输入node --experimental-modules index.mjs (这里index.mjs为文件名) ，node会提示这是实验特性，不要在生产环境使用
第三方模块都是导出默认成员，不能 import {toLowerCase} from 'lodash'，但是node官方模块因为做了兼容，可以这么使用 
12.ES Modules in Node.js 与commonjs模块交互
<pre>
//按ES Module标准编写的es-module.mjs
import mod from './commonjs.js'
console.log(mod)
//按commonjs标准编写的commonjs.js
module.exports = {
    foo: 'commonjs exports value'
}
</pre>
然后在命令行执行 node --experimental-modules es-module.mjs ，可以看到在命令行中输出 { foo: 'commonjs exports value'} (之前会提示ExperimentalWarning: The ESM module loader is experimental) 。这说明我们可以在ES Module中载入CommonJs的成员。也可以写成
<pre>
//按ES Module标准编写的es-module.mjs
import mod from './commonjs.js'
console.log(mod)
//按commonjs标准编写的commonjs.js
exports.foo = 'commonjs exports value'
</pre>
要注意，在ESModules中引入commonJs标准的成员，commonJs始终只会导出一个默认成员，也就是说如果按照下面的方式是执行，命令行是会报错的
<pre>
//按ES Module标准编写的es-module.mjs
//注意，不能直接提取成员，注意import不是解构导出对象
import {mod} from './commonjs.js'
console.log(mod)
//按commonjs标准编写的commonjs.js
exports.foo = 'commonjs exports value'
</pre>
上面我们用ESModule载入了CommonJs，如果我们用CommonJs载入ESModule呢？try 一下
<pre>
//按ES Module标准编写的es-module.mjs
export const foo = 'es module export value'
//按commonjs标准编写的commonjs.js
const mod = require('./es-module.mjs')
console.log(mod)
</pre>
在命令行中执行 node --experimental-modules commonjs.js ，会报错。可以得出不能在CommonJs模块中通过require载入ESModule
以上都是在node原生环境中执行的，如果用webpack打包工具等，执行结果可能会不一样
结论：
·ES Modules 中可以导入 CommonJs 模块
·CommonJs 中不能导入 ES Modules 模块
·CommonJs 始终只会导出一个默认成员
·注意import不是解构导出对象
13.ES Modules in Node.js 与commonjs模块的差异
<pre>
//cjs.js CommonJs 标准写的 
//单独执行node --experimental-modules cjs.js 是可以执行的
//加载模块函数
console.log(require)
//模块对象
console.log(module)
//导出对象别名
console.log(exports)
//当前文件的绝对路径
console.log(__filename)
//当前文件所在目录
console.log(__dirname)
//esm.mjs ES Modules标准写的
//执行 node --experimental-modules esm.mjs 会报错
console.log(require)
console.log(module)
console.log(exports)
console.log(__filename)
console.log(__dirname)
</pre>
可以看出ESM中没有CommonJs中的那些模块的全局成员了
ESModules中有一个fileURLToPath方法，我们可以通过这个方法去获取文件路径
<pre>
import {fileURLToPath} from 'url'
import {dirname} from 'path'
const __filename = fileURLToPath{import.meata.url}
console.log(__filename)
const __dirname = dirname(__filename)
console.log(__dirname)
</pre>
<img src="https://snakexu.github.io/images/lagou/part_2/modular/13_1.png">
14.ES Modules in Node.js 新版本进一步支持ESM
先把node切换到12.10.0的版本，并且确定没有任何问题，打开项目中的package.json文件，写入
<pre>
{
    "type":"module"
}
</pre>
然后把我们改成.mjs扩展名的文件改会.js扩展名，执行node --experimental-modules index.js 是可以执行的。但是如果我们执行commonjs的文件，需要把扩展名改为.cjs
15.ES Modules in Node.js Babel兼容方案
早日的nodejs版本，我们可以用Babel去实现ESModules的兼容，因为是低版本node，所以我们切换node版本为8.0.0，yarn add @babel/node @babel/core @babel/preset-env --dev，然后就可以通过yarn babel-node去运行这个命令，但是直接运行这个命令会报错，因为babel的preset-env是预设高版本js的转换，所以执行命令的正确姿势是yarn babel-node index.js --presets=@babel/preset-env，如果觉得每次都加入presets比较麻烦，可以在文件中添加.babelrc文件，然后在文件中写入
<pre>
{
    "presets": ["@babel/preset-env"]
}
</pre>
然后就可以直接通过yarn babel-node index.js运行了
或者也可以通过一个单独的插件yarn add @babel/plugin-transform-modules-commonjs --dev，然后修改.babelrc文件
<pre>
{
    "plugins": ["@babel/plugin-transform-modules-commonjs"]
}
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/15/拉勾-模块化开发/" data-id="ckdbzsilu004kjrxqmdwzhze7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-自动化构建" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/08/拉勾-自动化构建/" class="article-date">
  <time datetime="2020-07-07T19:48:07.000Z" itemprop="datePublished">2020-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/08/拉勾-自动化构建/">拉勾-自动化构建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.自动化构建简介(一切重复工作本应自动化)<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/1_1.png"><br>上图中的自动化构建是在自动化构建工作流，作用是运行环境兼容带来的问题，使用提高效率的语法、规范和标准。例如ECMAScript Next、scss、模版引擎等这些好用的工具都不能直接在浏览器中使用，自动化构建工具就可以派上用场了，可以把这些不被支持的代码特性转换为可支持的代码，提高编码效率<br>2.自动化构建初体验<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/2_1.png"><br>从上面的直接编写css代码到下图用scss编写再构建成普通css<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/2_2.png"><br>我们可以按照上面两张图来先创建一个项目，用css编写，再删除css文件，编写scss文件，安装sass模块(yarn add scss –dev)，安装完成后，在node_modules文件夹里就能看到.bin目录，这样我们就可以用sass编译我们刚刚写到scss文件了，在命令行中输入.\node_modules\.bin\sass，执行完这个命令就会看到这条命令的用法，即.\node_modules\.bin\sass 输入路径 输出路径，执行这条命令之后，就可以看到编译过后的scss文件-&gt;css文件，并且文件中还帮我们做了sourcemap。但是如果在开发过程中我们经常这样输入命令，就显得有些麻烦，而且别人也可能不知道你的项目有哪些命令，怎么用这些命令，那么NPM Scripts 就是用来解决这些问题的，在package.json文件中添加如下</p>
<p><pre><br>“scripts”: {<br>    “build”: “sass scss/main.scss css/style.css”<br>},<br></pre><br>scripts 可以自动发现node_modules文件夹中的执行命令，我们不用再写完整路径，然后就可以通过npm/yarn启动这个命令。这里我们再安装一个browser-sync的模块来启动测试服务器运行我们的项目，添加启动服务器的命令</p>
<p><pre><br>“scripts”: {<br>    “build”: “sass scss/main.scss css/style.css”,<br>    “serve”: “browser-sync .”//认真的说这条才是启动服务器的命令<br>},<br></pre><br>这时执行yarn serve命令就可以启动服务打开浏览器，但是我们可以添加preserve命令帮我们先执行build命令，这样更加简化项目执行</p>
<p><pre><br>“scripts”: {<br>    “build”: “sass scss/main.scss css/style.css –watch”,//–watch监听文件的变化，一旦发生变化就自动编译<br>    “preserve”:”yarn build”,//自动在serve执行之前执行<br>    “serve”: “browser-sync .”//认真的说这条才是启动服务器的命令<br>},<br></pre><br>当我们加了–watch之后再启动就发现，sass就阻塞在了监听的地方，去等待文件发生变化，此时我们需要借助npm-run-all去同时执行多个任务，yarn add npm-run-all –dev 安装这个模块</p>
<p><pre><br>“scripts”: {<br>    “build”: “sass scss/main.scss css/style.css –watch”,<br>    “serve”: “browser-sync .”,<br>    “start”: “run-p build serve”//通过run-p去同时执行build和serve，源于安装了npm-run-all<br>},<br></pre><br>再次升级</p>
<p><pre><br>“scripts”: {<br>    “build”: “sass scss/main.scss css/style.css –watch”,<br>    “serve”: “browser-sync . –files \”css/*\””,//–files参数让browser-sync去监听项目文件下的一些变化，一旦文件发生变化，自动同步到浏览器<br>    “start”: “run-p build serve”<br>},<br></pre><br>3.常用的自动化构建工具<br>目前市面上使用最多的自动化构建工具是grunt/gulp/fis等<br>grunt:出现最早，插件生态非常完善，由于工作过程是基于临时文件去实现的(磁盘读写)，所以构建速度比较慢<br>gulp:基于内存，构建速度相对较快，默认支持同时执行多个任务，插件生态比较完善<br>fis:百度内部使用，后来开源，把项目中典型的需求基本都集成在内部<br>4.grunt的基本使用<br>初始化一个项目，安装grunt，添加gruntfile.js文件，这个文件是grunt的入口文件，用于去定义需要grunt自动执行的任务，需要导出一个函数，此函数接收一个grunt的形参，内部提供一些创建任务时可以用到的API</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.registerTask(‘foo’,()=&gt;{//参数 任务名字，任务函数-&gt;任务发生时自动执行的函数<br>        console.log(‘hello grunt’)<br>    })<br>    grunt.registerTask(‘foo’,任务描述(出现在帮助信息中),()=&gt;{<br>        console.log(‘other task’)<br>    })<br>    // grunt.registerTask(‘default’,()=&gt;{//如果注册名字为default，那么将成为grunt的默认任务<br>        // console.log(‘default task’)<br>    // })<br>    grunt.registerTask(‘default’,[‘foo’,’bar’])//一般用default去映射一些其他任务，这里把foo和bar任务串联到了一起<br>    // 这里grunt默认支持同步模式，如果想使用异步操作，要用到this.async得到一个回调函数，在异步操作完成后调用这个回调函数标识一下这个任务已经完成<br>    // grunt.registerTask(‘async-task’,()=&gt;{<br>        // setTimeout(()=&gt;{<br>            // console.log(‘async task working’)<br>        // },1000)<br>    // })<br>    grunt.registerTask(‘async-task’,function (){<br>        const done = this.async()<br>        setTimeout(()=&gt;{<br>            console.log(‘async task working’)<br>            done()//标识一下这个任务已经完成了<br>        },1000)<br>    })<br>}<br></pre><br>然后运行yarn grunt foo 运行foo任务，可以运行grunt –help 去得到帮助信息。<br>5.grunt标记任务失败</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.registerTask(‘bad’,()=&gt;{<br>        console.log(‘bad working’)<br>        return false //构建任务失败的标记<br>        //如果当前任务在任务列表中，当前任务执行失败，那么列表中后续任务都不会再实现<br>    })<br>    grunt.registerTask(‘foo’,()=&gt;{<br>        console.log(‘foo task’)<br>    })<br>    grunt.registerTask(‘bar’,()=&gt;{<br>        console.log(‘bar task’)<br>    })<br>    grunt.registerTask(‘default’,[‘foo’,’bad’,’bar’])//bad执行失败了，bar就不会运行<br>}<br></pre><br>正常执行yarn grunt default 命令，上面的bar任务是不会执行的，但是命令行也提示我们，如果执行yarn grunt default –force，bar任务是可以执行的<br>标记异步任务执行失败</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.registerTask(‘bad-async’,function (){<br>        const done = this.async()<br>        setTimeout(()=&gt;{<br>            console.log(‘bad async’)<br>            done(false)<br>        },1000)<br>    })<br>}<br></pre><br>6.grunt的配置方法</p>
<p><pre><br>module.exports = grunt =&gt; {<br>  // grunt.initConfig() 用于为任务添加一些配置选项<br>  grunt.initConfig({<br>    // 键一般对应任务的名称<br>    // 值可以是任意类型的数据<br>    foo: {<br>      bar: ‘baz’<br>    }<br>  })<br>  grunt.registerTask(‘foo’, () =&gt; {<br>    // 任务中可以使用 grunt.config() 获取配置<br>    console.log(grunt.config(‘foo’))<br>    // 如果属性值是对象的话，config 中可以使用点的方式定位对象中属性的值<br>    console.log(grunt.config(‘foo.bar’))<br>  })<br>}<br></pre><br>7.grunt多目标任务<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_1.png"></p>
<p><pre><br>module.exports = grunt =&gt; {<br>    // 多目标模式，可以让任务根据配置形成多个子任务<br>    grunt.initConfig({//配置多任务的目标<br>      build: {//必须是一个对象<br>          css:’1’,//每一个属性的名称就是我们的目标名称<br>          js: ‘2’<br>        }<br>    })<br>    grunt.registerMultiTask(‘build’, function () {<br>        console.log(<code>build task</code>)<br>    })<br>}<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_2.png"><br>通过yarn grunt build:css 可以只运行指定目标</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        build: {<br>            css:’1’,<br>            js: ‘2’<br>        }<br>    })<br>    grunt.registerMultiTask(‘build’, function () {<br>       console.log(<code>task: build, target: ${this.target}, data: ${this.data}</code>)<br>    })<br>}<br></pre><br>重新用yarn grunt build:css 命令执行上面代码，可以得到<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_3.png"><br>在initConfig每一个被指定的属性都会成为一个目标，除了options</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        build: {<br>            options:{<br>                foo:’bar’,<br>            },<br>            css:’1’,<br>            js: ‘2’<br>        }<br>    })<br>    grunt.registerMultiTask(‘build’, function () {<br>       console.log(<code>task: build, target: ${this.target}, data: ${this.data}</code>)<br>    })<br>}<br></pre><br>再次执行yarn grunt build 命令<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_4.png"><br>可以看到并没有一个target叫options，这个options可以作为一个配置选项出现</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        build: {<br>            options:{<br>                foo:’bar’,<br>            },<br>            css:’1’,<br>            js: ‘2’<br>        }<br>    })<br>    grunt.registerMultiTask(‘build’, function () {<br>        console.log(this.options())<br>        console.log(<code>task: build, target: ${this.target}, data: ${this.data}</code>)<br>    })<br>}<br></pre><br>执行结果如下<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_5.png"></p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        build: {<br>            options:{<br>                foo:’bar’,<br>            },<br>            css:{<br>                options: {<br>                    foo: ‘baz’<br>                }<br>            },<br>            js: ‘2’<br>        }<br>    })<br>    grunt.registerMultiTask(‘build’, function () {<br>        console.log(this.options())<br>        console.log(<code>task: build, target: ${this.target}, data: ${this.data}</code>)<br>    })<br>}<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_2/automation/7_6.png"><br>8.Grunt插件的使用<br>插件机制是grunt的核心<br>使用一个插件的大体过程就是首先使用npm安装插件，再到gruntfile中载入这个插件提供的一些任务，最后根据这些插件的文档完成相关的配置选项。这里我们用grunt-contrib-clean来演示，这个插件用来清除项目当中产生的一些临时文件<br>首先安装 yarn add grunt-contrib-clean</p>
<p><pre><br>module.exports = grunt =&gt; {<br>  grunt.loadNpmTasks(‘grunt-contrib-clean’)<br>}<br></pre><br>运行yarn grunt clean，控制台会打印错误信息:clean任务没有配置对应目标，我们需要initConfig去配置不同的目标</p>
<p><pre><br>module.exports = grunt =&gt; {<br>  grunt.initConfig({<br>    clean: {<br>      temp: ‘temp/*<em>‘ //temp/app.js temp/</em>.txt 等都是支持的<br>    }<br>  })<br>  grunt.loadNpmTasks(‘grunt-contrib-clean’)<br>}<br></pre><br>9.Grunt常用插件及总结<br>9-1.grunt-sass<br>grunt官方也提供了一个sass插件，但是这个模块需要本机安装sass环境，使用起来不是很方便。grunt-sass是一个npm的模块，在内部是通过npm的形式去依赖sass，grunt-sass需要一个sass模块的支持，这里我们用grunt官方提供的sass模块，yarn add grunt-sass sass –dev</p>
<p><pre><br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        sass: {<br>              main: {<br>                  files: {<br>                      ‘dist/css/main.css’ : ‘src/scss/main.scss’<br>                  }<br>              }<br>        },<br>    })<br>    grunt.loadNpmTasks(‘grunt-sass’)<br>}<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_2/automation/9_1.png"><br>implementation是用来指定在grunt-sass中用哪一个模块去处理sass的编译</p>
<p><pre><br>const sass = require(‘sass’)<br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        sass: {<br>            options: {<br>                sourceMap: true,<br>                implementation: sass //更多选项可以去grunt-sass官方文档查看<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/css/main.css’ : ‘src/scss/main.scss’<br>                  }<br>              }<br>        },<br>    })<br>    grunt.loadNpmTasks(‘grunt-sass’)<br>}<br></pre><br>9-2.grunt-babel<br>安装 yarn add grunt-babel @babel-core @babel/preset-env –dev ，安装之后又需要 loadNpmTasks 去加载任务，随着安装的插件越来越多，社区中有一个模块可以减少loadNpmTasks的使用。同样也需要我们安装一下 yarn add load-grunt-tasks –dev </p>
<p><pre><br>const sass = require(‘sass’)<br>const loadGruntTasks = require(‘load-grunt-tasks’)<br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        sass: {<br>            options: {<br>                sourceMap: true,<br>                implementation: sass //更多选项可以去grunt-sass官方文档查看<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/css/main.css’ : ‘src/scss/main.scss’<br>                  }<br>              }<br>        },<br>        babel: {<br>            options: {<br>                sourceMap: true,<br>                presets: [‘@babel/preset-env’]<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/js/app.js’ : ‘src/js/app.js’<br>                  }<br>              }<br>        },<br>    })<br>    // grunt.loadNpmTasks(‘grunt-sass’)<br>    loadGruntTasks(grunt) // 自动加载grunt所有的插件任务<br>}<br></pre><br>9-3.grunt-contrib-watch<br>文件修改完之后自动编译，安装 yarn add grunt-contrib-watch –dev </p>
<p><pre><br>const sass = require(‘sass’)<br>const loadGruntTasks = reuqire(‘load-grunt-tasks’)<br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        sass: {<br>            options: {<br>                sourceMap: true,<br>                implementation: sass //更多选项可以去grunt-sass官方文档查看<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/css/main.css’ : ‘src/scss/main.scss’<br>                  }<br>              }<br>        },<br>        babel: {<br>            options: {<br>                sourceMap: true,<br>                presets: [‘@babel/preset-env’]<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/js/app.js’ : ‘src/js/app.js’<br>                  }<br>              }<br>        },<br>        watch: {<br>            js: {<br>                files: [‘src/js/<em>.js’],<br>                tasks: [‘babel’]<br>            },<br>            js: {<br>                files: [‘src/scss/</em>.scss’],<br>                tasks: [‘sass’]<br>            },<br>        }<br>    })<br>    // grunt.loadNpmTasks(‘grunt-sass’)<br>    loadGruntTasks(grunt) // 自动加载grunt所有的插件任务<br>}<br></pre><br>由于watch只会在文件发生改变的时候才执行，所以我们增加default任务，保证启动之前先执行一次css、js任务</p>
<p><pre><br>const sass = require(‘sass’)<br>const loadGruntTasks = reuqire(‘load-grunt-tasks’)<br>module.exports = grunt =&gt; {<br>    grunt.initConfig({<br>        sass: {<br>            options: {<br>                sourceMap: true,<br>                implementation: sass //更多选项可以去grunt-sass官方文档查看<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/css/main.css’ : ‘src/scss/main.scss’<br>                  }<br>              }<br>        },<br>        babel: {<br>            options: {<br>                sourceMap: true,<br>                presets: [‘@babel/preset-env’]<br>            },<br>              main: {<br>                  files: {<br>                      ‘dist/js/app.js’ : ‘src/js/app.js’<br>                  }<br>              }<br>        },<br>        watch: {<br>            js: {<br>                files: [‘src/js/<em>.js’],<br>                tasks: [‘babel’]<br>            },<br>            js: {<br>                files: [‘src/scss/</em>.scss’],<br>                tasks: [‘sass’]<br>            },<br>        }<br>    })<br>    // grunt.loadNpmTasks(‘grunt-sass’)<br>    loadGruntTasks(grunt) // 自动加载grunt所有的插件任务<br>    grunt.registerTasks(‘default’,[‘css’,’js’,’watch’])<br>}<br></pre><br>10.Gulp的基本使用<br> Gulp作为当下最流行的构建系统，其核心特点就是高效、易用。使用gulp的过程非常简单，大体来说就是现在项目中安装一个gulp的开发依赖，然后在项目的根目录，也就是package.json所在目录去添加gulpfile.js用于去编写一些构建任务<br> <img src="https://snakexu.github.io/images/lagou/part_2/automation/10_1.png"><br>报错是因为最新gulp取消了同步代码模式，约定每个任务都必须是个异步任务<br>纠正上面的问题</p>
<p><pre><br>exports.foo = done =&gt; {<br>  console.log(‘foo task working~’)<br>  done() // 标识任务执行完成<br>}<br>// default 是默认任务<br>// 在运行是可以省略任务名参数<br>exports.default = done =&gt; {<br>  console.log(‘default task working~’)<br>  done()<br>}<br></pre><br>在gulp4.0以前我们去注册gulp任务是要通过gulp模块中的一个方法去实现</p>
<p><pre><br>// v4.0 之前需要通过 gulp.task() 方法注册任务<br>const gulp = require(‘gulp’)<br>gulp.task(‘bar’, done =&gt; {<br>  console.log(‘bar task working~’)<br>  done()<br>})<br></pre><br>11.Gulp的组合任务<br> <pre><br>const { series, parallel } = require(‘gulp’)<br>const task1 = done =&gt; {<br>  setTimeout(() =&gt; {<br>    console.log(‘task1 working~’)<br>    done()<br>  }, 1000)<br>}<br>const task2 = done =&gt; {<br>  setTimeout(() =&gt; {<br>    console.log(‘task2 working~’)<br>    done()<br>  }, 1000)<br>}<br>const task3 = done =&gt; {<br>  setTimeout(() =&gt; {<br>    console.log(‘task3 working~’)<br>    done()<br>  }, 1000)<br>}<br>// 让多个任务按照顺序依次执行<br>exports.foo = series(task1, task2, task3)<br>// 让多个任务同时执行<br>exports.bar = parallel(task1, task2, task3)<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_2/automation/11_1.png"><br>12.Gulp的异步任务<br>Gulp中的任务都是异步任务，异步任务在被调用的时候是无法明确是否完成的，都是在函数内部通过函数回调/事件方式通知外部完成。在gulp中也有这个问题，也有很多解决方式。我们想到的解决方式一，也是通过回调的方式去解决</p>
<p><pre><br>exports.callback = done =&gt; {<br>  console.log(‘callback task’)<br>  done()<br>}<br>exports.callback_error = done =&gt; {<br>  console.log(‘callback task’)<br>  done(new Error(‘task failed’))// 如果发生错误，错误优先<br>}<br></pre><br>方案二，通过promise</p>
<p><pre><br>exports.promise = () =&gt; {<br>  console.log(‘promise task’)<br>  return Promise.resolve() //resolve中不要写东西，gulp会忽略这些东西<br>}<br>exports.promise_error = () =&gt; {<br>  console.log(‘promise task’)<br>  return Promise.reject(new Error(‘task failed’))//如果遇到失败任务，gulp同样会不再执行后面的所有任务<br>}<br></pre><br>方案三，async/await</p>
<p><pre><br>const timeout = time =&gt; {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(resolve, time)<br>  })<br>}<br>exports.async = async () =&gt; {<br>  await timeout(1000)<br>  console.log(‘async task’)<br>}<br></pre><br>方案四，stream</p>
<p><pre><br>const fs = require(‘fs’)<br>exports.stream = () =&gt; {<br>  const read = fs.createReadStream(‘yarn.lock’)<br>  const write = fs.createWriteStream(‘a.txt’)<br>  read.pipe(write)<br>  return read<br>}<br></pre><br>stream都有end事件，任务完成会触发stream的end事件，从而gulp知道任务完成，简单模拟一下就是</p>
<p><pre><br>exports.stream = done =&gt; {<br>  const read = fs.createReadStream(‘yarn.lock’)<br>  const write = fs.createWriteStream(‘a.txt’)<br>  read.pipe(write)<br>  read.on(‘end’, () =&gt; {<br>    done()<br>  })<br>}<br></pre><br>13.Gulp构建过程核心工作原理<br>我们一个普通文件的处理过程大致如下<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/13_1.png"><br>通过对node底层API去模拟实现这样一个过程</p>
<p><pre><br>const fs = require(‘fs’)<br>const { Transform } = require(‘stream’)<br>exports.default = () =&gt; {<br>  // 文件读取流<br>  const readStream = fs.createReadStream(‘normalize.css’)<br>  // 文件写入流<br>  const writeStream = fs.createWriteStream(‘normalize.min.css’)<br>  // 文件转换流<br>  const transformStream = new Transform({<br>    // 核心转换过程<br>    transform: (chunk, encoding, callback) =&gt; {<br>      const input = chunk.toString()<br>      //替换掉代码中的css注释<br>      const output = input.replace(/\s+/g, ‘’).replace(/\/*.+?*\//g, ‘’)<br>      callback(null, output)<br>    }<br>  })<br>  return readStream<br>    .pipe(transformStream) // 转换<br>    .pipe(writeStream) // 写入<br>}</pre></p>
<p><br>14.Gulp文件操作API<br>创建构建任务的流程：通过src方法去创建一个读取流，再借助插件实现的转换方法来实现文件的加工，再通过gulp提供的dest方法去创建一个写入流</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const cleanCSS = require(‘gulp-clean-css’)//压缩css代码<br>const rename = require(‘gulp-rename’)<br>exports.default = () =&gt; {<br>  return src(‘src/*.css’)<br>    .pipe(cleanCSS())<br>    .pipe(rename({ extname: ‘.min.css’ }))//指定重命名的扩展名<br>    .pipe(dest(‘dist’))<br>}<br></pre><br>15.Gulp案例-样式编译<br>首先准备一个需要自动化构建的项目<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/15_1.png"><br>上面项目目录中public是不需要加工可以直接打包的内容；src放开发阶段代码，这个目录下所有内容都会被构建，里面包含js、scss代码、项目图片(打包的时候压缩删除一些不必要的图片信息)。首先安装gulp，然后创建gulpfile.js文件</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/*.scss’)<br>    .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style<br>}<br></pre><br>执行yarn gulp style ，可以看到多出了dist目录，但是我们看到dist目录下的文件不能按照我们src目录输出，丢失了原来的目录结构，我们可以</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/*.scss’, { base: ‘src’ })// base保存了目录的基准结构<br>    .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style<br>}<br></pre><br>这里我们还没有加文件转换，我们安装 yarn add gulp-sass –dev ，安装开发依赖</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const sass = require(‘gulp-sass’)<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/*.scss’, { base: ‘src’ })<br>    .pipe(sass())<br>    .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style<br>}<br></pre><br>再执行yarn gulp style 会看到有main.css 。顺便，这里之前生成的文件不会被清空，因为我们没有安装相关插件，后续会安装，这里先手动清空一下吧。还有就是我们看到只生成了一个main.css，和我们项目里原来有三个scss相关的文件不同，这里是因为我们之前有三个.scss文件，但是其中两个是以下划线开头命名的，gulp默认下划线开头的是内部依赖文件，会被忽略掉。另外处理后盛出的css会把右半边花括号放到代码旁边，我们需要指定一下才能改成平时我们习惯的新的一行</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const sass = require(‘gulp-sass’)<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/*.scss’, { base: ‘src’ })<br>    .pipe(sass({outputStyle:’expanded’}))<br>    .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style<br>}<br></pre><br>16.Gulp案例-脚本编译<br>在上一节，我们完成了样式编译，现在来编译脚本</p>
<p><pre><br>const { src, dest } = require(‘gulp’)<br>const sass = require(‘gulp-sass’)<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/<em>.scss’, { base: ‘src’ })<br>    .pipe(sass({outputStyle:’expanded’}))<br>    .pipe(dest(‘dist’))<br>}<br>const script = () =&gt; {<br>    return src(‘src/assets/scripts/</em>.js’, { base: ‘src’ })<br>      .pipe(babel())<br>      .pipe(dest(‘dist’))<br>}<br>module.exports = { //这里采用这种导出方式只是因为暂时需要，后面会升级导出方法<br>  style,<br>  script<br>}<br></pre><br>安装 yarn add gulp-babel –dev 这个开发依赖，执行 yarn gulp script ，会发现报错<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/16_1.png"><br>因为这里babel只是帮忙唤醒babel-core模块的转换过程，并没有自动安装核心转换模块，我们要自己手动安装 yarn add @babel/core @babel/preset-env –dev </p>
<p><pre><br>//因为这一节内容是脚本编译，这里先不写样式编译的内容了<br>const { src, dest } = require(‘gulp’)<br>const script = () =&gt; {<br>    return src(‘src/assets/scripts/*.js’, { base: ‘src’ })<br>      .pipe(babel({preset:[‘@babel/preset-env’]}))<br>      .pipe(dest(‘dist’))<br>}<br>module.exports = { //这里采用这种导出方式只是因为暂时需要，后面会升级导出方法<br>  style,<br>  script<br>}<br></pre><br>重新运行 yarn gulp script ，就OK了。如果忘了写 {preset:[‘@babel/preset-env’]} ，可能会造成转换没有效果的感觉<br>17.Gulp案例-页面模版编译<br>页面模版也就是html，这里为了把能重用的部分抽离出来，用了模版引擎swig，首先又是熟悉的安装环节 yarn add gulp-swig –dev </p>
<p><pre><br>const swig = require(‘gulp-swig’)<br>//和上面编译脚本/样式都是在gulpfile.js文件中，这里只抽离写了页面模版相关的<br>const page = () =&gt; {<br>    return src(‘src/*<em>/</em>.html’, { base: ‘src’ })//src文件夹下的任意文件夹下的html文件<br>      .pipe(swig())<br>      .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style,<br>  script,<br>  page<br>}<br></pre><br>我们原来的模版用到了一些数据标记，如下图<br><img src="https://snakexu.github.io/images/lagou/part_2/automation/17_1.png"><br>即原来网站中可能发生变化的地方提取成一些数据，这里我们也模拟准备了一些数据</p>
<p><pre><br>const swig = require(‘gulp-swig’)<br>const data = {<br>  menus: [<br>    {<br>      name: ‘Home’,<br>      icon: ‘aperture’,<br>      link: ‘index.html’<br>    },<br>    {<br>      name: ‘Features’,<br>      link: ‘features.html’<br>    },<br>    {<br>      name: ‘About’,<br>      link: ‘about.html’<br>    },<br>    {<br>      name: ‘Contact’,<br>      link: ‘#’,<br>      children: [<br>        {<br>          name: ‘Twitter’,<br>          link: ‘<a href="https://twitter.com/w_zce&#39;" target="_blank" rel="noopener">https://twitter.com/w_zce&#39;</a><br>        },<br>        {<br>          name: ‘About’,<br>          link: ‘<a href="https://weibo.com/zceme&#39;" target="_blank" rel="noopener">https://weibo.com/zceme&#39;</a><br>        },<br>        {<br>          name: ‘divider’<br>        },<br>        {<br>          name: ‘About’,<br>          link: ‘<a href="https://github.com/zce&#39;" target="_blank" rel="noopener">https://github.com/zce&#39;</a><br>        }<br>      ]<br>    }<br>  ],<br>  pkg: require(‘./package.json’),<br>  date: new Date()<br>}<br>const page = () =&gt; {<br>    return src(‘src/*<em>/</em>.html’, { base: ‘src’ })//src文件夹下的任意文件夹下的html文件<br>      .pipe(swig( {data:data} ))//等价于 .pipe(swig( {data} ))<br>      .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>  style,<br>  script,<br>  page<br>}<br></pre><br>再执行yarn gulp page 命令，我们可以看到，我们的数据被插入到了页面模版中<br>但是项目中我们不可能为脚本、页面、样式单独执行任务，所以我们要创建一个组合任务</p>
<p><pre><br>////三个任务之间没有什么关联，可以同时执行，所以用parallel<br>const { src, dest, parallel } = require(‘gulp’)<br>const compile = parallel(style,script,page)<br>module.exports = {<br>  compile<br>}<br></pre><br>18.Gulp案例-图片和字体文件转换<br>只写了代码，如果有啥特别的地方再说吧，因为大致流程和上面编译别的文件差不多，安装的插件 yarn add gulp-imagemin –dev</p>
<p><pre><br>const imagemin = require(‘gulp-imagemin’)<br>const image = () =&gt; {<br>  return src(‘src/assets/images/<strong>‘, { base: ‘src’ })<br>    .pipe(imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>//字体文件同理，不再过多讲了<br>const font = () =&gt; {<br>  return src(‘src/assets/fonts/</strong>‘, { base: ‘src’ })<br>    .pipe(imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>const compile = parallel(style,script,page,image,font)<br></pre><br>19.Gulp案例-其他文件及文件清除<br>src下的文件都已经处理完了，再去把public中的文件做一个拷贝</p>
<p><pre><br>const extra = () =&gt; {<br>    return src(‘public/**’, { base: ‘public’ })<br>      .pipe(dest(‘dist’))<br>}<br>//这里没有把任务添加到compile是因为compile是处理src目录下的，容易产生混淆<br>const build = parallel(compile,extra)<br>module.exports = {<br>    build<br>}<br></pre><br>我们安装一个清除插件，清除每次执行yarn gulp XX 的结果(也就是清理dist目录下的文件)，虽然这个插件不属于gulp，但是可以在gulp中使用 yarn add del –dev</p>
<p><pre><br>//引入series，因为clean任务要先于别的任务执行，如果同时执行就可能出现已经生成的文件被删除的情况<br>const { src, dest, parallel, series } = require(‘gulp’)<br>const del = require(‘del’)//del返回的是一个promise<br>const clean = () =&gt; {<br>    return del([‘dist’])<br>}<br>const build =  series(clean,parallel(compile,extra))<br></pre><br>20.Gulp案例-自动加载插件<br>随着项目越来越复杂，如果每次都是这样手动引入插件，require操作会非常多，不利于代码的维护，我们可以通过一个插件解决这个小问题，安装这个插件 yarn add gulp-load-plugins –dev</p>
<p><pre><br>const loadPlugins = require(‘gulp-load-plugins’)//导出的是一个方法<br>//plugins是一个对象，所有插件都会成为这个对象上的一个属性<br>const plugins = loadPlugins()<br>//插件的gulp都会被去掉，剩下的按照驼峰命名，比如gulp-sass-ss变成sassSs<br>//把我们之前所有插件重命名<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/<em>.scss’, { base: ‘src’ })<br>      //用plugins重命名sass，之前引入sass的require(‘gulp-sass’)的定义可以删掉<br>    .pipe(plugins.sass({ outputStyle: ‘expanded’ }))<br>    .pipe(dest(‘dist’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const script = () =&gt; {<br>  return src(‘src/assets/scripts/</em>.js’, { base: ‘src’ })<br>      //用plugins重命名babel，之前引入babel的require(‘gulp-babel’)的定义可以删掉<br>    .pipe(plugins.babel({ presets: [‘@babel/preset-env’] }))<br>    .pipe(dest(‘dist’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const page = () =&gt; {<br>  return src(‘src/*.html’, { base: ‘src’ })<br>      //用swig重命名swig，之前引入swig的require(‘gulp-swig’)的定义可以删掉<br>    .pipe(plugins.swig({ data, defaults: { cache: false } })) // 防止模板缓存导致页面不能及时更新<br>    .pipe(dest(‘dist’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const image = () =&gt; {<br>    //用imagemin重命名imagemin，之前引入imagemin的require(‘gulp-imagemin’)的定义可以删掉<br>  return src(‘src/assets/images/<strong>‘, { base: ‘src’ })<br>    .pipe(plugins.imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>const font = () =&gt; {<br>  return src(‘src/assets/fonts/</strong>‘, { base: ‘src’ })<br>    .pipe(plugins.imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>//还有一些没有需要修改的代码没有写到这里，完整的代码会在后面介绍gulp的最后一节写入<br></pre><br>21.Gulp案例-开发服务器<br>除了对文件的构建意外，我们这里还需要一个开发服务器，用于在开发阶段调试我们的应用，我们可以通过gulp去启动并且管理这个服务器，在后续就可以配合我们的构建任务自动编译并刷新浏览器，可以减少很多重复操作<br>首先，安装插件 yarn add brower-sync –dev </p>
<p><pre><br>const browserSync = require(‘browser-sync’)<br>const bs = browserSync.create()<br>const serve = () =&gt; {<br>    bs.init({<br>        server:{<br>            baseDir:’dist’//指定网站的根目录<br>        }<br>    })<br>}<br></pre><br>运行yarn gulp serve 命令，我们可能看到的网页不是我们想要的，因为css样式等不对，这是因为我们没有处理node_modules目录，也就是构建的代码没有处理路径等问题，这里我们先用一个小的解决办法</p>
<p><pre><br>const browserSync = require(‘browser-sync’)<br>const bs = browserSync.create()<br>const serve = () =&gt; {<br>    bs.init({<br>        notify:false,//关闭是否连接browser-sync提示<br>        port:2080,//改变启动端口<br>        // open:false,//是否在启动时自动打开浏览器<br>        files:’dist/**’,//路径监听启动通配符，监听哪些文件改变后browser-sync更新浏览器<br>        server:{<br>            baseDir:’dist’,<br>            routes:{<br>                ‘/node_modules’:’node_modules’<br>            }<br>        }<br>    })<br>}<br></pre><br>22.Gulp案例-监视变化以及构建优化</p>
<p><pre><br>//watch自动监视文件路径的通配符，根据文件的变化决定是否重新执行某一个任务<br>const { src, dest, parallel, series, watch } = require(‘gulp’)<br>const serve = () =&gt; {<br>    watch(‘src/assets/styles/<em>.scss’, style)<br>    watch(‘src/assets/scripts/</em>.js’, script)<br>    watch(‘src/*.html’, page)<br>    watch(‘src/assets/images/<strong>‘, image)<br>    watch(‘src/assets/fonts/</strong>‘, font)<br>    watch(‘public/<strong>‘, extra)<br>    bs.init({<br>        notify:false,<br>        port:2080,<br>        files:’dist/</strong>‘,<br>        server:{<br>            baseDir:’dist’,<br>            routes:{<br>                ‘/node_modules’:’node_modules’<br>            }<br>        }<br>    })<br>}<br></pre><br>运行 yarn gulp serve 命令，到这里我们尝试修改源代码(src目录下的文件)基本实现了。我们对图片、字体、extra每次都执行构建意义不大(这种文件在上线之前构建一次就OK了)，影响构建效率。所以我们上面watch的image、font、extra都注释掉</p>
<p><pre><br>const serve = () =&gt; {<br>    watch(‘src/assets/styles/<em>.scss’, style)<br>    watch(‘src/assets/scripts/</em>.js’, script)<br>    watch(‘src/*.html’, page)<br>    // watch(‘src/assets/images/<strong>‘, image)<br>    // watch(‘src/assets/fonts/</strong>‘, font)<br>    // watch(‘public/<strong>‘, extra)<br>    watch([<br>        ‘src/assets/images/</strong>‘,<br>        ‘src/assets/fonts/<strong>‘,<br>        ‘public/</strong>‘<br>    ], bs.reload)//文件发生变化之后自动更新，而不是构建<br>    bs.init({<br>        notify:false,<br>        port:2080,<br>        files:’dist/**’,<br>        server:{<br>            //按照数组顺序，从最开始的目录开始找，直到找到文件或者到最后一项都没找到<br>            baseDir:[‘dist’,’src’,’public’] ,<br>            routes:{<br>                ‘/node_modules’:’node_modules’<br>            }<br>        }<br>    })<br>}<br>const compile = parallel(style,script,page)<br>//上线之前build任务<br>const build = series(clean,parallel(compile,image,font,extra))<br>const develop = series(compile,serve)<br>module.exports = {<br>    clean,<br>    compile,<br>    build,<br>    develop<br>}<br></pre><br>23.Gulp案例-useref文件引用处理<br>这里主要就是要处理我们之前发现构建的文件中有node_modules文件夹中的依赖的，因为我们并不会把node_modules文件夹放到线上，首先安装 yarn add gulp-useref –dev</p>
<p><pre><br>const useref = () =&gt; {<br>    return src(‘dist/*.html’,{base:’dist’})<br>      .pipe(plugins.useref({searchPath:[‘dist’,’.’]}))<br>      .pipe(dest(‘dist’))<br>}<br>module.exports = {<br>    clean,<br>    compile,<br>    build,<br>    develop,<br>    useref<br>}<br></pre><br>24.Gulp案例-文件压缩<br>分别压缩HTML、CSS、JavaScript，安装相关插件 yarn add gulp-htmlmin gulp-uglify gulp-clean-css –dev ，之前我们都是对一种文件进行一种操作，现在我们分别要对三种文件进行三种不同的操作，我们需要一个插件来识别 yarn add gulp-if –dev </p>
<p><pre><br>const useref = () =&gt; {<br>  return src(‘dist/*.html’, { base: ‘dist’ })<br>    .pipe(plugins.useref({ searchPath: [‘dist’, ‘.’] }))<br>    // html js css<br>    // if会自动创建一个转换流，会在转换流内部通过if指定的条件去决定是否要去执行具体的转换流<br>    .pipe(plugins.if(/.js$/, plugins.uglify()))<br>    .pipe(plugins.if(/.css$/, plugins.cleanCss()))<br>    .pipe(plugins.if(/.html$/, plugins.htmlmin()))<br>    .pipe(dest(‘dist’))<br>}<br></pre><br>这里执行yarn gulp useref 之前，先要执行 yarn gulp compile ，但是还有一个问题，src()中的是读取流，pipe(dest(‘dist’))是写入流，会产生读写冲突，我们不写入dist目录了，换个目录名试试</p>
<p><pre><br>const useref = () =&gt; {<br>  return src(‘dist/*.html’, { base: ‘dist’ })<br>    .pipe(plugins.useref({ searchPath: [‘dist’, ‘.’] }))<br>    // html js css<br>    // if会自动创建一个转换流，会在转换流内部通过if指定的条件去决定是否要去执行具体的转换流<br>    .pipe(plugins.if(/.js$/, plugins.uglify()))<br>    .pipe(plugins.if(/.css$/, plugins.cleanCss()))<br>    .pipe(plugins.if(/.html$/, plugins.htmlmin({<br>      //默认不是处理所有的空白字符，就是只是删除一些空格，需要指定额外的参数才能去掉所有换行符、空白字符<br>      collapseWhitespace: true,<br>      minifyCSS: true,//压缩html内的css代码<br>      minifyJS: true //压缩html中的js代码<br>    })))<br>    .pipe(dest(‘release’))<br>}<br></pre><br>25.Gulp案例-重新规划构建过程<br>上一节我们为了解决读写冲突，为useref指定了新的生成目录release，显然这样是不行的。我们先为各种类型的文件进行了转换，在上线之前又用useref进行了转换，那么我们之前为html、js、css文件转换直接写入最终要上线的dist目录就有问题了，我们应该先把这些转换结果放入一个临时的文件目录中，然后在useref转换的时候通过临时目录把文件拿出来做转换操作，最后再放入dist目录，这样更合适一些(也就是把处理css/js/html过程中的dest变为temp临时文件夹，clean的时候记得也清除temp目录；把serve中的baseDir的数组中dist改为temp；再把useref中dest(‘release’)，改为dest(‘dist’)，把src的base改为temp，searchPath的dist改为temp)</p>
<p><pre><br>const { src, dest, parallel, series, watch } = require(‘gulp’)<br>const del = require(‘del’)<br>const browserSync = require(‘browser-sync’)<br>const loadPlugins = require(‘gulp-load-plugins’)<br>const plugins = loadPlugins()<br>const bs = browserSync.create()<br>const data = {<br>  menus: [<br>    {<br>      name: ‘Home’,<br>      icon: ‘aperture’,<br>      link: ‘index.html’<br>    },<br>    {<br>      name: ‘Features’,<br>      link: ‘features.html’<br>    },<br>    {<br>      name: ‘About’,<br>      link: ‘about.html’<br>    },<br>    {<br>      name: ‘Contact’,<br>      link: ‘#’,<br>      children: [<br>        {<br>          name: ‘Twitter’,<br>          link: ‘<a href="https://twitter.com/w_zce&#39;" target="_blank" rel="noopener">https://twitter.com/w_zce&#39;</a><br>        },<br>        {<br>          name: ‘About’,<br>          link: ‘<a href="https://weibo.com/zceme&#39;" target="_blank" rel="noopener">https://weibo.com/zceme&#39;</a><br>        },<br>        {<br>          name: ‘divider’<br>        },<br>        {<br>          name: ‘About’,<br>          link: ‘<a href="https://github.com/zce&#39;" target="_blank" rel="noopener">https://github.com/zce&#39;</a><br>        }<br>      ]<br>    }<br>  ],<br>  pkg: require(‘./package.json’),<br>  date: new Date()<br>}<br>const clean = () =&gt; {<br>  return del([‘dist’, ‘temp’])<br>}<br>const style = () =&gt; {<br>  return src(‘src/assets/styles/<em>.scss’, { base: ‘src’ })<br>    .pipe(plugins.sass({ outputStyle: ‘expanded’ }))<br>    .pipe(dest(‘temp’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const script = () =&gt; {<br>  return src(‘src/assets/scripts/</em>.js’, { base: ‘src’ })<br>    .pipe(plugins.babel({ presets: [‘@babel/preset-env’] }))<br>    .pipe(dest(‘temp’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const page = () =&gt; {<br>  return src(‘src/<em>.html’, { base: ‘src’ })<br>    .pipe(plugins.swig({ data, defaults: { cache: false } })) // 防止模板缓存导致页面不能及时更新<br>    .pipe(dest(‘temp’))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const image = () =&gt; {<br>  return src(‘src/assets/images/<strong>‘, { base: ‘src’ })<br>    .pipe(plugins.imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>const font = () =&gt; {<br>  return src(‘src/assets/fonts/</strong>‘, { base: ‘src’ })<br>    .pipe(plugins.imagemin())<br>    .pipe(dest(‘dist’))<br>}<br>const extra = () =&gt; {<br>  return src(‘public/**’, { base: ‘public’ })<br>    .pipe(dest(‘dist’))<br>}<br>const serve = () =&gt; {<br>  watch(‘src/assets/styles/</em>.scss’, style)<br>  watch(‘src/assets/scripts/<em>.js’, script)<br>  watch(‘src/</em>.html’, page)<br>  // watch(‘src/assets/images/<strong>‘, image)<br>  // watch(‘src/assets/fonts/</strong>‘, font)<br>  // watch(‘public/<strong>‘, extra)<br>  watch([<br>    ‘src/assets/images/</strong>‘,<br>    ‘src/assets/fonts/<strong>‘,<br>    ‘public/</strong>‘<br>  ], bs.reload)<br>  bs.init({<br>    notify: false,<br>    port: 2080,<br>    // open: false,<br>    // files: ‘dist/*<em>‘,<br>    server: {<br>      baseDir: [‘temp’, ‘src’, ‘public’],<br>      routes: {<br>        ‘/node_modules’: ‘node_modules’<br>      }<br>    }<br>  })<br>}<br>const useref = () =&gt; {<br>  return src(‘temp/</em>.html’, { base: ‘temp’ })<br>    .pipe(plugins.useref({ searchPath: [‘temp’, ‘.’] }))<br>    // html js css<br>    .pipe(plugins.if(/.js$/, plugins.uglify()))<br>    .pipe(plugins.if(/.css$/, plugins.cleanCss()))<br>    .pipe(plugins.if(/.html$/, plugins.htmlmin({<br>      collapseWhitespace: true,<br>      minifyCSS: true,<br>      minifyJS: true<br>    })))<br>    .pipe(dest(‘dist’))<br>}<br>const compile = parallel(style, script, page)<br>// 上线之前执行的任务<br>const build =  series(<br>  clean,<br>  parallel(<br>    //这里compile和useref是有依赖关系的，所以用series执行<br>    series(compile, useref),<br>    image,<br>    font,<br>    extra<br>  )<br>)<br>const develop = series(compile, serve)<br>module.exports = {<br>  clean,<br>  build,<br>  develop<br>}<br></pre><br>26.Gulp案例-补充<br>通过观察我们发现，我们只需要将clean、build、develop导出，并且在package.json文件中定义scripts</p>
<p><pre><br>“scripts”: {<br>    “clean”: “gulp clean”,<br>    “build”: “gulp build”,<br>    “develop”: “gulp develop”<br>}<br></pre><br>另外还要记得在.gitignore中忽略我们生成的dist、temp目录<br>另外虽然这个代码已经完成了基本项目中的需求，但是依然不建议直接保存以后使用。原因在于有可能以后各种依赖会有改变，或者项目需求不同等等，其实最主要的是不利于个人的学习，不多做一些联系不能更加熟练的掌握<br>27.封装工作流-准备<br>如果我们开发多个同类型项目，那么多个项目的自动化工作流有可能是一样的，我们有可能需要在多个项目中重复去使用这些构建任务，这些构建任务在大多数情况下是相同的，那么就需要复用相同的gulpfile，我们可以把gulpfile作为代码段保存起来，在不同的项目中去使用。先做一些准备工作：我们在git上创建一个仓库用来存放我们的代码。在本地初始化一个项目，这里老师自己写的脚手架是zce-cli，安装之后通过zce init 模版名称 去创建项目，然后通过git init去初始化仓库，git remote add origin 远端仓库地址 ，然后提交我们初始化的仓库<br>28.封装工作流-提取<br>首先将gulpfile文件整体移动到我们刚创建的项目中(作为index.js)，再将package.json中的devDependencies中的内容放到我们刚才创建的项目的dependencies中，因为dependencies才会自动安装，而devDependencies是开发依赖，不会自动安装。正常是将包发布到npm，但是这里我们是本地调试，故先进入到我们刚修改的项目中，在项目文件夹下执行npm link命令，再到我们要使用这个包的项目目录下执行npm link 要link的包的包名。在使用目录的gulpfile文件中</p>
<p><pre><br>module.exports = require(‘包名’)<br></pre><br>另外，我们之前写gulp的时候定义了data给模版使用，但是这里是不合理的，我们应该定义一个读取data文件的过程<br>29.封装工作流-解决模块中的问题<br>在项目根目录下创建一个配置文件pages.config.js，在这个文件里存放我们需要的数据，然后在我们抽取的包的index.js中添加读取操作</p>
<p><pre><br>const cwd = process.cwd()<br>let config = {}<br>try{<br>    const loadConfig = require(<code>${cwd}/pages.config.js</code>)<br>    config = Object.assign({},config,loadConfig)<br>}cache(e){}<br></pre><br>把代码中读取data的地方换成我们刚读取的config.data，并且把{ presets: [‘@babel/preset-env’] }改成{ presets: [require(‘@babel/preset-env’)] }<br>30.封装工作流-抽象路径配置<br>项目中的目录都是我们指定的，比如src文件夹，这样不够灵活，我们可以考虑把其改成可配置的</p>
<p><pre><br>let config = {<br>    build:{<br>        src:’src’,<br>        dist:’dist’,<br>        temp:’temp’,<br>        public:’public’,<br>        paths:{<br>            styles:’assets/styles/<em>.scss’,<br>            scripts:’assets/scripts/</em>.js’,<br>            pages:’<em>.html’,<br>            images:’asset/images/<strong>‘,<br>            fonts:’asset/fonts/</strong>‘,<br>        }<br>    },<br>}<br>const style = () =&gt; {<br>    //从’src/assets/styles/</em>.scss’变成config.build.paths.styles肯定会有一些问题<br>    //cwd指定在哪个路径去找，默认是当前项目所在目录<br>  return src(config.build.paths.styles, { base: config.build.src, cwd: config.build.src })<br>    .pipe(plugins.sass({ outputStyle: ‘expanded’ }))<br>    .pipe(dest(config.build.temp))<br>    .pipe(bs.reload({ stream: true }))<br>}<br>const font = () =&gt; {<br>  return src(config.build.paths.fonts, { base: config.build.src, cwd: config.build.src })<br>    .pipe(plugins.imagemin())<br>    .pipe(dest(config.build.dist))<br>}<br>const serve = () =&gt; {<br>  watch(config.build.paths.styles, {cwd: config.build.src},style)<br>  watch(config.build.paths.scripts, {cwd: config.build.src},script)<br>  watch(config.build.paths.pages, {cwd: config.build.src},page)<br>  watch([<br>    config.build.paths.images,<br>    config.build.paths.fonts,<br>    //‘public/<strong>‘//public因为和images等路径不一样，我们把public单独拆出来再做一个任务<br>  ],{cwd: config.build.src}, bs.reload)<br>  watch(‘</strong>‘,{cwd: config.build.public}, bs.reload)<br>  bs.init({<br>    notify: false,<br>    port: 2080,<br>    server: {<br>      baseDir: [‘temp’, ‘src’, ‘public’],<br>      routes: {<br>        ‘/node_modules’: ‘node_modules’<br>      }<br>    }<br>  })<br>}<br></pre><br>把我们之前写的config相关的目录换成config对象里的属性，我们已经把style修改作为例子放在这里了，剩下的按照例子修改就好。都修改完成后我们输入命令yarn serve来尝试下是不是都修改正确，都修改正确后，我们可以把config对象放到pages.config.js文件中，这样我们就可以按照自己的想法配置文件目录名称了<br>31.封装工作流-包装Gulp CLI</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/08/拉勾-自动化构建/" data-id="ckdbzsit9005wjrxqxdnlx5re" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-脚手架工具" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/03/拉勾-脚手架工具/" class="article-date">
  <time datetime="2020-07-03T09:00:29.000Z" itemprop="datePublished">2020-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/03/拉勾-脚手架工具/">拉勾-脚手架工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.脚手架工具概要<br>脚手架的本质作用：创建项目基础结构、提供项目规范和约定<br>·相同的组织结构<br>·相同的代码开发范式<br>·相同的模块依赖<br>·相同的工具配置<br>·相同的基础代码<br>2.常用的脚手架工具<br>Yeoman、plop<br>3.Yeoman简介<br>相比vue-cli等这类专门的脚手架，Yeoman是一款非常通用的脚手架<br>4.Yeoman基础使用<br>首先要安装Yeoman，可以yarn global add yo或者npm install -g yo<br>使用Yeoman去创建项目，要找到对应类型的Generator，假设我们要生成一个node项目，我们需要generator-node这样一个模块，那么就需要把这个generator-node模块全局安装到本地。<br>安装成功后，可以创建一个目录，通过yo命令去运行我们安装的generator-node去创建项目，只不过这时候我们的命令要去掉generator，yo node这个命令就可以了，Yeoman会问我们一系列问题，正常回答就好<br>另外如果在生成过程中，让你在travis-cli上启动这个项目，命令行会卡死在这儿，敲一下回车结束这个流程<br>5.Sub Generator<br>有时候我们可能并不需要创建完整的项目，只需要在已有的项目基础上去创建一些文件，例如给一个已经存在的项目创建readme，或者创建一个配置文件等，可以用yeoman提供的sub generator这样一个特性来实现。在项目目录下用特定的命令去生成对应的文件，比如我们在项目中用generator-node子集的一个生成器去生成一个cli应用:yo node:cli，先提问是不是覆盖原来的package.json文件，我们选择是，然后本地模块可以通过npm link到全局范围，重新通过npm i 安装依赖<br>这里需要注意的是，并不是每个generator都生成子集生成器，我们要去官网去确定是不是有子集生成器<br>6.Yeoman 使用步骤总结<br><img src="https://snakexu.github.io/images/lagou/part_2/tools/6_1.png"><br>比如创建webapp的时候，有一些二进制的文件需要安装，npm处理起来会比较缓慢，我们可以用淘宝镜像源。一些淘宝镜像源<br><img src="https://snakexu.github.io/images/lagou/part_2/tools/6_2.png"><br>7.自定义Generator(基于Yeoman搭建自己的脚手架)<br>Yeoman是一款通用的脚手架，我们可以通过Yeoman去创建自己的项目。一些通用的cli只会创建基础的公共代码，而我们实际项目中会出现一些基础代码/业务代码，在相同类型项目时还是会重复的。我们可以通过自定义Generator来实现这些功能<br>8.创建Generator模块(本质上就是创建一个NPM模块)<br>Generator基本结构<br><img src="https://snakexu.github.io/images/lagou/part_2/tools/8_1.png"><br>另外generator的名称需要固定为generator-&lt; name &gt;(尖括号内无空格，尖括号内代表可修改项)这种格式<br>我们通过npm init / yarn init 的命令初始化一个项目，安装yeoman-generator模块，提供了生存generator的基类，在基类中提供了一些工具函数，让我们可以在创建生成器时更加便捷<br>然后我们按照之前介绍的基本结构创建文件夹，其中generators/app/index.js会作为generator的核心入口，需要导出继承自Yeoman Generator的类型。Yeoman Generator 在工作时会自动调用我们在此类型中定义的一些生命周期方法，我们在这些方法中可以通过调用父类提供的一些工具方法实现一些功能，例如文件写入</p>
<p><pre><br>const Generator = require(‘yeoman-generator’)<br>module.exports = class extends Generator {<br>    riting () {<br>        // Yeoman 自动在生成文件阶段调用此方法<br>        // 我们这里尝试往项目目录中写入文件<br>        this.fs.write(<br>           this.destinationPath(‘temp.txt’),<br>           Math.random().toString()<br>        )<br>    }<br>}<br></pre><br>以上一个简单的generator就完成了，通过npm link / yarn link 使之成为一个全局的模块包，这样yeoman在工作的时候就能找到我们写的工具，然后通过yo 工具名 来使用了<br>9.根据模版创建文件<br>我们可以创建一个templates目录，并且把我们想要生成的文件的都放入这个目录作为模板。例如我们创建templates/foo.txt</p>
<p><pre><br>这是一个模板文件<br>//下面说的都是真的，简单介绍了一下generator template的支持语法等<br>内部可以使用 EJS 模板标记输出数据<br>例如：&lt;%= title %&gt;<br>其他的 EJS 语法也支持<br>&lt;% if (success) { %&gt;<br>哈哈哈<br>&lt;% }%&gt;<br></pre><br>然后在generators/app/index.js中通过模板方式写入文件到目标目录</p>
<p><pre><br>const Generator = require(‘yeoman-generator’)<br>module.exports = class extends Generator {<br>    riting () {<br>        // Yeoman 自动在生成文件阶段调用此方法<br>        // 通过模板方式写入文件到目标目录<br>        // 模板文件路径<br>        const tmpl = this.templatePath(‘foo.txt’)<br>        // 输出目标路径<br>        const output = this.destinationPath(‘foo.txt’)<br>        // 模板数据上下文<br>        const context = { title: ‘Hello zce~’, success: false }<br>        this.fs.copyTpl(tmpl, output, context)<br>    }<br>}<br></pre><br>然后在命令行运行yo generatorname命令，yeoman就会使用模板引擎自动渲染模板。相对于手动创建每一个文件，模版的方式大大提高了效率<br>10.接收用户输入</p>
<p><pre><br>module.exports = class extends Generator {<br>    prompting () {<br>        // Yeoman 在询问用户环节会自动调用此方法<br>        // 在此方法中可以调用父类的 prompt() 方法发出对用户的命令行询问<br>        return this.prompt([<br>              {<br>                type: ‘input’,//采用用户输入的方式来得到信息<br>                name: ‘name’,//我们用来得到用户输入的键<br>                message: ‘Your project name’,//给用户的提示<br>                default: this.appname // appname 为项目生成目录名称，作为这个问题的默认值<br>              }<br>        ])<br>        .then(answers =&gt; {<br>              // answers =&gt; { name: ‘user input value’ }<br>              this.answers = answers<br>        })<br>    }<br>    riting () {<br>        // Yeoman 自动在生成文件阶段调用此方法<br>        // 模板文件路径<br>        //这里bar.html就是模版，里面简单的写了一些简单的html内容<br>        const tmpl = this.templatePath(‘bar.html’)<br>        // 输出目标路径<br>        const output = this.destinationPath(‘bar.html’)<br>        // 模板数据上下文<br>        const context = this.answers<br>        this.fs.copyTpl(tmpl, output, context)<br>    }<br>}<br></pre><br>11.Vue Generator案例<br>首先我们先按照原始方式创建一个理想的项目结构，里面有我们所有需要重复使用的项目基础代码，然后我们去封装一个generator去生成我们理想的项目结构<br>首先创建一个generator目录，比如我们叫generator-zce-vue，进入这个目录，通过yarn init / npm init 去初始化一个package.json，安装yeoman-generator依赖。打开项目，把我们之前生成的项目结构目录整体拷贝到templates目录下作为模板，并且把需要发生变化的地方可以替换成EJS(&lt;%= 变量名 %&gt; )模版标记，用用户输入等方式获取，比如我们替换项目名称</p>
<p><pre><br>//README.md文件</pre></p>
<h1 id="lt-name-gt"><a href="#lt-name-gt" class="headerlink" title="&lt;%= name %&gt;"></a>&lt;%= name %&gt;</h1><h2 id="Project-setup"><a href="#Project-setup" class="headerlink" title="Project setup"></a>Project setup</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure>
<h3 id="Compiles-and-hot-reloads-for-development"><a href="#Compiles-and-hot-reloads-for-development" class="headerlink" title="Compiles and hot-reloads for development"></a>Compiles and hot-reloads for development</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run serve</span><br></pre></td></tr></table></figure>
<h3 id="Compiles-and-minifies-for-production"><a href="#Compiles-and-minifies-for-production" class="headerlink" title="Compiles and minifies for production"></a>Compiles and minifies for production</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run build</span><br></pre></td></tr></table></figure>
<h3 id="Run-your-tests"><a href="#Run-your-tests" class="headerlink" title="Run your tests"></a>Run your tests</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run test</span><br></pre></td></tr></table></figure>
<h3 id="Lints-and-fixes-files"><a href="#Lints-and-fixes-files" class="headerlink" title="Lints and fixes files"></a>Lints and fixes files</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run lint</span><br></pre></td></tr></table></figure>
<h3 id="Customize-configuration"><a href="#Customize-configuration" class="headerlink" title="Customize configuration"></a>Customize configuration</h3><p>See <a href="https://cli.vuejs.org/config/" target="_blank" rel="noopener">Configuration Reference</a>.<br>//package.json<br>{<br>  “name”: “&lt;%= name %&gt;”,<br>  “version”: “0.1.0”,<br>  “private”: true,<br>  “scripts”: {<br>    “serve”: “vue-cli-service serve”,<br>    “build”: “vue-cli-service build”,<br>    “lint”: “vue-cli-service lint”<br>  },<br>  “dependencies”: {<br>    “axios”: “^0.19.0”,<br>    “core-js”: “^3.2.1”,<br>    “vue”: “^2.6.10”,<br>    “vue-router”: “^3.0.3”,<br>    “vuex”: “^3.0.1”<br>  },<br>  “devDependencies”: {<br>    “@vue/cli-plugin-babel”: “^3.11.0”,<br>    “@vue/cli-plugin-eslint”: “^3.11.0”,<br>    “@vue/cli-service”: “^3.11.0”,<br>    “@vue/eslint-config-standard”: “^4.0.0”,<br>    “babel-eslint”: “^10.0.1”,<br>    “eslint”: “^6.2.2”,<br>    “eslint-plugin-vue”: “^5.0.0”,<br>    “sass”: “^1.18.0”,<br>    “sass-loader”: “^7.1.0”,<br>    “vue-template-compiler”: “^2.6.10”<br>  }<br>}<br>//index.html<br>&lt; title &gt;&lt;%= name %&gt;&lt; /title &gt;<br><br>然后修改入口文件代码</p>
<p><pre><br>const Generator = require(‘yeoman-generator’)</pre></p>
<p>module.exports = class extends Generator {<br>  prompting () {<br>    return this.prompt([<br>      {<br>        type: ‘input’,<br>        name: ‘name’,<br>        message: ‘Your project name’,<br>        default: this.appname<br>      }<br>    ])<br>    .then(answers =&gt; {<br>      this.answers = answers<br>    })<br>  }<br>  writing () {<br>    // 把每一个文件都通过模板转换到目标路径<br>    const templates = [<br>      ‘.browserslistrc’,<br>      ‘.editorconfig’,<br>      ‘.env.development’,<br>      ‘.env.production’,<br>      ‘.eslintrc.js’,<br>      ‘.gitignore’,<br>      ‘babel.config.js’,<br>      ‘package.json’,<br>      ‘postcss.config.js’,<br>      ‘README.md’,<br>      ‘public/favicon.ico’,<br>      ‘public/index.html’,<br>      ‘src/App.vue’,<br>      ‘src/main.js’,<br>      ‘src/router.js’,<br>      ‘src/assets/logo.png’,<br>      ‘src/components/HelloWorld.vue’,<br>      ‘src/store/actions.js’,<br>      ‘src/store/getters.js’,<br>      ‘src/store/index.js’,<br>      ‘src/store/mutations.js’,<br>      ‘src/store/state.js’,<br>      ‘src/utils/request.js’,<br>      ‘src/views/About.vue’,<br>      ‘src/views/Home.vue’<br>    ]<br>    templates.forEach(item =&gt; {<br>      // item =&gt; 每个文件路径<br>      this.fs.copyTpl(<br>        this.templatePath(item),<br>        this.destinationPath(item),<br>        this.answers<br>      )<br>    })<br>  }<br>}<br><br>然后npm link / yarn link 到全局，然后创建项目文件夹，在我们的项目文件夹运行yo generator-name命令，输入交互信息，而我们发现会报错，是因为我们在index.html文件中用到了和EJS模版标记一样的标记，但是我们需要原样输出，那么我们就多加一个%就好</p>
<p><pre> &lt; link rel=”icon” href=”&lt;%%= BASE_URL %&gt;favicon.ico” &gt; </pre><br>12.发布Generator<br>实际上就是发布一个npm模块，只需要将自己写好的generator模块通过npm publish这样一个命令去发布一个公开模块就好。在发布之前，我们需要将源代码托管到源代码仓库。先创建一个本地仓库，创建gitignore去忽略一些文件，然后通过git init初始化一个本地空仓库。通过git add . 去添加，git commit，打开github，创建一个新仓库，通过git remote add origin 远端仓库地址 ，git push -u origin master， npm publish 。这里要注意了，如果你使用的是淘宝镜像，就需要发布到官方镜像:yarn publish –registry=<a href="https://registry.yarnpkg.com" target="_blank" rel="noopener">https://registry.yarnpkg.com</a><br>13.Plop简介<br>一个小而美的脚手架工具。主要用于创建项目中特定类型文件。自动化创建指定类型文件，提高工作效率。<br>14.Plop的基本使用<br>首先，将plop作为开发依赖安装到项目中yarn add plop –dev(这里老师创建了一个基本的react项目，把plop作为依赖安装到这个项目中)。在项目的根目录下创建plopfile.js文件，这个文件是plop工作的入口文件，导出一个函数，并且这个函数接收一个叫plop的对象，这个对象提供了一系列工具函数帮我们创建生成器的任务</p>
<p><pre><br>module.exports = plop =&gt; {<br>  plop.setGenerator(‘component’, { //plop.setGenerator(生成器名字,生成器配置选项)<br>    description: ‘application component’,//描述<br>    prompts: [ // 命令行交互问题<br>      {<br>        type: ‘input’,<br>        name: ‘name’,<br>        message: ‘component name’ //屏幕提示，如果有默认答案，还可以写default:默认答案内容<br>      }<br>    ],<br>    actions: [ // 完成命令行交互之后执行的动作<br>      {<br>        type: ‘add’,<br>        //双花括号，得到命令行交互的答案，但是由于hexo对双花括号报错，这里将双花括号中间添加空格<br>        path: ‘src/components/{ { name } }/{ { name } }.js’,<br>        templateFile: ‘plop-templates/component.js.hbs’//本次添加文件的模板文件，一般放在项目根目录的plop-templates文件夹下面<br>      },<br>      {<br>        type: ‘add’,<br>        path: ‘src/components/{ { name } }/{ { name } }.css’,<br>        templateFile: ‘plop-templates/component.css.hbs’<br>      },<br>      {<br>        type: ‘add’,<br>        path: ‘src/components/{ { name } }/{ { name } }.test.js’,<br>        templateFile: ‘plop-templates/component.test.js.hbs’<br>      }<br>    ]<br>  })<br>}<br></pre><br>component.test.js.hbs</p>
<p><pre><br>import React from ‘react’;<br>import ReactDOM from ‘react-dom’;<br>import  from ‘./‘;</pre></p>
<p>it(‘renders without crashing’, () =&gt; {<br>  const div = document.createElement(‘div’);<br>  ReactDOM.render(&lt; { { name } } /&gt;, div);<br>  ReactDOM.unmountComponentAtNode(div);<br>});<br><br>component.js.hbs</p>
<p><pre><br>import React from ‘react’;<br>import ‘./{ { name } }.css’;<br>export default () =&gt; (<br>  &lt; div className=”{ { name } }” &gt;</pre></p>
<p>  &lt; /div &gt;<br>)<br><br>component.css.hbs</p>
<p><pre><br>. {</pre></p>
<p>}<br><br>安装plop的时候，plop提供了一个cli程序，可以通过yarn去启动这个plop程序即yarn plop 生成器名字 (生成器名字就是我们刚才在plop.setGenerator中指定的)<br>总结，在项目中使用plop的步骤<br><img src="https://snakexu.github.io/images/lagou/part_2/tools/14_1.png"><br>15.脚手架的工作原理<br>本节通过创建一个小型脚手架工具来体会工作原理，主要是node的cli的应用，创建一个目录，在目录中用npm init / yarn init 初始化一个项目<br>package.json</p>
<p><pre><br>{<br>  “name”: “sample-scaffolding”,<br>  “version”: “0.1.0”,<br>  “main”: “index.js”,<br>  “bin”: “cli.js”,//指定执行cli应用的入口文件<br>  “author”: “zce &lt; <a href="mailto:w@zce.me" target="_blank" rel="noopener">w@zce.me</a> &gt; (<a href="https://zce.me)&quot;" target="_blank" rel="noopener">https://zce.me)&quot;</a>,<br>  “license”: “MIT”,<br>  “dependencies”: {<br>    “ejs”: “^2.6.2”,<br>    “inquirer”: “^7.0.0”<br>  }<br>}<br></pre><br>cli.js</p>
<p><pre></pre></p>
<p>#!/usr/bin/env node<br>// Node CLI 应用入口文件必须要有这样的文件头<br>// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755<br>// 具体就是通过 chmod 755 cli.js 实现修改<br>// 脚手架的工作过程：<br>// 1. 通过命令行交互询问用户问题<br>// 2. 根据用户回答的结果生成文件<br>const fs = require(‘fs’)<br>const path = require(‘path’)<br>// 发起命令行交互需要安装inquirer<br>const inquirer = require(‘inquirer’)<br>// 模版引擎，需要安装<br>const ejs = require(‘ejs’)<br>inquirer.prompt([ //发起命令行询问<br>  {<br>    type: ‘input’,<br>    name: ‘name’,<br>    message: ‘Project name?’<br>  }<br>])<br>.then(anwsers =&gt; { // 在then中拿到用户答案<br>  // console.log(anwsers)<br>  // 根据用户回答的结果生成文件<br>  // 模板目录<br>  const tmplDir = path.join(__dirname, ‘templates’)<br>  // 目标目录<br>  const destDir = process.cwd()<br>  // 将模板下的文件全部转换到目标目录<br>  fs.readdir(tmplDir, (err, files) =&gt; {<br>    if (err) throw err<br>    files.forEach(file =&gt; {<br>      // 通过模板引擎渲染文件<br>      ejs.renderFile(path.join(tmplDir, file), anwsers, (err, result) =&gt; { //参数 模版引擎路径，工作环境上下文，回调函数<br>        if (err) throw err<br>        // 将结果写入目标文件路径<br>        fs.writeFileSync(path.join(destDir, file), result)<br>      })<br>    })<br>  })<br>})<br><br>通过yarn link 的方式把这样一个模块link到全局，然后可以通过sample-scaffolding这样一个命令</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/03/拉勾-脚手架工具/" data-id="ckdbzsilt004ijrxq1l39an8b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-工程化概述" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/03/拉勾-工程化概述/" class="article-date">
  <time datetime="2020-07-03T06:31:24.000Z" itemprop="datePublished">2020-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/03/拉勾-工程化概述/">拉勾-工程化概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.工程化的定义和主要解决的问题<br>主要解决的问题:传统语言或语法的弊端，无法使用模块化/组件化，重复的机械式工作，代码风格统一、质量保证，依赖后端服务接口支持，整体依赖后端项目<br>2.一个项目过程中工程化表现<br>一切以提高效率、降低成本、质量保证为目的的手段都属于”工程化”<br>一切重复的工作都应该被自动化<br>创建项目(创建项目结构，创建特定类型文件)(通过脚手架工具自动帮我们完成基础结构 的搭建)<br>编码(格式化代码，校验代码风格，编译、构建、打包)(借助工程化工具自动化帮我们做一些的代码的格式化，代码风格的校验)<br>预览/测试(Web Server/Mock,Live Reloading/HMR,Source Map)(借助现代化webserver实现热更新体验等)<br>提交(GitHooks,Lint-staged，持续集成)(githook自动化在代码提交之前做项目代码整体的检查)<br>部署(CI/CD，自动发布)<br>3.工程化不等于工具<br>工程化不等于某个工具。工程化的核心是对项目整体的规划/架构，工具是对这种规划的落地的手段<br>规划项目的整体结构，类似下图<br><img src="https://snakexu.github.io/images/lagou/part_2/engineering/3_1.png"><br>一些成熟的工程化集成:create-react-app/vue-cli/angular-cli/gatsby-cli<br>4.工程化与Node.js<br>Node.js对现在工程化开发起到了很大作用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/03/拉勾-工程化概述/" data-id="ckdbzsih2000ujrxq0ijqvdyq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工程化/">工程化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-JavaScript性能优化" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/28/拉勾-JavaScript性能优化/" class="article-date">
  <time datetime="2020-06-28T12:06:17.000Z" itemprop="datePublished">2020-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/28/拉勾-JavaScript性能优化/">拉勾-JavaScript性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.课程概述<br>·性能优化不可避免<br>·哪些内容可以看作性能优化：本质上来说任何一种可以提高运行效率，降低运行开销的行为都可以认为是性能优化<br>·无处不在的前端性能优化：例如请求资源时用到的网络，数据的传输方式，开发过程中所使用的框架等等都可以进行优化<br>本阶段的核心是JavaScript语言的优化，内容概要<br>·内存管理<br>·垃圾回收与常见GC算法<br>·V8引擎的垃圾回收<br>·Performance工具<br>·代码优化实例<br>2.内存管理<br>2-1.内存为什么需要管理<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/2_1.png"><br>从图中可以看到，我们一下子给数组索引值很大的地方添加了一个变量，导致内存泄漏性性能损耗很大<br>2-2.内存管理介绍<br>·内存:由可读写单元组成，表示一片可操作空间<br>·管理:人为的去操作一片空间的申请、使用和释放<br>·内存管理:开发者主动申请空间、使用空间、释放空间<br>·管理流程:申请-使用-释放<br>2-3.JavaScript中的内存管理<br>由于JavaScript没有提供相应的API，所以不能像一些语言可以由开发者主动调用API来完成相应空间的管理。但是我们可以通过js脚本来演示在内部一个空间的生命周期是怎样完成的</p>
<p><pre><br>//申请<br>let obj = {}<br>//使用<br>obj.name = “lg”<br>//释放<br>obj = null<br></pre><br>3.JavaScript中的垃圾回收<br>3-1.JavaScript中的垃圾<br>·JavaScript中内存管理是自动的<br>·对象不再被引用时是垃圾<br>·对象不能从根上访问到时是垃圾<br>3-2.JavaScript中的可达对象<br>·可以访问到的对象就是可达对象(引用、作用域链)<br>·可达的标准就是从根出发是否能够被找到<br>·JavaScript中的根就可以理解为是全局变量对象</p>
<p><pre><br>let obj = {name:’xm’}//空间被引用,obj是可达的<br>let ali = obj //被引用，多了一次引用，引用数值变化<br>obj = null//obj的引用被断掉了，但是{name:’xm’}的空间是存在的，因为遍历ali还存在<br></pre><br>下面这个例子会可以更多理解</p>
<p><pre><br>function objGroup(obj1,obj2){<br>    obj1.next = obj2<br>    obj2.prev = obj1<br>    return {<br>        o1:obj1,<br>        o2:obj2<br>    }<br>}<br>let obj = objGroup({name:’obj1’},{name:’obj2’})<br>console.log(obj)<br>//{<br>//  o1: <ref *1=""> {<br>//    name: ‘obj1’,<br>//    next: { name: ‘obj2’, prev: [Circular <em>1] }<br>//  },<br>//  o2: &lt;ref </em>2&gt; {<br>//    name: ‘obj2’,<br>//    prev: <ref *1=""> { name: ‘obj1’, next: [Circular *2] }<br>//  }<br>//}<br></ref></ref></pre><br>我们结合上面的代码和下面的图一起来看<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/3_1.png"><br>我们从全局global出发，找到可达obj对象，通过函数调用指向一个内存空间，内存空间中有o1和o2，在o1和o2里边我们又通过相应的属性去指向obj1的空间和obj2的空间，对于obj1和obj2，又通过next和prev做了一个互相的引用。目前来说我们代码中出现的对象都可以从根上进行查找到。如果此时我们通过delete obj.o1和delete obj2.prev，我们去掉obj对o1的引用以及obj2对o1的引用，那么此时我们很难再通过什么方式找到obj1的空间<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/3_2.png"><br>上图红线部分表示我们delete操作之后的情况，此时obj1就会被认为是垃圾，被JavaScript引擎进行回收。<br>4.GC算法介绍<br>4-1.GC定义与作用<br>·GC就是垃圾回收机制的简写<br>·GC可以找到内存中的垃圾、并释放和回收空间<br>4-2.GC里的垃圾是什么<br>·程序中不再需要使用的对象</p>
<p><pre><br>function func(){<br>    name = ‘lg’<br>    return <code>${name} is a coder</code><br>}<br>func()<br></pre><br>·程序中不能再访问到的对象</p>
<p><pre><br>function func(){<br>    const name = ‘lg’<br>    return <code>${name} is a coder</code><br>}<br>func()<br></pre><br>4-3.GC算法是什么<br>·GC算法是一种机制，垃圾回收器完成具体的工作<br>·工作内容就是查找垃圾释放空间、回收空间<br>·算法就是工作时查找和回收所遵循的规则<br>4-4.常见GC算法<br>·引用计数<br>·标记清除<br>·标记整理<br>·分代回收<br>5.引用计数算法实现原理<br>·核心思想:设置引用数，判断当前引用数是否为0<br>·引用计数器<br>·引用关系改变时修改引用数字<br>·引用数字为0时立即回收</p>
<p><pre><br>const user1 = {age:11}<br>const user2 = {age:22}<br>const user3 = {age:33}<br>const nameList = [user1.age,user2.age,user3.age]<br>function fn(){<br>    num1 = 1<br>    num2 = 2<br>}<br>fn()<br></pre><br>这种情况下当前全局有user1、user2、user3、nameList、num1、num2变量，这些变量的引用计数都不为0。如果我们稍作修改</p>
<p><pre><br>function fn(){<br>    const num1 = 1<br>    const num2 = 2<br>}<br></pre><br>那么在fn执行完毕后，在外部全局作用域不能找到num1、num2，num1、num2的引用计数为0，会被作为垃圾回收。而user1、user2、user3被nameList引用，即使脚本执行完毕，user1、user2、user3的引用计数器都不为0，不会被作为垃圾回收。<br>6.引用计数算法优缺点<br>优点：<br>·发现垃圾时立即回收<br>·最大限度减少程序暂停(应用程序执行必然对内存有消耗，而我们执行平台的内存是有上限的，内存肯定有占满的时候，由于引用计数算法时刻监控着引用数值为0的情况，即使内存即将被占满，由于有引用计数时刻监测着引用为0的变量，进行垃圾回收，保证了当前内存不会有占满的时候)<br>缺点：<br>·无法回收循环引用的对象<br>·时间开销大(当前引用计数需要维护一个数值的变化，就需要时刻监控当前对象的引用数值是否发生变化，数值修改本身就需要消耗时间，如果内存中很多对象都需要变化时间就会显得更大一些)</p>
<p><pre><br>//循环引用对象<br>function fn(){<br>    const obj1 = {}<br>    const obj2 = {}<br>    obj1.name = obj2<br>    obj2.name = obj1<br>    return ‘lg is a coder’<br>}<br>fn()<br></pre><br>虽然在fn执行完毕后，外部不再有对obj1、obj2的引用，但是函数内部o bj1和obj2互相引用，造成引用计数无法为0，无法释放变量空间，造成内存的浪费<br>7.标记清除算法实现原理<br>·核心思想:分标记和清除二个阶段完成<br>·遍历所有对象找标记活动对象<br>·遍历所有对象清除没有标记对象<br>·回收相应的空间<br> <img src="https://snakexu.github.io/images/lagou/part_1/performance/7_1.png"><br> 在标记阶段找到所有可达对象(会递归查找，比如图中global找到A再找到D)，将可达对象进行标记；标记完成之后进行清除，找到没有标记的对象，进行清除，同时将标记阶段做的标记清除，这样就完成了一次垃圾的回收，还会将回收的空间放到空闲列表上，方便后续的程序申请使用。而上图中的a1、b1可能是当前局部作用域，而当前局部作用域执行完成以后空间就会被回收，在global链条下找不到a1、b1，GC机制认为a1、b1是垃圾对象，不进行标记，a1、b1被垃圾回收。<br>8.标记清除算法的优缺点<br>相比引用计数，标记清除解决了循环引用的问题。缺点是容易造成内存空间的碎片化，也就是回收的内存空间在地址上不是连续在一起的，不能使空间得到最大化的使用<br>9.标记整理算法实现原理<br>·标记整理可以看作是标记清除的增强<br>·标记阶段的操作和标记清除一致<br>·清除阶段会先执行整理，移动对象位置<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/9_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/performance/9_2.png"><br>10.常见GC算法总结<br>常见GC算法：<br>·引用计数<br>  可以即时回收垃圾对象<br>  可以即时回收垃圾对象<br>  减少程序卡顿时间<br>  无法回收循环引用的对象<br>  资源消耗较大<br>·标记清除<br>  可以回收循环引用的对象<br>  容易产生碎片化空间，浪费空间<br>  不会立即回收垃圾对象<br>·标记整理<br>  减少碎片化空间<br>  不会立即回收垃圾对象<br>11.认识V8<br>·V8是一款主流的JavaScript执行引擎(chrome浏览器，node平台都是在用V8执行代码)<br>·V8采用即时编译<br>·V8内存设限(V8是为浏览器制造的，现有内存大小对网页应用来说足够使用了；V8内部的垃圾回收机制来说这个内存限制也是合理的)<br>12.V8垃圾回收策略<br>在程序使用过程中我们需要用到很多数据，包括原始数据、对象数据。对于原始数据来说都是程序语言自身来进行控制的，所以我们提到的垃圾回收主要还是存在堆区里的对象数据，因此这个过程是离不开内存操作的，而V8对内存是设置了上限的，因为我们想知道在这种情况下是怎么进行垃圾回收的<br>V8垃圾回收策略<br>·采用分代回收的思想<br>·内存分为新生代、老生代(后面介绍如何划分新生代、老生代)<br>·针对不同对象采用不同算法<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/12_1.png"><br>V8中常用GC算法<br>·分代回收<br>·空间复制<br>·标记清除<br>·标记整理<br>·标记增量<br>13.V8如何回收新生代对象<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/13_1.png"><br>V8内存分配<br>·V8内存空间一分为二(上面图中左边带白色部分为新生代，右边老生代存储区有写明)<br>·小空间用于存储新生代对象(32M|16M)<br>·新生代指的是存活时间较短的对象<br>新生代对象回收实现<br>·回收过程中采用复制算法+标记整理<br>·新生代内存区分为二个等大小空间<br>·使用空间为From，空闲空间为To<br>·活动对象存储于from空间<br>·标记整理后将活动对象拷贝至To(可以得到连续的存储空间)<br>·From与To交换空间完成释放<br>回收细节说明<br>·拷贝过程中可能出现晋升<br>·晋升就是将新生代对象移动至老生代<br>·一轮GC还存活的新生代需要晋升<br>·To空间的使用率超过25%需要晋升(怕将来交换之后新进对象没有操作空间)<br>14.V8如何回收老生代对象<br>老生代对象说明<br>·老生代对象存放在右侧老生代区域<br>·64位操作系统1.4G，32位操作系统700M<br>·老生代对象就是指存活时间较长的对象(例如全局变量，一些闭包中的变量数据)<br>老生代对象回收实现<br>·主要采用标记清除、标记整理、增量标记算法<br>·首先使用标记清除完成垃圾空间的回收<br>·采用标记整理进行空间优化(发现老生代存储空间不满足需求的情况下)<br>·采用增量标记进行效率优化<br>细节对比<br>·新生代区域垃圾回收使用空间换时间<br>·老生代垃圾回收不适合复制算法(相对新生代空间，老生代空间较大，采用复制算法消耗较大)<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/14_1.png"><br>标记增量:将我们当前一整段的垃圾回收拆分成多个小步去实现，从而去替代之前一口气完成的垃圾回收，从而完成程序执行与垃圾回收交替运行，时间安排更加合理<br>15.V8垃圾回收总结<br>·V8是一款主流的JavaScript执行引擎<br>·V8内存设置上限<br>·V8采用基于分代回收思想实现垃圾回收<br>·V8内存分为新生代和老生代<br>·V8垃圾回收常见的GC算法<br>16.Performance工具介绍<br>为什么使用Performance<br>·GC的目的是为了实现内存空间的良性循环<br>·良性循环的基石是合理使用<br>·时刻关注才能确定是否合理<br>·Performance提供多种监控方式<br>通过Performance时刻监控内存<br>Performance使用步骤<br>·打开浏览器输入目标网址<br>·进入开发人员工具面板，选择性能<br>·开启录制功能，访问具体界面<br>·执行用户行为，一段时间后停止录制<br>·分析界面中记录的内存信息<br>17.内存问题的体现<br>内存问题的外在表现<br>·页面出现延迟加载或经常性暂停<br>在网络环境正常的情况下，一般判定内存有问题，而且与GC频繁的垃圾回收操作相关——程序代码中存在瞬间让程序爆掉的代码<br>·页面持续性出现糟糕的性能<br>有可能存在内存膨胀——当前界面为了去达到最佳使用速度会去申请一定的内存空间，而申请的内存空间远大于当前设备所能提供的内存大小<br>·页面的性能随时间延长越来越差<br>通常伴随着内存的泄漏<br>18.监控内存的几种方式<br>界定内存问题的标准<br>·内存泄漏：内存使用持续升高<br>·内存膨胀：在多数设备上都存在性能问题<br>·频繁垃圾回收：通过内存变化图进行分析<br>监控内存的几种方式<br>·浏览器任务管理器<br>·Timeline时序图记录<br>·堆快照查找分离DOM<br>·判断是否存在频繁的垃圾回收<br>19.任务管理器监控内存</p>
<p><pre><br>&lt; button id=”btn” &gt;Add&lt; /button &gt;<br>&lt; script &gt;<br>    const oBtn = document.getElementById(‘btn’);<br>    oBtn.onclick = function(){<br>        let arrList = new Array(1000000)<br>    }<br>&lt; /script &gt;<br></pre><br>写完上面代码，我们打开浏览器，shift+ESC调出浏览器任务管理器，在浏览器任务管理器上右键单击，选择JavaScript内存，在浏览器的任务管理器上会多出JavaScript内存一列<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/19_1.png"><br>上图中内存一列和JavaScript内存一列有什么不同呢？内存一列是原生内存，可以理解为浏览器中DOM节点占据的内存，如果这个值持续增大，那么代表界面中在不断持续的创建新的DOM。JavaScript内存是表示JavaScript堆，这列中我们需要关注的是小括号内的值，表示的是界面中所有可达对象正在使用的内存大小，这个值增大表示，要么在创建新对象，要么当前对象一直在增长。我们点击几次刚才的button，再来看浏览器任务管理器，会看到JavaScript内存变大。借助这样一个方式，我们监控当前浏览器内存的变化。如果JavaScript内存的值一直增大，可以断定程序有问题，但是想知道有什么问题，不是浏览器任务管理器能满足的了。<br>20.Timeline记录内存</p>
<p><pre><br>&lt; button id=”btn” &gt;Add&lt; /button &gt;<br>&lt; script &gt;<br>    const arrList = []<br>    function test(){<br>        for(var i =0; i &lt; 100000; i++){<br>            document.body.appendChild(document.createElement(‘p’))<br>        }<br>        arrList.push(new Array(100000).join(‘x’))//这些操作都是为了引起页面性能明显变化<br>    }<br>    document.getElementById(‘btn’).addEventListener(‘click’,test)<br>&lt; /script &gt;<br></pre><br>打开浏览器开发者工具，选择性能，开始录制，多次点击按钮，结束录制，只展示内存变化<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/20_1.png"><br>这里性能有升有降，证明垃圾回收机制正常起作用了。如果一直是在上升而不下降，那么就有可能是内存泄漏，我们可以具体查看时间线上的节点判断哪里出问题。<br>21.堆快照查找分离DOM<br>什么是分离DOM<br>·界面元素存活在DOM树上<br>·垃圾对象时的DOM节点<br>·分离状态的DOM节点</p>
<p><pre><br>&lt; button id=”btn” &gt;Add&lt; /button &gt;<br>&lt; script &gt;<br>var tmpEle<br>function fn(){<br>    var ul = document.createElement(‘ul’)<br>    for(var i =0; i &lt; 100000; i++){<br>        var li = document.createElement(‘li’)<br>        ul.appendChild(li)<br>    }<br>    tmpEle = ul//我们并没有把新创建的DOM添加到页面中，属于分离DOM的一种<br>}<br>document.getElementById(‘btn’).addEventListener(‘click’,fn)<br>&lt; /script &gt;<br></pre><br>首先我们在页面没有进行操作的时候点击一下堆快照<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/21_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/performance/21_2.png"><br>然后筛选deta，发现没有内容。当我们点击当前页面按钮，再次执行上面的操作，拍摄快照，筛选内容<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/21_3.png"><br>就会发现当前页面有我们在代码里创建的分离DOM，解决方案就是把分离DOM置空</p>
<p><pre><br>&lt; button id=”btn” &gt;Add&lt; /button &gt;<br>&lt; script &gt;<br>var tmpEle<br>function fn(){<br>    var ul = document.createElement(‘ul’)<br>    for(var i =0; i &lt; 100000; i++){<br>        var li = document.createElement(‘li’)<br>        ul.appendChild(li)<br>    }<br>    tmpEle = ul<br>    tmpEle = null<br>}<br>document.getElementById(‘btn’).addEventListener(‘click’,fn)<br>&lt; /script &gt;<br></pre><br>22.判断是否存在频繁GC<br>为什么确定频繁垃圾回收<br>·GC工作时应用程序是停止的<br>·频繁且过长的GC会导致应用假死<br>·用户使用中感知应用卡顿<br>确定频繁的垃圾回收<br>·Timeline中频繁的上升下降<br>·任务管理器中数据频繁的增加减小<br>23.Performance总结<br>·Performance使用流程<br>·内存问题的相关分析<br>·Performance时序图监控内存变化<br>·任务管理器监控内存变化<br>·堆快照查找分离DOM<br>24.代码优化介绍<br>如何精准测试JavaScript性能<br>·本质上就是采集大量的执行样本进行数学统计和分析<br>·使用基于Benchmark.js的 <a href="https://jsperf.com/" target="_blank" rel="noopener">https://jsperf.com/</a> 完成<br>Jsperf使用流程<br>·使用GitHub账号登陆<br>·填写个人信息(非必填)<br>·填写详细的测试用例信息(title、slug)<br>·填写准备代码(DOM操作时经常使用)<br>·填写必要有setup与teardowm代码<br>·填写测试代码片段<br>25.慎用全局变量<br>为什么要慎用<br>·全局变量定义在全局执行上下文，是所有作用域链的顶端(一直会查找到全局作用域，影响性能)<br>·全局执行上下文一直存在于上下文执行栈，直到程序退出(全局变量一直存在影响GC)<br>·如果某个局部作用域出现了同名变量则会遮蔽或污染全局<br>之前我们讲过注册jsperf，然后在jsperf上执行代码，查看差异，就能看出全局变量与局部变量的执行差异<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/25_1.png"><br>26.缓存全局变量<br>将使用中无法避免的全局变量缓存到局部</p>
<p><pre><br>&lt; input type=”button” value=”btn” id=”btn1” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn2” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn3” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn4” &gt;<br>  &lt; p &gt;1111&lt; /p &gt;<br>  &lt; input type=”button” value=”btn” id=”btn5” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn6” &gt;<br>  &lt; p&gt;222&lt; /p&gt;<br>  &lt; input type=”button” value=”btn” id=”btn7” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn8” &gt;<br>  &lt; p&gt;333&lt; /p&gt;<br>  &lt; input type=”button” value=”btn” id=”btn9” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn10” &gt;</pre></p>
<p>  &lt; script &gt;<br>    function getBtn() {<br>      let oBtn1 = document.getElementById(‘btn1’)<br>      let oBtn3 = document.getElementById(‘btn3’)<br>      let oBtn5 = document.getElementById(‘btn5’)<br>      let oBtn7 = document.getElementById(‘btn7’)<br>      let oBtn9 = document.getElementById(‘btn9’)<br>    }</p>
<pre><code>function getBtn2() {
  let obj = document
  let oBtn1 = obj.getElementById(&apos;btn1&apos;)
  let oBtn3 = obj.getElementById(&apos;btn3&apos;)
  let oBtn5 = obj.getElementById(&apos;btn5&apos;)
  let oBtn7 = obj.getElementById(&apos;btn7&apos;)
  let oBtn9 = obj.getElementById(&apos;btn9&apos;)
}
</code></pre><p>  &lt; /script &gt;<br><br>这里要在jsperf中执行上面代码，因为有html代码所以需要一点不同的操作，同学们自己了解一下，执行代码效果<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/26_1.png"><br>27.通过原型对象添加附加方法<br>通过原型新增方法，在原型对象上新增实例对象需要的方法</p>
<p><pre><br>var fn1 = function() {<br>  this.foo = function() {<br>    console.log(11111)<br>  }<br>}<br>let f1 = new fn1()<br>var fn2 = function() {}<br>fn2.prototype.foo = function() {<br>  console.log(11111)<br>}<br>let f2 = new fn2()<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_1/performance/27_1.png"><br>28.避开闭包陷阱<br>闭包特点<br>·外部具有指向内部的引用<br>·在”外部”作用域访问”内部”作用域的数据(这里内、外的概念用的并不是很标准，以后慢慢了解)<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/28_1.png"><br>关于闭包<br>·闭包是一种很强大的语法<br>·闭包使用不当很容易出现内存泄漏<br>·不要为了闭包而闭包</p>
<p><pre><br>function foo(){<br>  var el = document.getElementById(‘btn’);//html页面上存在的一个元素<br>  el.onclick = function(){<br>    console.log(el.id)<br>  }<br>  //如果元素在页面被移除，而上面还调用了el，导致元素引用计数不为0，不能被垃圾回收导致内存泄漏<br>  //这里el置空使btn元素引用计数为0，可以顺利被垃圾回收<br>  el = null<br>}<br></pre><br>29.避免属性访问方法使用<br>JavaScript中的面向对象<br>·JavaScript不需属性的访问方法，所有属性都是外部可见的<br>·使用属性访问方法只会增加一层重定义，没有访问的控制力</p>
<p><pre><br>function Person() {<br>  this.name = ‘icoder’<br>  this.age = 18<br>  this.getAge = function() {<br>    return this.age<br>  }<br>}<br>const p1 = new Person()<br>const a = p1.getAge()<br>//与上面代码进行执行效率对比<br>function Person() {<br>  this.name = ‘icoder’<br>  this.age = 18<br>}<br>const p2 = new Person()<br>const b = p2.age<br></pre><br>上面代码中两种访问方式执行效率对比，得出直接访问属性效率更高<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/29_1.png"><br>30.For循环优化</p>
<p><pre><br>var arrList = []<br>arrList[10000] = ‘icoder’<br>for (var i = 0; i &lt; arrList.length; i++) {<br>  console.log(arrList[i])<br>}<br>for (var i = arrList.length; i; i–) {<br>  console.log(arrList[i])<br>}<br></pre><br>这里主要是想说明如果提前获取要遍历元素的长度比在for循环中每次i &lt; arr.length执行效率要高，尤其在被遍历元素量级很大的时候会比较明显<br>31.选择最优的循环方法</p>
<p><pre><br>arrList.forEach(function(item) {<br>  console.log(item)<br>})<br>for (var i = arrList.length; i; i–) {<br>  console.log(arrList[i])<br>}<br>for (var i in arrList) {<br>  console.log(arrList[i])<br>}<br></pre><br>这里主要对比三种遍历方式执行效率的差异(这里注意for循环是提前计算length，而不是每次循环i &lt; length 这种)<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/31_1.png"><br>可以看出性能角度forEach &gt; for &gt; for…in<br>32.文档随便优化节点添加<br>节点的添加操作必然有回流和重绘， 这两个操作对性能消耗比较大</p>
<p><pre><br>//第一种添加方式<br>for (var i = 0; i &lt; 10; i++) {<br>      var oP = document.createElement(‘p’)<br>      oP.innerHTML = i<br>      document.body.appendChild(oP)<br>}<br>//第二种添加方式<br>const fragEle = document.createDocumentFragment()<br>for (var i = 0; i &lt; 10; i++) {<br>    var oP = document.createElement(‘p’)<br>    oP.innerHTML = i<br>    fragEle.appendChild(oP)<br>}<br>document.body.appendChild(fragEle)<br></pre><br>对比两种添加节点对方式，明显第二种方式添加效率比较好<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/32_1.png"><br>33.克隆优化节点操作<br>当我们要去新增节点，可以先找到一个相似节点去克隆，再把克隆的节点添加到界面(被克隆到节点可能已经具有样式/属性，我们不用再额外添加)</p>
<p><pre><br>//传统方法<br>for (var i = 0; i &lt; 3; i++) {<br>    var oP = document.createElement(‘p’)<br>    oP.innerHTML = i<br>    document.body.appendChild(oP)<br>}<br>//克隆方法<br>var oldP = document.getElementById(‘box1’)//假设已经存在box1节点<br>for (var i = 0; i &lt; 3; i++) {<br>    var newP = oldP.cloneNode(false)<br>    newP.innerHTML = i<br>    document.body.appendChild(newP)<br>}<br></pre><br>采用第二种克隆方法性能优于传统添加节点方式<br>34.直接量替换new Object</p>
<p><pre><br>// 采用字面量<br>var a = [1, 2, 3]<br>// 采用new<br>var a1 = new Array(3)<br>a1[0] = 1<br>a1[1] = 2<br>a1[2] = 3<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_1/performance/34_1.png"><br>采用字面量优于new去创建 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/28/拉勾-JavaScript性能优化/" data-id="ckdbzsinw0055jrxqms642cjb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-TypeScript语言" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/26/拉勾-TypeScript语言/" class="article-date">
  <time datetime="2020-06-26T10:32:05.000Z" itemprop="datePublished">2020-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/26/拉勾-TypeScript语言/">拉勾-TypeScript语言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.课程概述<br>解决JavaScript类型系统的问题，TypeScript大大提高代码的可靠程度。我们这里其实主要讨论的是JavaScript自有类型系统的问题以及如何借助一些优秀的方案解决这些问题，TypeScript是在这个过程中我们涉及到的一门语言，因为TypeScript目前是此类问题最终级的解决方案，所以我们会着重学习TypeScript。本章主要学习:<br>(1)强类型与弱类型<br>(2)静态类型与动态类型<br>(3)JavaScript自有类型系统的问题<br>(4)Flow静态类型检查方案<br>(5)TypeScript语言规范与基本应用<br>2.强类型与弱类型<br>·强类型与弱类型(类型安全)<br>·静态类型与动态类型(类型检查)<br>强类型:在语言层面限制函数的实参类型必须与形参类型相同<br><img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/2_1.png"><br>弱类型:在语言层面不会限制实参的类型<br><img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/2_2.png"><br>由于这种强弱之分并不是某一个权威机构的定义，导致大家在细节方面的认知略有不同，不过总体上是强类型有更强的类型约束，而弱类型中几乎没有什么约束。老师个人认为强类型语言中不能有任意类型的隐式类型转换，而弱类型语言则允许任意的数据隐式类型转换，比如下图我们在终端做了字符串与数字类型的减法操作，并没有报错，因为JavaScript会做隐式类型转换<br><img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/2_3.png"><br>有人会说，JavaScript也会报类型错误，比如<br><img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/2_4.png"><br>这里要注意，我们说的强类型是在语言的语法层面就限制了不允许传入不同类型的值，如果我们传入不同类型的值在编译就报类型错误，而不是等到运行阶段再通过逻辑判断去限制。在JavaScript中所有报出的类型错误都是在代码层面在运行时通过逻辑判断的。<br>总结：强类型不允许随意的隐式转换，而弱类型允许。变量类型允许随时改变的特点不是强弱类型的差异<br>3.静态类型与动态类型<br>静态类型:一个变量声明的时候它的类型就是明确的，声明过后，它的类型就不允许再修改<br>动态类型:运行阶段才能够明确变量类型，而且变量类型可以随时改变<br>在JavaScript中<br><img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/3_1.png"><br>在运行时才明确var定义的foo变量是NUMBER类型，再将number类型的foo修改为字符串，也是允许的。那我们也可以说动态类型语言中的变量没有类型，变量中存放的值是有类型的。JavaScript是一门标准的动态类型语言。<br>4.JavaScript类型系统特征<br>弱类型且动态类型，本身类型系统非常薄弱，所以类型是非常灵活的，也带来了缺点-缺失了类型系统的可靠性。为什么JavaScript不能设计成强类型/静态类型的语言？因为早期JavaScript应用简单，几十行代码是非常够用的，这时候类型系统就显得很多余了；另外就是JavaScript是一门脚本语言，没有编译环节，而静态类型语言需要在编译阶段做静态类型检查。基于以上原因，JavaScript成为了一门更灵活(弱类型/静态类型)的语言。而随着JavaScript开发的项目规模越来越大，这些曾经的优势变为了短板。<br>5.弱类型的问题</p>
<pre>
const obj = {}
obj.foo()//报错，运行时才能发现错误
function sum(a,b){
    return a+b
}
console.log(sum(100,100))
console.log(sum(100,'100'))//变成了字符串拼接，类型不明确导致函数功能发生改变
obj[true] = 100
console.log(obj['true'])//在对象中属性名默认为string，对对象索引器的错误用法 
</pre>
综上，在代码规模比较小的情况下，弱类型的弱势并不是很明显，但是在开发周期长的大型项目中，弱类型的弱势就很明显了，而君子协议的约定是有隐患的，强制约定才是一种保障，提前消灭一大部分异常而不必等到运行时再慢慢debug
6.强类型的优势
6-1.错误更早暴露
6-2.代码更智能，编码更准确
6-3.重构更牢靠
6-4.减少不必要的类型判断
7.Flow概述
JavaScript的类型检查器。可以在需要的地方写上类型，而在生产环境可以通过babel等消除，而且不必对每一个变量都写类型注解，可以说非常方便
8.Flow快速上手
创建一个项目，安装flow
//老师课程里是用yarn安装使用的flow，我在本地项目用的npm按装使用，用npm安装和普通插件安装一样，如何使用参考
//https://blog.csdn.net/qq_38785020/article/details/89642800
<pre>
// @flow//这里必须要写，是告诉flow，我需要你检查这个文件
function sum (a: number, b: number) {
  return a + b
}
sum(100, 100)
sum(100, '100')//Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ 01-getting-started.js:7:10
               //Cannot call sum with '100' bound to b because string [1] is incompatible with
               //number [2]. [incompatible-call]
</pre>
执行npm run flow的部分结果如下图
<img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/6_1.png">
9.Flow编译移除注解
为了类型检查，我们给代码添加了一些注解，这些注解并不是JavaScript的标准语法，以至于js是无法正常运行的，如果想运行，那么就要在开发过后移除这些类型注解。移除这些注解，现在有两种方式，一种就是官方推荐的flow-remove-types，这是最快速最简单的办法。首先安装flow-remove-types，然后在package.json文件的script中添加"remove":"flow-remove-types . -d dist"，此时执行npm run remove就可以看到当前目录下生成了dist文件夹，dist文件夹中无类型注解。
flow-remove-types命令:flow-remove-types 要移除注解的文件夹 -d 输出文件夹
另外一个方法就是通过babel去移除。这里需要安装@babel/core(babel的核心模块)、@babel/cli、@babel/preset-flow。然后添加.babelrc文件，文件中内容
{
    "preset":["@babel/preset-flow"]
}
执行的命令是:babel 执行目录 -d 输出目录
这两种方案选哪种合适？如果你的项目中已经引入babel，那么babel/preset-flow就挺好的，其实到底用哪种自己根据项目考虑最合适的就好
9.Flow开发工具插件
上面我们都是在命令行执行flow检查错误，并不能在代码中直观看到问题到底在哪儿，用户体验差了一些，我们可以在vscode中搜索Flow Language Support，这个是Flow官方提供的插件
https://flow.org/en/docs/editors flow官网对编辑器插件支持的情况
10.Flow 类型推断
Flow会根据我们的代码聪明的做一些类型推断
<pre>
function square(n){
    return n*n
}
square('10')//即使我们在没有给函数添加类型注解的情况下，如果我们输入字符串作为参数，也会报错
</pre>
11.Flow 类型注解
尽管flow很聪明的帮我们做一些类型推断，但是我们还是写上注解比价好，这样方便程序的理解。另外Flow的几个基础用法
<pre>
/**类型注解
*
*@flow
*/
function square(n:number){
    return n*n
}
let num:number = 10
function foo():number{//返回值类型为number，如果没有返回值，可以写void
    //return 101//不报错
    //return 'string'//报错
}
</pre>
13.Flow 原始类型
<pre>
const a: string = 'foobar'
const b: number = Infinity // NaN // 100
const c: boolean = false // true
const d: null = null
const e: void = undefined
const f: symbol = Symbol()
</pre>
14.Flow 数组类型
<pre>
/**
 * 数组类型
 *
 * @flow
 */
const arr1: Array< number > = [1, 2, 3]//这里和tyescript很像，指定了数组里所有元素的类型都为number
const arr2: number[] = [1, 2, 3]
// 元组
const foo: [string, number] = ['foo', 100]
</pre>
15.Flow 对象类型
<pre>
/**
 * 对象类型
 *
 * @flow
 */
const obj1: { foo: string, bar: number } = { foo: 'string', bar: 100 }
const obj2: { foo?: string, bar: number } = { bar: 100 }//?是可选项
const obj3: { [string]: string } = {}//默认给对象添加属性的方法是可以的
obj3.key1 = 'value1'
obj3.key2 = 'value2'
</pre>
16.Flow 函数类型
<pre>
/**
 * 函数类型
 *
 * @flow
 */
function foo (callback: (string, number) => void) {
  callback('string', 100)
}
foo(function (str, n) {
  // str => string
  // n => number
})
</pre>
在之前，我们已经把基础的函数类型注解了解过了，这里主要是如果函数参数是callback函数如何注解
17.Flow 特殊类型
<pre>
/**
 * 特殊类型
 *
 * @flow
 */

// 字面量类型
const a: 'foo' = 'foo'
const type: 'success' | 'warning' | 'danger' = 'success'
// ------------------------
// 声明类型
type StringOrNumber = string | number
const b: StringOrNumber = 'string' // 100
// ------------------------
// Maybe 类型
const gender: ?number = undefined
// 相当于
// const gender: number | null | void = undefined
</pre>
18.Flow Mixed与Any
Mixed和Any都可以接收任意类型的值，但是不同点在于Mixed更接近于强类型的概念，Any更接近于弱类型的概念
<pre>
/**
 * Mixed Any
 *
 * @flow
 */
// string | number | boolean | ....
function passMixed (value: mixed) {
  //value.substr(1)
  //value * value////先按字符串类型运算再按数值类型运算会报错
  if (typeof value === 'string') {
    value.substr(1)
  }
  if (typeof value === 'number') {
    value * value
  }
}
passMixed('string')
passMixed(100)
// ---------------------------------
function passAny (value: any) {
  value.substr(1)
  value * value//先按字符串类型运算再按数值类型运算不会报错
}
passAny('string')
passAny(100)
</pre>
19.Flow 类型小结
https://flow.org/en/docs/types/ 对flow中所有类型的一个总结，因为我们不会逐个讲flow的类型
https://www.saltycrane.com/cheat-sheets/flow-type/latest/ 一个第三方的类型手册，可以更方便做查询
20.Flow 运行环境API
Flow在不同的运行环境，比如在浏览器和在node会有一些不同的类型注解
<pre>
/**
 * 运行环境 API
 *
 * @flow
 */
const element: HTMLElement | null = document.getElementById('app')
</pre>
一些API说明文件的链接
<img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/20_1.png">
21.TypeScript概述
TypeScript是基于JavaScript基础之上的编程语言，很多时候我们都在说是JavaScript的超集。由于TypeScript可以编译为JavaScript，那么任何支持JavaScript的运行环境都支持TypeScript。TypeScript功能比Flow更为强大，生态也更健全更完善。可以是TypeScript是前端开发的第二语言。但是再好的语言也会有一些缺点
缺点一:语言本身多了很多概念
TypeScript属于“渐进式”，就是即使我们对TypeScript的概念并不了解，仍可以按照JavaScript的标准语法去编写TypeScript代码，在开发过程中了解一个特性就可以使用一个特性
缺点二:项目初期，TypeScript会增加一些成本
但是随着项目的发展，这些一开始的开销反而会变成优势
22.TypeScript快速上手
首先新建项目，在项目中安装typescript，安装完成后我们在node_modules文件夹下看到.bin目录，在.bin目录下看到tsc，这是一个命令，这个命令的作用就是帮我们编译typescript代码。新建一个typescript文件01-getting-started.ts。虽然我们还不了解typescript，但是完全可以按照JavaScript的标准语法先来编写typescript的代码，而且typescript支持最新的ECMAScript标准。
<pre>
const hello = (name)=>{
    console.log(`hello ${name}`)
}
hello('TypeScript')
</pre>
在命令行执行tsc 01-getting-started.ts命令，然后就可以看到在项目的根目录下多了一个同名的js文件，js文件的内容是
<pre>
var hello = function (name) {
    console.log("hello " + name);
};
hello('TypeScript');
</pre>
通过tsc命令可以把我们的代码转换成了ES3标准的代码。另外对于类型检验，和Flow很像，比如
<pre>
const hello = (name:string)=>{
    console.log(`hello ${name}`)
}
hello('TypeScript')
hello(100)//执行tsc命令的时候报错
</pre>
tsc命令实际上就是TypeScript compile，这个命令去编译ts文件。在编译过程中，首先会检查typescript的类型使用是否异常，然后移除类型注解之类的扩展语法，并且在这个过程中会自动转换ES新特性为ES3标准的JavaScript
23.TypeScript配置文件
tsc命令不仅可以编译单个文件，还可以编译整个项目或者说整个工程。在编译整个项目之前，我们会先给这个项目创建一个typescript的配置文件，在命令行执行tsc --init 命令，可以看到生成了一个tsconfig.json文件。打开这个文件，我们简单看一下，这里大部分内容都被注释掉了，这里我们简单了解几个
<pre>
"target": "es5", //tsc命令将ts代码转换为甚么标准，这里是转换为es5标准
"module": "commonjs", //以commonjs标准执行模块化
"sourceMap": true,  //开启源代码映射
"outDir": "dist",  //tsc命令编译结果输出文件夹
"rootDir": "src",  //项目源代码文件夹
"strict": true,  //开启严格模式
</pre>
在严格模式下，不能不指定类型注解(在非严格模式下，不写类型注解被默认推断为any，在严格模式下，即使是any类型也要明确指定)。如果我们已经有配置文件，但是依然编译单个文件而不是整个项目，那么配置文件是不生效的，只有在用tsc命令编译整个项目的时候，配置文件才生效。此时执行tsc命令编译整个项目，会报错:
error TS6059: File '/myTypeScript/01-getting-started.ts' is not under 'rootDir' '/myTypeScript/src'. 'rootDir' is expected to contain all source files.
Found 1 error.
说明我们的配置文件已经生效了。
现在我们在项目下新建src文件夹，把之前编译生成的js文件删除，把ts文件移到src文件夹中，再次执行tsc命令，就会看到在根目录下多了dist文件夹，文件夹下有01-getting-started.js文件和01-getting-started。map文件。js文件内容如下
<pre>
"use strict";
var hello = function (name) {
    console.log("hello " + name);
};
hello('TypeScript');
//# sourceMappingURL=01-getting-started.js.map
</pre>
24.TypeScript原始类型
TypeScript大部分原始类型的用法和Flow很像。
<pre>
const a:string = 'foo'
const b:number = 100 //NaN //Infinity
const c:boolean = true //false
const d:string = null //严格模式下会报错
</pre>
上面这些在非严格模式下是允许为空/null，在非严格模式下是不允许为空的。tsconfig中的strict是开启所有严格检查的选项，如果只是检查变量不能为空，可以使用
<pre>
"strictNullChecks": true, 
</pre>
<pre>
const e:void=undefined//在函数没有返回值的时候标记返回值类型，只能存放undefined/null,严格模式下只能存放undefined
const f:null = null
const g:undefined = undefined
const h:symbol = Symbol()//报错，为什么报错？下回分解
</pre>
25.TypeScript标准库声明
<pre>
const h:symbol = Symbol()//报错，为什么报错，需要设置"target": "es2015"
</pre>
symbol是ES2015中新增的标准类型，symbol自身也是有类型的，而且这些类型在typescript中已经帮我们定义好了。在页面中写Array，然后在Array上单击右键，点击Goto Definition
<img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/25_1.png">
能看到lib.es5.d.ts，这里声明了所有内置对象定义的类型，但是我们看到文件名中包含es5，这是一个es5所对应的标准库声明，但是symbol是es2015定义的内置类型，所以在es5定义的标准库中不能正确声明。但是如果我们既想编译到es5标准又想用es2015的标准怎么办呢？找到tsconfig配置文件中的lib选项
<pre>
lib": ["ES2015"],
</pre>
但是打开ts文件会发现console报错了，真是让人秃头，你猜怎么解决，没错，再次找到配置文件(因为console是浏览器环境下BOM对象提供的，所以要添加相应的标准库，谁让我们刚才写ES2015之后，别的标准库就被覆盖了呢)，然后在lib中添加DOM(ts中DOM和BOM合并成为DOM，可以少写几个字母，开心么)
<pre>
lib": ["ES2015","DOM"],
</pre>
总结一下就是标准库就是内置对象所对应的声明，在代码中使用内置对象就要引用所对应的标准库，否则ts就找不到对应的标准类型就会报错
26.TypeScript中文错误消息
ts会根据使用编辑器的语言来显示信息，但是很无奈，我们用的编辑器大部分都是英文的，不过ts还是有办法的，在执行tsc命令的时候
<pre>
tsc --locale zh-CN
</pre>
编辑器其实也有相应的语言转换插件，但是不建议使用，毕竟英文更有助于我们搜索问题
27.TypeScript作用域问题
我们在不同文件中定义const a，那么如果是在全局作用域中定义的话，就会报错，比如
<pre>
a.ts
const a:string = 'foo'
b.ts
const a:number = 1
</pre>
一种解决方案就是把他们放到不同的作用域中，例如我们可以用一个立即执行函数
<pre>
a.ts
const a:string = 'foo'
b.ts
(function(){
    const a:number = 1
})
</pre>
或者添加一个exprot，这样变量就变成模块的局部成员了
<pre>
a.ts
const a:string = 'foo'
b.ts
const a:number = 1
exports{}
</pre>
28.TypeScript Object类型
ts中的Object泛指所有非原始类型，对象、数组、函数
<pre>
export{}//确保与其他示例没有成员冲突
const foo:object = function(){}//[]//{}
const obj:{foo:string,bar:number}={foo:'123',bar:456}//必须一一对应，最好用接口类型
</pre>
29.TypeScript 数组类型
<pre>
export {} // 确保跟其它示例没有成员冲突
// 数组类型的两种表示方式
const arr1: Array< number > = [1, 2, 3]
const arr2: number[] = [1, 2, 3]
// 案例 -----------------------
// 如果是 JS，需要判断是不是每个成员都是数字
// 使用 TS，类型有保障，不用添加类型判断
function sum (...args: number[]) {
  return args.reduce((prev, current) => prev + current, 0)
}
sum(1, 2, 3) // => 6
sum(1,2,3,'p')//报错
</pre>
30.TypeScript 元组类型
元组就是一种特殊的数据结构，明确元素数量和元素类型的数组，各个元素的类型不必要完全相同。在ts中可以使用类似数组字面量来定义元组的类型
<pre>
const tuple: [number, string] = [18, 'zce']
// const age = tuple[0]
// const name = tuple[1]
const [age, name] = tuple
// ---------------------
const entries: [string, number][] = Object.entries({
  foo: 123,
  bar: 456
})
const [key, value] = entries[0]
// key => foo, value => 123
</pre>
31.TypeScript 枚举类型
枚举类型有两个特点：(1)可以给一组数值取一个更好理解的名字(2)一个枚举中只会存在固定的值，并不会有超出范围的可能性
在传统语言中枚举是很常见的数据结构，但是在JavaScript中并没有这种数据结构，很多时候都是使用一个对象模拟枚举
<pre>
// 用对象模拟枚举
const PostStatus = {
  Draft: 0,
  Unpublished: 1,
  Published: 2
}
// 标准的数字枚举
enum PostStatus {
  Draft = 0,//枚举类型的值可以不用等号去指定
  Unpublished = 1,//如果不指定值，默认枚举中的值从0开始累加
  Published = 2
}
const post = {
  title: 'Hello TypeScript',
  content: 'TypeScript is a typed superset of JavaScript.',
  status: PostStatus.Draft // 3 // 1 // 0 //使用枚举 枚举名称.成员名称
}
// 字符串枚举
enum PostStatus {
  Draft = 'aaa',//字符串不能自增，所以必须指定每个值
  Unpublished = 'bbb',
  Published = 'ccc'
}
</pre>
枚举类型会入侵到我们运行时代码——会影响我们编译后的结果。我们在ts中使用的大多数类型都会在编译完成后移除掉，因为它只是我们在编译过程中做的类型检查。而枚举会编译为一个双向的键值对对象(双向键值对->可以通过键获取值，也可以通过值获取键)。我们可以试着编译一下我们刚才写的代码
<pre></pre>
32.TypeScript 函数类型
函数的类型约束，无外乎就是对函数的输入输出进行类型限制，输入就是参数，输出就是返回值。不过在js中有两种函数定义的方式，分别是函数声明和函数表达式。
<pre>
function func1(a:number,b:number):string{
    return 'func1'
}
function func2(a:number,b?:number):string{//?参数是可选的
    return 'func2'
}
function func3(a:number,b:number = 1):string{//设置参数默认值
    return 'func3'
}
//可选参数、默认值都要设置在最后一个参数
function func4(a:number,b:number,...rest:number[]):string{//任意个数的参数
    return 'func4'
}
const func5: (a: number, b: number) => string = function (a: number, b: number): string {
  return 'func5'
}
</pre>
33.TypeScript 任意类型
<pre>
function stringify (value: any) {
  return JSON.stringify(value)
}
stringify('string')
stringify(100)
stringify(true)
let foo: any = 'string'
foo = 100
foo.bar()
// any 类型是不安全的
</pre>
any类型约等于不执行任何类型检查
34.TypeScript 隐式类型推断
在ts中如果一个变量没有通过类型注解标记一个变量的类型，ts会通过变量使用情况推断变量的类型——隐式类型推断
<pre>
let age = 18 // 被推断为number类型
// age = 'string'//再把number类型赋值为字符串类型会被报错
let foo//定义的时候没有标记类型注解，ts推断为any类型
foo = 100
foo = 'string'
</pre>
建议为每个变量添加明确的类型标注，后期可以更直观的了解代码
35.TypeScript 类型断言
<pre>
// 假定这个 nums 来自一个明确的接口
const nums = [110, 120, 119, 112]
const res = nums.find(i => i > 0)//这里我们能明确，一定会有大于0的值，但是ts不明确，它会以为有可能返回的是undefined
//const square = res * res//使用的时候不能确定是数字，于是我们断言一定会是数字的
const num1 = res as number //这里是一种断言方式
const num2 = <number>res //另外一种断言方式 // JSX 下不能使用
</number></pre>
这里要明确，类型断言不等于类型转换，并不是把一个类型转换成另外一个类型，类型转换是代码在运行时的一个概念，类型断言是编译过程中的一个概念，在编译过后，类型断言就不会存在了，有本质上的差异
36.TypeScript 接口
理解成一种规范、契约，约定一个对象的结构，去使用一个接口就一定要去遵循这个接口全部的约定。接口最直观的体现就是约定对象中有哪些成员，这些成员的类型是什么样的
<pre>
interface Post {
  title: string
  content: string
}
function printPost (post: Post) {
  console.log(post.title)
  console.log(post.content)
}
printPost({
  title: 'Hello TypeScript',
  content: 'A javascript superset'
})
</pre>
接口就是用来约束对象的结构，一个对象要实现一个接口就要拥有这个对象中所有的成员。如果我们编译一下这个代码会发现编译后的js文件中并没有任何与接口有关的痕迹，ts中的接口只是为我们有结构的数据进行类型约束，在实际运行中没有太大的意义
37.TypeScript 接口补充
<pre>
interface Post {
  title: string
  content: string
  subtitle?: string//可选成员
  readonly summary: string//只读成员
}
const hello: Post = {
  title: 'Hello TypeScript',
  content: 'A javascript superset',
  summary: 'A javascript'
}
hello.summary = 'other'//只读成员初始化完成修改之后再修改会报错
interface Cache {
  [prop: string]: string//动态成员，prop这个不是固定的名字，可以按需求自己设置
}
const cache: Cache = {}
cache.foo = 'value1'
cache.bar = 'value2'
</pre>
38.TypeScript 类的基本使用
类-描述一类具体事物的抽象特征，用来描述一类具体对象的抽象成员。ES6以前，js通过函数+原型模拟实现类，ES6开始有了专门的class。TypeScript增强了class的相关语法
<pre>
class Person {
  name: string // = 'init name'
  age: number  //在下面赋值之前要先定义
  constructor (name: string, age: number) {
    this.name = name
    this.age = age
  }
  sayHi (msg: string): void {
    console.log(`I am ${this.name}, ${msg}`)
  }
}
</pre>
39.TypeScript 类的访问修饰符
<pre>
class Person {
  public name: string // = 'init name'
  private age: number
  protected gender: boolean
  constructor (name: string, age: number) {
    this.name = name
    this.age = age
    this.gender = true
  }
  sayHi (msg: string): void {
    console.log(`I am ${this.name}, ${msg}`)
    console.log(this.age)
  }
}
class Student extends Person {
  private constructor (name: string, age: number) {
    super(name, age)
    console.log(this.gender)
  }
  //private只能在类内被访问，所以定义静态方法在类内实例化
  static create (name: string, age: number) {
    return new Student(name, age)
  }
}
const tom = new Person('tom', 18)
console.log(tom.name)
// console.log(tom.age)
// console.log(tom.gender)
const jack = Student.create('jack', 18)
</pre>
40.TypeScript 类的只读属性
<pre>
class Person {
  public name: string // = 'init name'
  private age: number
  // 只读成员
  protected readonly gender: boolean
  constructor (name: string, age: number) {
    this.name = name
    this.age = age
    this.gender = true
  }
  sayHi (msg: string): void {
    console.log(`I am ${this.name}, ${msg}`)
    console.log(this.age)
  }
}
const tom = new Person('tom', 18)
console.log(tom.name)
// tom.gender = false//只读属性只能赋值一次，并且赋值之后不能再修改
</pre>
41.TypeScript 类与接口
<pre>
//其实Eat与Run两个接口可以合并成一个接口，但是简单细化更好
interface Eat {
  eat (food: string): void
}
interface Run {
  run (distance: number): void
}
class Person implements Eat, Run {
  eat (food: string): void {
    console.log(`优雅的进餐: ${food}`)
  }

  run (distance: number) {
    console.log(`直立行走: ${distance}`)
  }
}
class Animal implements Eat, Run {
  eat (food: string): void {
    console.log(`呼噜呼噜的吃: ${food}`)
  }

  run (distance: number) {
    console.log(`爬行: ${distance}`)
  }
}
</pre>
42.TypeScript 抽象类
抽象类与接口有点像，都是约束子类中必须有某一个成员，区别在于抽象类可以包含一些具体实现，但是接口只能是成员的抽象，不能包含具体的实现。
<pre>
//抽象类 抽象类只能被继承，不能被new
abstract class Animal {
  eat (food: string): void {
    console.log(`呼噜呼噜的吃: ${food}`)
  }
  //抽象方法，不需要方法体 父类如果有抽象方法，子类必须实现这个抽象方法
  abstract run (distance: number): void
}
//继承抽象类
class Dog extends Animal {
  run(distance: number): void {
    console.log('四脚爬行', distance)
  }

}
const d = new Dog()
d.eat('嗯西马')
d.run(100)
</pre>
43.TypeScript 泛型
在定义函数、接口、类的时候没有指定具体的类型，等到使用的时候再具体指定一个类型。泛型就是声明函数的时候不去指定具体的类型，等到调用的时候再传递具体的类型，为了最大程度复用代码
<pre>
function createNumberArray (length: number, value: number): number[] {
  //由于Array对象默认创建的是any类型的数组，需要指定一下元素类型，这里通过泛型参数传递一个类型
  //这里Array是一个泛型类，在ts中定义这个类的时候并不知道我们会用它存放什么样类型的数据，所以使用泛型参数，再调用的时候再传递一个具体类型
  const arr = Array< number >(length).fill(value)
  return arr
}
const res = createNumberArray(3, 100)
res => [100, 100, 100
</pre>
上面我们定义了一个数字数组，如果我们又需要一个字符串数组，难道要再定义一个？
<pre>
function createStringArray (length: number, value: string): string[] {
  const arr = Array< string >(length).fill(value)
  return arr
}
</pre>
这么做有点傻，更好的方法是使用泛型
<pre>
function createArray< T > (length: number, value: T): T[] {
  const arr = Array< T >(length).fill(value)
  return arr
}
const res = createArray< string >(3, 'foo')
</pre>
44.TypeScript 类型声明
我们经常在使用npm安装一些第三方模块的时候不一定是ts编写的，这个时候可以用类型声明，即一个成员在定义的时候没有明确的类型声明，我们在使用的时候可以定义一个类型声明
<pre>
import { camelCase } from 'lodash' //假设lodash没有ts版本的声明模块
declare function camelCase (input: string): string
const res = camelCase('hello typed')
</pre>
如果有ts声明模块我们可以安装ts模块，比如lodash有types声明文件 @types/lodash，我们可以在开发环境安装声明文件，因为不会提供具体代码，只是提供类型声明。而query-string模块有类型声明文件，我们可以直接使用
<pre>
import qs from 'query-string'
qs.parse('?key=value&key2=value2')
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/26/拉勾-TypeScript语言/" data-id="ckdbzsipr005fjrxqa465umxo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-ECMAScript新特性" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/拉勾-ECMAScript新特性/" class="article-date">
  <time datetime="2020-06-21T10:12:12.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/拉勾-ECMAScript新特性/">拉勾-ECMAScript新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.课程介绍<br>这里主要是对本章节课程简单概述，就不详细记录了<br>2.ECMAScript概述<br>ECMAScript也是一门脚本语言，通常缩写为es，通常看作JavaScript的标准化规范。实际上JavaScript是ECMAScript的扩展语言。 ECMAScript只提供了最基本的语法，也就说约定了代码该如何编写，例如该怎么定义变量和函数以及分支、循环之类的语句。JavaScript实现了ECMAScript的语言标准并且在这个基础之上实现了一些扩展，使得我们可以在浏览器环境中操作DOM和BOM，在node环境中可以做读写文件之类的操作。总之，浏览器环境中的JavaScript就是ECMAScript和webAPI(也就是我们所说的DOM和BOM)。在node环境中的JavaScript就是ECMAScript和node环境提供的API(fs,net…)。JavaScript语言本身指的就是ECMAScript。从2015年ECMAScript就保持着每年一个大版本的迭代，导致JavaScript这门语言本身变得越来越高级，越来越便捷。下图是目前为止所有ECMAScript的标准名称和版本号、发行时间<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/2_1.png"><br>其中ES2015是一个比较重要的点，也是从2015开始按照年份命名，由于一下子没适应从之前的版本号命名变成年份命名，所以ES2015也被称为ES6。<br>3.ES2015概述<br>ES2015也可以叫做ES6，可以说是新时代ECMAScript标准的代表版本——相比上一个版本变化比较大，自此命名规则发生变化。有人喜欢用ES6泛指ES6之后所有的新标准，例如有人说使用ES6之中的async/await，但是实际上async/await是ES2017中制定的新标准。所以需要注意分辨资料中的ES6是特指还是泛指。如果可以，建议阅读ES2015完整语言规格文件，因为包含了新特性/新特性之后的所有语言标准规范。这是链接<a href="https://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">https://www.ecma-international.org/ecma-262/6.0/</a><br>本章节主要介绍ES5.1基础之上的变化，并且主要介绍一些变化大/值得我们单独了解的新特性。主要归为4类:<br>·解决原有语法上的一些问题/不足(如let、const的块级作用域)<br>·对原有语法进行增强(如解构、默认值)<br>·全新的对象/全新的方法/全新的功能(promise、proxy等)<br>·全新的数据类型/数据结构(symbol/set等)<br>4.ES2015准备工作<br>可以使用node环境，也可以使用最新版本的chrome浏览器，老师用的node版本为12.13.0。同时还需要nodemon的小工具，修改完代码后自动执行<br>5.ES2015 let与块级作用域<br>作用域-代码中某个成员能够起作用的范围，在ES2015之前，es只有两种类型的作用域，分别是<br>·全局作用域<br>·函数作用域<br>在ES2015中新增了一个<br>·块级作用域<br>块——在代码中用花括号包裹起来的范围。以前块没有独立作用域</p>
<pre>
for(var i=0; i < 3; i++){
    for(var i=0; i < 3; i++){
        console.log(i)
    }
    console.log('内层结束 i = '+i)
}
</pre>
执行结果
//0
//1
//2
//内层结束 i = 3
造成以上执行结果的原因是:外层声明了i过后，内层再次声明了这个变量，而且都是使用var去声明变量的，也就是说并不是一个块级作用域内的成员，而是全局成员，那么内层声明i就会覆盖掉之前声明的i，内层循环结束后，i=3，那么外层拿到的i也就是i=3，不满足外层循环的条件，自然就不会循环了。如果把var换成let，那么就能解决我们遇到的这个问题，因为let有块级作用域。但是我们这里不鼓励这种同名变量，对于以后程序的理解有很大麻烦。
在我们循环注册事件时，在事件的处理函数中，要访问循环的计数器，这种情况下，以前机会出现一些问题
<pre>
var elements = [{},{},{}]
for(var i=0; i < elements.length;i++){
    elements[i].onclick = function(){
        console.log(i)//获取的是外层的i，在执行完后，无论从哪里调用，i的值都已经是3了
    }
}
elements[0].onclick()//3
elements[1].onclick()//3
elements[2].onclick()//3
</pre>
通过闭包解决这个问题——借助函数作用域摆脱全局作用域所产生的影响
<pre>
var elements = [{},{},{}]
for(var i=0; i < elements.length;i++){
    elements[i].onclick = (function(){
        console.log(i)
    })(i)
}
elements[0].onclick()//0
elements[1].onclick()//1
elements[2].onclick()//2
</pre>
借助let的块级作用域解决问题
<pre>
var elements = [{},{},{}]
for(let i=0; i < elements.length;i++){
    elements[i].onclick = function(){
        console.log(i)
    }
}
elements[0].onclick()//0
elements[1].onclick()//1
elements[2].onclick()//2
</pre>
其实在上面代码中本质也是闭包的机制， onclick执行的时候，循环已经结束，实际的i已经被销毁了，通过闭包的机制才能拿到相应的i
<pre>
for(let i=0; i < elements.length;i++){
    let i = 'foo'
    console.log(i)//得到三次foo
}
</pre>
上面代码表明两个i没有相互影响，没有在同一个作用域当中。如果这样不好理解，那我们把上面的代码拆解开，用if的方式去演示
<pre>
let i = 0;
if(i < 3){

    let i = 'foo'
    console.log(i)
}
i++
if(i < 3){
    let i = 'foo'
    console.log(i)
}
i++
if(i < 3){
    let i = 'foo'
    console.log(i)
}
i++
</pre>
上面代码模拟了循环的完整过程
另外let不会像var一样发生变量提升的情况，至于为什么不继续用var升级而改用let，主要是考虑到很多项目如果这样升级势必造成影响。
6.ES2015 const
定义一个恒量/常量，在let的基础上多了一个"只读"特性，即变量声明之后不可以再修改
<pre>
const name = "zce"
name = "jack"//报错
</pre>
声明的同时要赋值
<pre>
const name
name = "zce"//报错
</pre>
其实这里说的声明的成员不能被修改，指的是不允许在声明过后重新指向一个内存地址，并不是说不允许修改恒量中的成员
<pre>
const obj = {}
obj.name = "zce"//不报错，没有修改obj指向的内存地址，修改了内存地址空间的数据
obj = {}//报错，因为重新为obj指了一个新的地址
</pre>
老师的个人最佳实践是不用var(比如先使用后定义并不是一个好的编程习惯)，主要用const(更明确代码中的成员是否会被修改)，配合let定义必须要修改的值
7.ES2015数组的解构
<pre>
const arr = [100,200,300]
const [foo,bar,baz] = arr
console.log(foo,bar,baz) //100,200,300
//或者如果只想获取第三个成员
const [,,baz] = arr // 300
//提取从当前位置往后的所有成员
const [foo,...rest] = arr //...rest的用法只能在最后一个位置使用
console.log(rest) //[200,300]
//解构成员数组长度小于被解构数组长度，会从前到后提取
const [foo,bar] = arr
console.log(foo,bar); //100,200
//如果解构成员长度大于数组长度，提取到的是undefined
const [foo,bar,baz,more] = arr
console.log(more)//undefined
//如果需要给提取到的下标设置默认值
const [foo,bar,baz,more = 'defalut value'] = arr
console.log(bar,more)//200"defalut value"
</pre>
举例用到解构的好处
<pre>
const path = "/foo/bar/baz";
//const tmp = path.split('/');
//const rootdir = tmp[1]//这种方案需要多用到一个中间变量
const [,rootdir] = path.split('/')
console.log(rootdir)
</pre>
8.ES2015对象的解构
对象的解构和数组的解构很相似，不同之处在于对象没有下标，我们通过变量解构
<pre>
const obj = { name:'zce',age:18}
const { name } = obj
console.log(name)
const { age } = obj
console.log(age)
</pre>
没有匹配到的成员值为undefined，也可以设置默认值。在对象中我们解构的变量名同时用来匹配被解构对象当中的属性名，所以如果当前作用域中有同名的成员就会产生冲突
<pre>
const obj = { name:'zce',age:18}
const name = 'tom'
const { name } = obj
console.log(name)//报错
</pre>
解决的方式是重命名
<pre>
const obj = { name:'zce',age:18}
const name = 'tom'
const { name:objName = 'jace' } = obj//jack为设置默认值
console.log(objName)//zce
</pre>
应用场景的例子
<pre>
const { log } = console
log('foo')
log('bar')
</pre>
简化了代码的编写，减小了代码整体的体积
9.ES2015模版字符串
<pre>
const str = `hello es2015,this is a \`string\``
console.log(str)//hello es2015,this is a `string`
const str1 = `hello es2015,
this is a \`string\``//支持换行
const name = 'tom' 
//${可以嵌入任何标准的js语句}，例如变量
const msg = `hey,${name}---${1+2}---${Math.random()}`//hey,tom---3---0.2061239309540519
</pre>
10.ES2015带标签的模版字符串
<pre>
const str = tag`hello world`//tag是一个标签，是一个特殊的模版字符串函数，这里没有tag这个函数，所以这里会报错
const str1 = console.log`hello world`//console.log作为模版字符串的标签//['hello','world']
</pre>
为什么打印的是数组呢？我们一步步探寻
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings){
    console.log(strings)
}
const result = myTagFunc`hey,${name} is a ${gender}`
</pre>
<img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/10_1.png">
上面打印的数组就是我们模版字符串内容分割过后的结果，模版字符串中可能有嵌入的表达式，所以数组就是按照表达式分割过后的静态内容，所以是数组。除了数组以外，这个函数还可以接收所以在模版字符串中出现的函数表达式的返回值。
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    console.log(strings,name,gender)
}
const result = myTagFunc`hey,${name} is a ${gender}`//["hey,", " is a ", "", raw: Array(3)] "tom" true
</pre>
函数的返回值就是带标签的模版字符串对应的返回值
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    //console.log(strings,name,gender)
    return '123'
}
const result = myTagFunc`hey,${name} is a ${gender}`//123
</pre>
如果想返回正常的返回值
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    return strings[0]+name+strings[1]+gender+strings[2]
}
const result = myTagFunc`hey,${name} is a ${gender}`
console.log(result)//hey,tom is a true
</pre>
标签函数的作用就是对模版字符串进行加工
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    const sex = gender ? 'man' : 'woman'
    return strings[0]+name+strings[1]+sex+strings[2]
}
const result = myTagFunc`hey,${name} is a ${gender}`
console.log(result)//hey,tom is a man
</pre>
11.ES2015字符串的扩展方法
·includes()
·startsWith()
·endsWith()
<pre>
const message = 'Error:foo is not defined.'
console.log(message.startsWith('Error'))//true
console.log(message.endsWith('.'))//true
console.log(message.includes('foo'))//true
</pre>
12.ES2015参数默认值
过去是通过逻辑参数来设置默认值
<pre>
function foo(enable){
    enable = enable || true
    console.log('foo invoked - enable:')
    console.log(enable)
}
foo(true)
//foo invoked - enable:
//true
</pre>
但是上面代码有个问题，就是如果传入的是false，会引起错误，所以我们不要使用短路设置默认值
<pre>
function foo(enable){
    enable = enable === undefined ? true : enable
    console.log('foo invoked - enable:')
    console.log(enable)
}
foo(true)
//foo invoked - enable:
//true
</pre>
而有了参数默认值新功能过后，这一切都会变得简单的多
<pre>
function foo(enable = true){
    console.log('foo invoked - enable:')
    console.log(enable)
}
foo(false)
//foo invoked - enable:
//false
</pre>
如果有多个参数，那么带有默认值的参数一定要放在参数列表的最后，因为参数是按照次序传递的，如果有参数的默认值不在最后面的话，默认值将无法正常工作
13.ES2015剩余参数
<pre>
function foo(...args){
    console.log(args)
}
foo(1,2,3,4 )//[1, 2, 3, 4]
</pre>
因为接收的是剩余的所有参数，所以只能出现在参数列表的最后一位，且只能出现一次
14.ES2015展开数组
把数组当中的每一个成员按照次序传递
<pre>
const arr = ['foo','bar','baz'];
console.log(...arr)//foo bar baz
</pre>
15.ES2015箭头函数
<pre>
const inc = n => n+1
console.log(inc(100))
</pre>
对比一下普通函数，会发现箭头函数使我们的代码更简短更易读
<pre>
const arr = [1,2,3,4,5,6,7]
arr.filter(function(item){
    return itme % 2
})
arr.filter(item => item % 2 )
</pre>
16.ES2015箭头函数与this
箭头函数不会改变this的指向
<pre>
const person = {
    name : 'tom',
    sayHi : function(){
        console.log(`hi, my name is ${this.name}`)
    }
}
person.sayHi()//hi, my name is tom
</pre>
对比上面的代码，我们把sayHi方法改变为箭头函数
<pre>
const person = {
    name : 'tom',
    sayHi : () => {
        console.log(`hi, my name is ${this.name}`)
    }
}
person.sayHi()//hi, my name is undefined
</pre>
这种特性可以解决一些问题
<pre>
const person = {
    name : 'tom',
    sayHi : () => {
        console.log(`hi, my name is ${this.name}`)
    },
    // sayHiAsync:function(){
    //      const _this = this //我们要拿到this的指向
    //     setTimeout(function(){
    //         console.log(_this.name)
    //     },1000)
    // }//这里是ES5的方法
    sayHiAsync:function(){
        setTimeout(() => {
            console.log(_this.name)
        })
    }
}
person.sayHiAsync()
</pre>
17.ES2015对象字面量的增强
<pre>
const bar = '123'
const obj = {
    foo:123,
    // bar:bar,//传统方式
    bar,
    // method:function(){
        // console.log('method111')
    // }//传统方式
    method(){
        console.log('method111')
        console.log(this)
    },
    //ES2015动态添加变量属性的方法
    [Math.random()]:123,//计算属性名，表达式的执行结果作为属性的属性名
}
console.log(obj)//{foo: 123, bar: "123", method: ƒ}
console.log(obj.method())//{foo: 123, bar: "123", method: ƒ}
obj[Math.random()] = 123//过去动态添加变量属性的方法 
</pre>
18.ES2015 Object.assign
将多个源对象的属性复制到一个目标对象中，如果对象中有相同的属性，源对象中的属性会覆盖掉目标对象中的属性(从源对象中取，往目标对象中放)
<pre>
const source1 = {
    a:123,
    b:123
}
const target = {
    a:456,
    c:456
}
const result = Object.assign(target,source1)
// console.log(result)//{a: 123, c: 456, b: 123}
// console.log(target)//{a: 123, c: 456, b: 123}
// console.log(result === target)//true
const source2 = {
    b:789,
    d:789
}
const result = Object.assign(target,source1,source2)
console.log(result)//{a: 123, c: 456, b: 789, d: 789}
console.log(target)//{a: 123, c: 456, b: 789, d: 789}
console.log(result === target)//true
</pre>
本质就是用源对象中的属性覆盖目标对象中的属性，用法举例
<pre>
function func(obj){
    obj.name = 'func obj'
    console.log(obj)//{name: "func obj"}
}
const obj = { name : "global obj"}
func(obj)
console.log(obj)//{name: "func obj"}
</pre>
在上面代码中如果在函数内部直接修改对象参数的属性，外界对应的对象也会发生变化，如果只想在函数内部修改属性
<pre>
function func(obj){
    const funcObj = Object.assign({},obj)
    funcObj.name = 'func obj'
    console.log(funcObj)//{name: "func obj"}
}
const obj = { name : "global obj"}
func(obj)
console.log(obj)//{name: "global obj"}
</pre>
19.ES2015 Object.is
<pre>
console.log(
// 0 === false //false
// 0 == false  //true
// NaN === NaN //false,过去认为NaN是一种无限可能的值，所以认为两个NaN不相等
// +0 === -0   //true
//针对NaN!==NaN和+0===-0两种不符合我们日常需求的运算，我们可以用Object.is
// Object.is(NaN,NaN) //true
Object.is(+0,-0) //false
)
</pre>
虽然Object.is在一些地方很好用，但是日常开发还是建议使用===和==运算符
20.ES2015 Proxy
如果我们要监视某个对象的读写，我们需要Object.defineProperty这样的方法来为我们的对象添加属性，这样我们就能捕获对象属性的读写过程。这样的方法使用的非常广泛，比如vue3.0之前就是使用的这样的方法完成双向数据绑定。在ES2015中设计了Proxy类型，为对象设置访问代理器的。相对于Object.defineProperty，proxy功能更为强大使用起来也更为方便。
<pre>
const person = {
    name:'zce',
    age:20
}
const personProxy = new Proxy(person,{
    get(target,prototype){
        console.log(target,prototype);//{name: "zce", age: 20} "name"
        return 100
    },
    set(){}
})
console.log(personProxy.name) //100
</pre>

<pre>
const person = {
    name:'zce',
    age:20
}
const personProxy = new Proxy(person,{
    get(target,prototype){
        return prototype in target ? target[prototype] : 'default'
    },
    set(){}
})
console.log(personProxy.name) //zce
console.log(personProxy.xxx) //default
</pre>

<pre>
const person = {
    name:'zce',
    age:20
}
const personProxy = new Proxy(person,{
    get(target,prototype){
        return prototype in target ? target[prototype] : 'default'
    },
    set(target, prototype, value){
        console.log(target, prototype, value)//{name: "zce", age: 20} "gender" true
    }
})
personProxy.gender = true
</pre>

<p><pre><br>const person = {<br>    name:’zce’,<br>    age:20<br>}<br>const personProxy = new Proxy(person,{<br>    get(target,prototype){<br>        return prototype in target ? target[prototype] : ‘default’<br>    },<br>    set(target, prototype, value){<br>        if(prototype === ‘age’){<br>            if(!Number.isInteger(value)){<br>                throw new TypeError(<code>${value} is not an int</code>)<br>            }<br>        }<br>        target[prototype] = value<br>    }<br>})<br>personProxy.age = ‘aaa’//报错 aaa is not an int<br>personProxy.gender = true<br></pre><br>21.ES2015 Proxy对比defineProperty<br>21-1.Object.defineProperty只能监视到对象属性的读写，proxy能监视到更多对象操作：比如proxy可以监视到delete操作或对对象中方法的调用等</p>
<p><pre><br>const person = {<br>    name:’zce’,<br>    age:20<br>}<br>const personProxy = new Proxy(person,{<br>    deleteProperty(target,prototype){<br>        console.log(‘delete’,prototype);//delete age<br>        delete target[prototype]<br>    }<br>})<br>delete personProxy.age<br>console.log(person)//{name: “zce”}<br></pre><br>下图列举了proxy可以监视的对象的操作<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/21_1.png"><br>21-2.Proxy更好的支持数组对象的监视<br>以往通过Object.defineProperty监视数组的操作往往通过重写数组的操作方法来实现(通过自定义的方法覆盖掉数组原型上的操作)</p>
<p><pre><br>const list = []<br>const listProxy = new Proxy(list,{<br>    set(target, prototype, value){<br>        console.log(‘set’,prototype,value)<br>        target[prototype] = value<br>        return true//表示设置成功<br>    }<br>})<br>listProxy.push(100)<br>//set 0 100<br>//set length 1<br></pre><br>21-3.Proxy是以非侵入的方式监管了对象的读写<br>对一个已经定义好的对象，不需要对对象本身进行任何操作就可以监视到它内部成员的读写，而Object.defineProperty需要我们通过特定的方式单独去定义对象中的需要被监视的属性，对已经存在的对象，我们需要做很多额外的操作</p>
<p><pre><br>const person = {}<br>Object.defineProperty(person,’name’,{<br>    get(){<br>        console.log(‘name 被访问’)<br>        return person._name<br>    },<br>    set(value){<br>        console.log(‘name 被设置’)<br>        person._name = value<br>    }<br>})<br>Object.defineProperty(person,’age’,{<br>    get(){<br>        console.log(‘age 被访问’)<br>        return person._age<br>    },<br>    set(value){<br>        console.log(‘age 被设置’)<br>        person._age = value<br>    }<br>})<br>person.name = ‘jack’<br>console.log(person.name)<br></pre><br>22.ES2015 Reflect<br>统一的对象操作，是一个静态类，也就是说不能通过new去实例化一个对象，只能调用静态类中的一些静态方法(例如Reflect.get())。Relect内部封装了一系列对对象底层的操作，一共13个(定义了14个，但是其中一个已经废弃掉了)，仔细看这13个方法的方法名与Proxy对象中的处理对象方法成员是一致的，相当于是Proxy处理对象方法的默认实现，如果觉得这句话不好理解，可以通过下面的例子理解。</p>
<p><pre><br>const obj = {<br>    foo:’123’,<br>    bar:’456’<br>}<br>const proxy = new Proxy(obj,{<br>    get(target,property){<br>        console.log(‘watch logic~’)<br>        return Reflect.get(target,property)<br>    }<br>})<br>console.log(proxy.foo)//123<br></pre><br>Reflect的主要意义在于提供了一套统一的用于操作对象的API</p>
<p><pre><br>const obj = {<br>    foo:’123’,<br>    bar:’456’<br>}<br>//console.log(‘name’ in obj)//传统判断对象属性是否存在<br>//console.log(delete obj[‘age’])//传统删除对象属性<br>//console.log(Object.keys(obj))//传统遍历对象属性<br>console.log(Reflect.has(obj,’name’))//判断对象属性是否存在<br>console.log(Reflect.deleteProperty(obj,’age’))//删除对象属性<br>console.log(Reflect.ownKeys(obj))//获取对象中所有属性名<br></pre><br>23.ES2015 Promise<br>一种更优的异步编程解决方案，解决了传统异步编程中回调函数嵌套过深的问题<br>24.ES2015 class类<br>从前定义一个类，我们要通过函数、原型去实现</p>
<p><pre><br>function Person(name){<br>    this.name = name<br>}<br>Person.prototype.say = function(){<br>    console.log(<code>hi, my name is ${this.name}</code>)<br>}<br></pre><br>现在我们用class去实现</p>
<p><pre><br>class Person{<br>    constructor(name){<br>        this.name = name<br>    }<br>    say(){<br>        console.log(<code>hi, my name is ${this.name}</code>)<br>    }<br>}<br>const p = new Person(‘tom’)<br>p.say()<br></pre><br>25.ES2015静态方法<br>在类中通常有实例方法和静态方法，实例方法就是通过构造的实例对象去调用，静态方法是通过类型本身去调用。以前实现静态方法就是在构造函数对象去挂载方法来实现，因为在js中函数也是对象，可以添加一些方法成员。ES2015中新增添加静态成员的static关键词</p>
<p><pre><br>class Person{<br>    constructor(name){<br>        this.name = name<br>    }<br>    say(){<br>        console.log(<code>hi, my name is ${this.name}</code>)<br>    }<br>    static create(name){<br>        return new Person(name)<br>    }<br>}<br>const tom = Person.create(‘tom’)<br>tom.say()//hi, my name is tom<br></pre><br>因为静态方法是在当前类中定义的，所以在静态方法内部，this不会指向某一个实例对象而是当前的类型<br>26.ES2015 类的继承<br>通过继承的特性我们就能抽象出来相似的类型之间重复的地方，在ES2015之前大多数情况我们都会通过原型的方式实现继承，在ES2015专门出现了用于继承的关键词extends</p>
<p><pre><br>class Person{<br>    constructor(name){<br>        this.name = name<br>    }<br>    say(){<br>        console.log(<code>hi, my name is ${this.name}</code>)<br>    }<br>}<br>class Student extends Person{<br>    constructor(name,number){<br>        super(name)<br>        this.number = number<br>    }<br>    hello(){<br>        super.say()<br>        console.log(<code>my school number is ${this.number}</code>)<br>    }<br>}<br>const s = new Student(‘jack’,100)<br>s.hello()<br>//hi, my name is jack<br>//my school number is 100<br></pre><br>extends继承比原型继承更方便更清楚一些<br>27.ES2015 Set<br>ES2015提供的全新的数据结构，可以把它理解为集合，与传统的数组非常类似，不过set内部的成员不允许重复，也就是说每一个值在同一个set内部是唯一的。它是一个类型，我们通过用这个类型构造的实例就能用来存放不重复的数据，可以通过集合的add方法往集合中添加数据。由于add方法可以返回集合对象本身，我们可以链式调用，如果我们用add添加了之前已经存在的值，那么这个值就会被忽略掉。想要遍历集合当中的数据，我们可以用forEach方法，也可以通过for…of…。可以通过size属性获取整个集合的长度</p>
<p><pre><br>const s = new Set()<br>s.add(1).add(2).add(3).add(4).add(2)<br>console.log(s)//Set {1,2,3,4}<br>s.forEach(i =&gt; console.log(i))<br>//1<br>//2<br>//3<br>//4<br>for(let i of s){<br>    console.log(i)<br>}<br>//1<br>//2<br>//3<br>//4<br>console.log(s.size)//4<br>console.log(s.has(100))//false，判断集合中是否存在某个特定的值<br>console.log(s.delete(3))//删除集合中某个指定的值，删除成功的话返回true<br>s.clear()//清楚当前集合中全部的内容<br>console.log(s)//Set {}<br></pre><br>最常见的应用场景就是为数组中的元素去重</p>
<p><pre><br>const arr = [1,2,1,3,1,4]<br>const result = new Set(arr)<br>console.log(result)//Set { 1, 2, 3, 4 }<br>//可以用Array.from/[…展开]把Set再次转化成数组<br>const result1 = Array.from(new Set(arr))//[ 1, 2, 3, 4 ]<br>const result2 = […new Set(arr)]//[ 1, 2, 3, 4 ]<br></pre><br>28.ES2015 Map<br>与对象非常相似，本质上都是键值对的集合，但是对象中的键只能是字符串类型，所以说存放复杂数据结构时会有一些问题。有人说我也可以用其他类型的数据做为对象的键，这里我们一起来尝试一下</p>
<p><pre><br>const obj={}<br>obj[true] = ‘value’<br>obj[123] = ‘value’<br>obj[{a:1}] = ‘value’<br>console.log(Object.keys(obj))//[ ‘123’, ‘true’, ‘[object Object]’ ]<br></pre><br>从上面打印结果来看，我们设置的布尔/对象/数字 类型的非字符串类型的键，都被内部toString的结果作为键。看上面的打印结果，我们应该能想到一些问题，设想我们用对象存储学生的考试成绩，假定我们用对象存储每个学生的考试成绩。如果我们用学生对象作为键，那不管每个对象键中的属性有何不同，但是toString的结果都是一样的，就没有办法做到区分</p>
<p><pre><br>console.log(obj[{}])//value<br>console.log(obj[‘[object Object]’])//value<br></pre><br>现在我们明白了问题的所在，Map就是为了解决这样的问题。Map才能算严格意义上的键值对的集合，用来去映射两个任意类型数据之间的关系</p>
<p><pre><br>const m = new Map()<br>const tom = { name:’tom’ }<br>m.set(tom,90)<br>console.log(m)//Map { { name: ‘tom’ } =&gt; 90 }<br>console.log(m.get(tom))//90<br>//m.has()//判断某个键是否存在<br>//m.delete()//删除某个键<br>//m.clear()//清空s所有键值<br>m.forEach((value,key)=&gt;{//遍历<br>    console.log(value,key)<br>})//90 { name: ‘tom’ }<br></pre><br>对象只能用字符串作为键，而Map可以用任意类型数据作为键<br>28.ES2015 Symbol<br>在ES2015之前对象的属性名只能是字符串，字符串是可能会产生冲突的。比如我们设置了全局缓存对象变量cache，而在不同的js文件中我们设置了同一个对象属性，那么就会产生问题，在过去，我们会通过约定来尽量规避这种情况<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/28_1.png"><br>但是约定的方式只是规避了问题，并不是彻底解决问题，ES2015提供了Symbol类型来彻底解决这个问题，作用就是表示一个独一无二的值</p>
<p><pre><br>const s = Symbol()<br>console.log(s)//Symbol()<br>console.log(typeof s)//symbol<br></pre><br>这种类型最大的特点就是独一无二，也就说通过这种方式创建的每一个值都是唯一的，永远不会重复</p>
<p><pre><br>console.log(Symbol() === Symbol())//false<br></pre><br>考虑到在开发过程中的调试，允许我们传入一个字符串作为这个值的描述文本，对于我们多次使用Symbol的情况，就能在控制台中区分出来到底是哪一个对应的Symbol</p>
<p><pre><br>console.log(Symbol(‘foo’))//Symbol(foo)<br>console.log(Symbol(‘bar’))//Symbol(bar)<br>console.log(Symbol(‘baz’))//Symbol(baz)<br></pre><br>从ES2015开始，对象就可以使用Symbol类型的值作为属性名</p>
<p><pre><br>const obj = {}<br>obj[Symbol()] = ‘123’<br>obj[Symbol()] = ‘456’<br>console.log(obj)//{ [Symbol()]: ‘123’, [Symbol()]: ‘456’ }<br>//或者<br>const obj1 = {<br>    [Symbol()]:123<br>}<br>console.log(obj1)//{ [Symbol()]: 123 }<br></pre><br>我们可以通过Symbol的特性来模拟对象的私有成员，假定我们创建了a.js文件</p>
<p><pre><br>//a.js<br>const name = Symbol()<br>const person = {<br>    [name] : ‘zce’,<br>    say(){<br>        console.log(this[name])<br>    }<br>}<br>//b.js<br>//person[Symbol()]//不能访问，因为Symbol成员不能产生完全一样的值<br>person.say()<br></pre><br>在b.js中，我们没有办法再去创建一个完全相同的Symbol，所以无法访问person对象中的Symbol变量的成员，只能访问对象中普通名称的成员。Symbol目前最主要的作用就是为对象添加独一无二的属性名。截止到ES2019，一共定义了6种原始类型和Object数据类型，一共7种数据类型。在未来还会新增一个叫BigInt的原始数据类型，用于去存放更长的数字，目前处于stage-4阶段，预计在下一个版本能正式被标准化，那么ES就是8种数据类型了<br>28.ES2015 Symbol补充<br>Symbol每次生成的都是全新的一个值，如果想去全局复用，可以用全局变量的方式或者使用Symbol类型提供的静态方法，也就是for方法，可以接收一个字符串作为一个参数，相同的字符串一定会返回相同的Symbol类型的值，因为在方法内部维护了一个全局的注册表，为我们的字符串和Symbol提供了一一对应的关系。因为方法内部维护的是字符串与Symbol的关系，也就是说如果我们传入的不是字符串，方法内部会自动转换成字符串，会导致比如传入布尔值的true和传入字符串的true拿到的值是一样的</p>
<p><pre><br>const s1 = Symbol.for(‘foo’)<br>const s2 = Symbol.for(‘foo’)<br>console.log(s1 === s2)//true<br>console.log(Symbol.for(true) === Symbol.for(‘true’))<br></pre><br>Symbol方法中还定义了很多内置的Symbol常量来作为内部方法的标识，可以让一些自定义对象实现js当中内置的一些接口</p>
<p><pre><br>//Symbol.iterator<br>//Symbol.hasInstance<br>const obj = {}<br>console.log(obj.toString())//[object Object]-&gt;我们把这样的字符串叫做对象的toString标签<br>//自定义对象的toString标签，可以在对象中添加一个特定的成员去标识<br>//考虑到使用字符串添加标识可能会跟内部的一些成员产生重复，所以es要求我们使用Symbol实现接口<br>const obj1 = {<br>    [Symbol.toStringTag]:’XObject’<br>}<br>console.log(obj1.toString())//[object XObject]<br>//toStringTag是Symbol内置的一个常量，这种Symbol在后面我们为对象实现迭代器时常用到<br></pre><br>Symbol作为对象的属性名，通过传统的for…in…循环/Object.keys()是无法拿到的，通过JSON.stringify序列化对象为一个字符串，Symbol属性也会被忽略掉，种种特性使得Symbol特别适合作为私有属性</p>
<p><pre><br>const obj = {<br>    [Symbol()]:’symbol value’,<br>    foo:’normal value’<br>}<br>for(var key in obj){<br>    console.log(key)<br>}<br>Object.keys(obj)<br></pre><br>如果想获取Symbol类型的属性名，可以通过Object.getOwnPropertySymbols(obj)。Object.getOwnPropertySymbols类似于Object.keys，所不同的是Object.keys只能获取到字符串类型的属性名，而Object.getOwnPropertySymbols获取到的是Symbol属性名<br>31.ES2015 for…of循环<br>在es中有很多遍历数据的方法，比如for循环适合遍历普通数组，for…in…适合遍历键值对，还有一些函数式的遍历方法，例如forEach方法。但是这些遍历方法都有一些局限性，所以ES2015借鉴其他语言引入了一种新的遍历方法for…of循环，这种遍历方式以后会作为遍历所有数据结构的统一方式。下面先了解for…of循环的基本用法</p>
<p><pre><br>const arr = [100,200,300,400]<br>for(const item of arr){<br>    console.log(item)<br>}<br>//100<br>//200<br>//300<br>//400<br></pre><br>这种循环方式就可以取代我们之前常用的数组循环方式forEach，并且for…of循环可以随时用break关键词终止循环，这一点比forEach表现好，因为forEach循环无法终止遍历</p>
<p><pre><br>const arr = [100,200,300,400]<br>for(const item of arr){<br>    console.log(item)<br>    if(item &gt; 100){<br>        break;<br>    }<br>}<br></pre><br>除了数组可以用for…of循环遍历，一些伪数组对象也是可以用for…of循环遍历的，例如函数中的arguments，DOM节点的列表。这些伪数组对象的遍历和普通数组对象的遍历没有什么区别，这里不再演示。但是一些Set(其实和遍历数组基本一样，拿到的是元素本身)、Map对象，我们还是了解一下吧</p>
<p><pre><br>const s = new Set([‘foo’,’bar’])<br>for(const item of s){<br>    console.log(item)<br>}<br>//foo<br>//bar<br></pre></p>
<p><pre><br>const m = new Map()<br>m.set(‘foo’,’123’)<br>m.set(‘bar’,’345’)<br>for(const item of m){<br>    console.log(item)<br>}<br>//[ ‘foo’, ‘123’ ]//当前被遍历的键和值<br>//[ ‘bar’, ‘345’ ]<br>//配合数组的解构语法，可以直接拿到数组的键和值了<br>for(const [key,value] of m){<br>    console.log(key,value)<br>}<br>//foo 123<br>//bar 345<br></pre><br>上面基本都成功了，但是当我们试图变量普通对象的时候，却报错了</p>
<p><pre><br>const obj = {foo:123,bar:456}<br>for(item of obj){<br>    console.log(item)<br>}<br>//for(item of obj){<br>            ^<br>//TypeError: obj is not iterable<br></pre><br>说好的能遍历所有的数据结构呢？预知原因几何，且听下回分解<br>32.ES2015 可迭代接口<br>上节课说到for…of循环说好的能遍历所有的数据结构，但是居然不能遍历普通对象，这是因为：ES中能够表示有结构的数据类型越来越多，例如数组、对象到ES2015的set、map等，开发者甚至可以组合使用这种类型去定义一些符合自己业务需求的数据结构，为了给各种各样的数据结构提供统一的遍历方式，ES2015提供了一种Iterable的接口，意思就是可迭代的(如果不太理解编程语言当中的接口概念，可以把接口理解为一种规格标准，例如在ES中任意一种数据类型都有toString方法，是因为它们都实现了统一的规格标准。而在编程语言当中更专业的说法是它们都实现了统一的接口)。实现Iterable接口就是for…of的前提。我们可以在浏览器的控制台中查看一下我们之前定义的Map、Set等对象的数据结构<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_1.png"><br>可以看到我们每个可以用for…of循环遍历的数据结构都有Symbol.iterator，在Symbol.iterator中有个next方法，我们调用这个next方法<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_2.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_3.png"><br>我们能看到next方法返回的又是一个对象，当我们多次调用next方法之后可以看到<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_4 .png"><br>我们可以想到，在迭代器当中维护了一个数据指针，我们每调用一次next，数据都会往后移一位，而途中done属性的作用就是表示我们 内部的数据是否遍历完了。我们通过尝试，了解了实现iterable接口数据类型的特点。我们来总结一下，所有能实现for…of循环的数据类型都要实现iterable的接口，在内部必须挂载一个iterator的方法，这个iterator的方法需要返回一个带有next方法的对象，我们不断调用next方法就能实现对内部所有数据的遍历。那么我们再反过来看一下Set</p>
<p><pre><br>const s = new Set([‘foo’,’bar’,’baz’])<br>const iterator = s<a href="">Symbol.iterator</a><br>console.log(iterator.next())//{ value: ‘foo’, done: false }<br>console.log(iterator.next())//{ value: ‘bar’, done: false }<br>console.log(iterator.next())//{ value: ‘baz’, done: false }<br>console.log(iterator.next())//{ value: undefined, done: true }<br></pre><br>这就是for…of循环内部的实现原理，其实我们也可以使用while循环实现相同的遍历<br>33.ES2015 实现可迭代接口<br>上节课我们了解了可迭代接口iterable，也就是说如果我们给对象实现iterable接口，那么也可以通过for…of循环去遍历普通对象。在ES中实现iterable实际上就是在对象中挂载iterator方法，在这个方法中返回一个迭代器对象</p>
<p><pre><br>const obj = {<br>    [Symblo.iterator]:function(){//实现了可迭代接口iterable<br>        return {//实现了迭代器接口iterator<br>            next:function(){<br>                return {//迭代结果接口iterationResult<br>                    value:’zce’,//当前被迭代到的数据，值可以是任意类型，本例中为了方便理解，随便赋了一个值<br>                    done:true   //布尔值，表示迭代是否结束<br>                }<br>            }<br>        }<br>    }<br>}<br>//我们试着调用for…of<br>for(const item of obj){<br>    console.log(‘循环体’)<br>}<br></pre><br>我们试着调用for…of循环，发现并没有报错(虽然也没有执行，但是不报错已经是一个好的开始，毕竟我们把done属性设置为true)，那我们在上面代码的基础上进行修改</p>
<p><pre><br>const obj = {<br>    store:[‘foo’,’bar’,’baz’],//对象中添加一个数组，里面放一些值得被遍历的数据<br>    [Symbol.iterator]:function(){//实现了可迭代接口iterable<br>        let index = 0//既然要在next方法中迭代数组，我们就要维护一个下标<br>        const self = this//在next函数中的this并没有指向当前对象，定义self来接收当前的this<br>        return {//实现了迭代器接口iterator<br>            next:function(){<br>                const result =  {//迭代结果接口iterationResult<br>                    value:self.store[index],//当前被迭代到的数据，值可以是任意类型<br>                    done:index &gt;= self.store.length   //布尔值，表示迭代是否结束<br>                }<br>                index++<br>                return result<br>            }<br>        }<br>    }<br>}<br>for(const item of obj){<br>    console.log(‘循环体’,item)<br>}<br>//循环体 foo<br>//循环体 bar<br>//循环体 baz<br></pre><br>虽然我们实现了对象的迭代器，但是好像也没觉得有什么用处，难道实现起来真的没有意义么？<br>34.ES2015 迭代器模式<br>上节课我们实现了对象的迭代器，但是感觉并不是很实用？这节课我们来学习下迭代器模式，看看能不能派上用场。不过不要被这个名字吓到，我们来了解下就知道了。假如我们合作一个任务清单应用，这里老师的任务是设计一个用于存放所有任务的对象，我的任务是把所有的任务项全部罗列、呈现到界面上。<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/34_1.png"><br>从上图可以看到，用一般的思维方式去完成这个任务，我的代码和老师的代码严重耦合，老师的代码只要修改了，我的代码就需要修改。此时如果老师的数据结构能够对外提供一个统一的遍历接口，对于我(调用者而言)也就不用再关心老师的代码内部的数据结构是怎样的了，更不用担心老师的代码内部结构改变过后产生的影响<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/34_2.png"><br>实现可迭代接口其实是相同的道理，对外提供统一的遍历接口，让外部不用再担关心内部数据的结构是什么样的，ES2015在语言层面实现了迭代器模式，适用于任何数据结构，只需要在需要的地方实现iterator方法就可以</p>
<p><pre><br>//老师的代码===============================<br>const todos = {<br>    life: [‘吃饭’, ‘睡觉’, ‘打豆豆’],<br>    learn: [‘语文’, ‘数学’, ‘外语’],<br>    work: [‘喝茶’],<br>    // 提供统一遍历访问接口<br>    each: function (callback) {<br>        const all = [].concat(this.life, this.learn, this.work)<br>        for (const item of all) {<br>            callback(item)<br>        }<br>    },<br>    // 提供迭代器（ES2015 统一遍历访问接口）<br>    [Symbol.iterator]: function () {<br>        const all = […this.life, …this.learn, …this.work]<br>        let index = 0<br>        return {<br>            next: function () {<br>                return {<br>                      value: all[index],<br>                      done: index++ &gt;= all.length<br>                }<br>            }<br>        }<br>    }<br>}<br>// 我的代码 ===============================<br>todos.each(function (item) {<br>  console.log(item)<br>})<br>console.log(‘——————————-‘)<br>for (const item of todos) {<br>  console.log(item)<br>}<br>/*吃饭<br>睡觉<br>打豆豆<br>语文<br>数学<br>外语</pre></p>
<h2 id="喝茶"><a href="#喝茶" class="headerlink" title="喝茶"></a>喝茶</h2><p>吃饭<br>睡觉<br>打豆豆<br>语文<br>数学<br>外语*/<br><br>35.ES2015 生成器<br>生成器是为了避免异步编程过程中回调嵌套过深，提供更好的异步编程解决方案。我们先来了解一下生成器函数的语法以及基本应用</p>
<p><pre><br>function* foo(){<br>    console.log(‘zce’)//并未被打印<br>    return 100<br>}<br>const result = foo()<br>//console.log(result)//Object [Generator] {}<br>console.log(result.next())<br>//zce<br>//{ value: 100, done: true }//生成器接口也实现了iterator接口，也即是迭代器接口的协议<br></pre><br>这里我们单独用生成器函数并没有什么体会，因为平时使用生成器函数都会配合yield关键词使用</p>
<p><pre><br>function * foo () {<br>  console.log(‘1111’)<br>  yield 100<br>  console.log(‘2222’)<br>  yield 200<br>  console.log(‘3333’)<br>  yield 300<br>}<br>const generator = foo()<br>console.log(generator.next()) // 第一次调用，函数体开始执行，遇到第一个 yield 暂停<br>//1111<br>//{ value: 100, done: false }<br>console.log(generator.next())//第二次调用，从暂停位置继续，直到遇到下一个 yield 再次暂停<br>//2222<br>//{ value: 200, done: false }<br>console.log(generator.next())<br>//3333<br>//{ value: 300, done: false }<br>console.log(generator.next())// 第四次调用，已经没有需要执行的内容了，所以直接得到 undefined<br>//{ value: undefined, done: true }<br>console.log(generator.next())<br>//{ value: undefined, done: true }<br></pre><br>生成器函数自动帮我们返回一个生成器对象，我们调用这个对象的next方法才会让这个函数的函数体开始执行，在执行过程中一旦遇到yield关键词，函数的执行就会被暂停，而且yield后面的值将会被作为next的结果返回，如果我们继续调用生成器对象next，函数就会从暂停的位置继续开始执行，周而复始知道函数的执行完全结束，next所返回done的值也就变成了true。生成器函数最大的特点就是惰性执行，就是我们调用一下next就执行一次。<br>36.ES2015 生成器应用<br>了解了生成器，我们简单应用一下<br>(1)实现一个发号器</p>
<p><pre><br>function * createIdMaker(){<br>    let id = 1;<br>    while(true){//虽然这里是执行条件是true，但是因为有yield，每次只执行一遍就会停下<br>        yield id++<br>    }<br>}<br>const idMaker = createIdMaker()<br>console.log(idMaker.next().value)//1<br>console.log(idMaker.next().value)//2<br>console.log(idMaker.next().value)//3<br>console.log(idMaker.next().value)//4<br></pre><br>(2)实现对象的iterator方法<br>虽然生成器本身是有iterator接口的，我们用生成器实现iterator接口要比之前简单很多</p>
<p><pre><br>const todos = {<br>  life: [‘吃饭’, ‘睡觉’, ‘打豆豆’],<br>  learn: [‘语文’, ‘数学’, ‘外语’],<br>  work: [‘喝茶’],<br>  [Symbol.iterator]: function * () {<br>    const all = […this.life, …this.learn, …this.work]<br>    for (const item of all) {<br>      yield item<br>    }<br>  }<br>}<br>for (const item of todos) {<br>  console.log(item)<br>}<br></pre><br>37.ES2015 ES Modules<br>会在后面相关内容做介绍，这里不讲<br>38.ES2016 概述<br>ES2016与ES2015相比只是一个小版本的迭代<br>(1)Array.prototype.includes检查数组是否包含指定元素变得更加简单<br>过去我们用indexOf查找元素是否存在，但是indexOf不能查找NaN，includes可以查找NaN</p>
<p><pre><br>const arr = [‘foo’,1,NaN,false]<br>console.log(arr.includes(‘foo’))//true<br>console.log(arr.includes(NaN))//true<br></pre><br>(2)指数运算符<br>过去我们求2的10次放就是Math.pow(2,10)，ES2016的指数运算就是语言本身的运算符，在ES2016中2的10次方就是console.log( 2 ** 10 )<br>39.ES2017 概述<br>(1)Object.values()<br>返回对象的值数组<br>(2)Object.entries()<br>以数组的形式返回对象中的所有键值对</p>
<p><pre><br>const obj = {<br>    foo:’value1’,<br>    bar:’value2’<br>}<br>console.log(Object.values(obj))//[ ‘value1’, ‘value2’ ]<br>for(let [key,value] of Object.entries(obj)){<br>    console.log(key,value)<br>}<br>//foo value1<br>//bar value2<br>console.log(new Map(Object.entries(obj)))<br>//Map { ‘foo’ =&gt; ‘value1’, ‘bar’ =&gt; ‘value2’ }<br></pre><br>(3)Object.getOwnPropertyDescriptor()<br>获取对象中属性的完整描述信息。自从ES5之后我们可以给对象定义getter/setter属性，getter/setter是不能通过Object. assign去完全复制的，只会把getter/setter去当成一个普通的属性来复制</p>
<p><pre><br>const p1 = {<br>    firstName : ‘lei’,<br>    lastName : ‘wang’,<br>    get fullName(){<br>        return this.firstName+’ ‘+this.lastName<br>    }<br>}<br>// console.log(p1.fullName)<br>// const p2 = Object.assign({},p1)<br>// p2.firstName = ‘zce’<br>// console.log(p2.fullName)//lei wang<br>// console.log(p2)//{ firstName: ‘zce’, lastName: ‘wang’, fullName: ‘lei wang’ }<br>const descriptors = Object.getOwnPropertyDescriptors(p1)<br>// console.log(descriptor)<br>//{<br>//  firstName: {<br>//    value: ‘lei’,<br>//    writable: true,<br>//    enumerable: true,<br>//    configurable: true<br>//  },<br>//  lastName: {<br>//    value: ‘wang’,<br>//    writable: true,<br>//    enumerable: true,<br>//    configurable: true<br>//  },<br>//  fullName: {<br>//    get: [Function: get fullName],<br>//    set: undefined,<br>//    enumerable: true,<br>//    configurable: true<br>//  }<br>//}<br>const p2 = Object.defineProperties({},descriptors)<br>p2.firstName = ‘zce’<br>console.log(p2.fullName)//zce wang<br></pre><br>(4)String.prototype.padStart/String.prototype.padEnd<br>用给定的字符串填充指定(字符串开始位置或者字符串结束位置)位置</p>
<p><pre><br>const books = {<br>    html:5,<br>    css:16,<br>    javascript:128<br>}<br>for(const [name,count] of Object.entries(books)){<br>    console.log(<code>${name.padEnd(16,&#39;-&#39;)}|${count.toString().padStart(3,&#39;0&#39;)}</code>)<br>}<br>//html————|005<br>//css————-|016<br>//javascript——|128<br></pre><br>(5)在函数参数中添加尾逗号</p>
<p><pre><br>function foo(bar,baz,){<br>    //…<br>}<br></pre><br>(6)Async/Await<br>在异步编程中详细介绍过</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/21/拉勾-ECMAScript新特性/" data-id="ckdbzsit8005vjrxqhatvb1jx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/拉勾/">拉勾</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾/">拉勾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业/">网易微专业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECMAScript新特性/" style="font-size: 10px;">ECMAScript新特性</a> <a href="/tags/JavaScript异步编程/" style="font-size: 10px;">JavaScript异步编程</a> <a href="/tags/TypeScript语言/" style="font-size: 10px;">TypeScript语言</a> <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/函数式编程范式/" style="font-size: 10px;">函数式编程范式</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/手写Promise源码/" style="font-size: 10px;">手写Promise源码</a> <a href="/tags/拉勾/" style="font-size: 20px;">拉勾</a> <a href="/tags/拉勾，自动化构建/" style="font-size: 10px;">拉勾，自动化构建</a> <a href="/tags/数据结构/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 17.5px;">算法</a> <a href="/tags/网易微专业/" style="font-size: 10px;">网易微专业</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/29/拉勾-规范化标准/">拉勾-规范化标准</a>
          </li>
        
          <li>
            <a href="/2020/07/28/拉勾-其他打包工具/">拉勾-其他打包工具</a>
          </li>
        
          <li>
            <a href="/2020/07/17/拉勾-Webpack打包/">拉勾-Webpack打包</a>
          </li>
        
          <li>
            <a href="/2020/07/15/拉勾-模块化开发/">拉勾-模块化开发</a>
          </li>
        
          <li>
            <a href="/2020/07/08/拉勾-自动化构建/">拉勾-自动化构建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>