<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="喵小喵的窝">
<meta property="og:url" content="http://yoursite.com/page/12/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="喵小喵的窝">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-基于Websocket的火拼俄罗斯-基础" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/21/基于Websocket的火拼俄罗斯-基础/" class="article-date">
  <time datetime="2019-12-21T08:26:03.000Z" itemprop="datePublished">2019-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/21/基于Websocket的火拼俄罗斯-基础/">基于Websocket的火拼俄罗斯(基础)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.关于websocket的简单介绍<br>我之前有过一篇相关记录：<a href="https://snakexu.github.io/2019/11/15/%E8%BD%AE%E8%AF%A2/" target="_blank" rel="noopener">https://snakexu.github.io/2019/11/15/%E8%BD%AE%E8%AF%A2/</a><br>2.首先我们需要搭建一个基于nodejs的websocket server,这里需要用到一个模块，叫做nodejs-websocket(<a href="https://github.com/sitegui/nodejs-websocket" target="_blank" rel="noopener">https://github.com/sitegui/nodejs-websocket</a> )，我们知道了通过npm install nodejs-websocket来安装该模块<br>3.我们简单了解下github上给出的例子</p>
<pre>
var ws = require("nodejs-websocket")
// Scream server example: "hi" -> "HI!!!"
var server = ws.createServer(function (conn) {
    //conn代表这个连接
    console.log("New connection")
    //下面是当客户端有消息发过来会回调的一个函数
    conn.on("text", function (str) {
        console.log("Received "+str)
        //客户端将收到的消息进行处理之后发回
        conn.sendText(str.toUpperCase()+"!!!")
    })
    //连接关闭的时候
    conn.on("close", function (code, reason) {
        console.log("Connection closed")
    })
}).listen(8001)
</pre>
结合我们的index.html我们进行一些修改
index.html
<pre>
< input id="sendText" type="text" name="">
< button id="sendBtn">发送
< div id="recv">
< script type="text/javascript">
  var websocket = new WebSocket("ws://localhost:3000");
  websocket.onopen = function(){
    console.log("websocket open");
    document.getElementById("recv").innerHTML = "Connected";
  }
  websocket.onclose = function() {
     console.log('websocket close')
  }
  websocket.onmessage = function(e){
    console.log(e.data);
    document.getElementById("recv").innerHTML = e.data;
  }
  document.getElementById("sendBtn").onclick = function(){
    var txt = document.getElementById("sendText").value;
    websocket.send(txt);
  }
< /script>
</pre>
wsServer.js(在上面给定例子的基础上做了简单的修改，将端口号设置为一个变量)
<pre>
var ws = require("nodejs-websocket")
var PORT = 3000
// Scream server example: "hi" -> "HI!!!"
var server = ws.createServer(function (conn) {
    console.log("New connection")
    conn.on("text", function (str) {
        console.log("Received "+str)
        conn.sendText(str.toUpperCase()+"!!!")
    })
    conn.on("close", function (code, reason) {
        console.log("Connection closed")
    })
    //这里是为了解决如果直接关掉index.html页面而报错的问题
    conn.on("error", function(){
        console.log("handle err");
        console.log(err);
    })
}).listen(PORT)
console.log("websocket server listening on port" + PORT)
</pre>
注意，运行上面程序需要在命令行输入node wsServer.js启动node程序
4.我们在上面程序的基础上，做一个简单的聊天室程序
index.html
<pre>
< input id="sendText" type="text" name="">
< button id="sendBtn">发送< /button>
< script type="text/javascript">
  var websocket = new WebSocket("ws://localhost:3000");
  function showMessage(str){
    var div = document.createElement("div");
    div.innerHTML = str;
    document.body.appendChild(div)
  }
  websocket.onopen = function(){
    console.log("websocket open");
    document.getElementById("sendBtn").onclick = function(){
      var txt = document.getElementById("sendText").value;
      if(txt){
        websocket.send(txt);
      }
    }
  }
  websocket.onclose = function() {
     console.log('websocket close')
  }
  websocket.onmessage = function(e){
    console.log(e.data);
    showMessage(e.data);
  }
< /script>
</pre>
wsServer.js
<pre>
var ws = require("nodejs-websocket")
var PORT = 3000
var clientCount = 0;
// Scream server example: "hi" -> "HI!!!"
var server = ws.createServer(function (conn) {
    console.log("New connection")
    clientCount++;
    conn.nickname = 'user' +  clientCount;
    broadcast(conn.nickname + 'comes in')//通知客户端
    conn.on("text", function (str) {
        console.log("Received "+str)
        //conn.sendText(str)
        broadcast(str)
    })
    conn.on("close", function (code, reason) {
        console.log("Connection closed")
        broadcast(conn.nickname + 'left')
    })
    conn.on("error", function(){
        console.log("handle err");
        console.log(err);
    })
}).listen(PORT)
console.log("websocket server listening on port" + PORT)
function broadcast(str){
    //server.connections取到server的所有连接
    server.connections.forEach(function(connection){
        connection.sendText(str)
    })
}
</pre>
经过上面的修改，我们重启服务，在浏览器中打开index.html会发现
<img src="https://snakexu.github.io/images/mooc/websocket_5.png">
再在浏览器中打开一个index.html，然后在这个页面的input中输入hello everyone点击发送，我们可以看到
<img src="https://snakexu.github.io/images/mooc/websocket_2.png">
<img src="https://snakexu.github.io/images/mooc/websocket_3.png">
在第一次打开的index.html页面中我们看到user2上线的时候有通知，user2发送的消息user1页能够收到，然后我们关闭第一次打开的html页面，也就是user1的页面，可以看到
<img src="https://snakexu.github.io/images/mooc/websocket_4.png">
也就是说，user1的离开通知了user2
简单的聊天室也就完成了，但是这个聊天室也确实过于简单了些，接下来的课程，将对这个聊天室进行一些优化
5.进行了一些简单的修改，使进入/离开/聊天内容的颜色有了区分，并且能显示是谁发送了消息
wsServer.js
<pre>
var ws = require("nodejs-websocket")
var PORT = 3000
var clientCount = 0;
// Scream server example: "hi" -> "HI!!!"
var server = ws.createServer(function (conn) {
    console.log("New connection")
    clientCount++;
    conn.nickname = 'user' +  clientCount;
    var mes = {};
    mes.type = "enter";
    mes.data = conn.nickname + ' comes in'
    broadcast(JSON.stringify(mes))//通知客户端
    conn.on("text", function (str) {
        console.log("Received "+str)
        //conn.sendText(str)
        var mes = {};
        mes.type = "message";
        mes.data = conn.nickname + 'says: ' + str
        broadcast(JSON.stringify(mes))
    })
    conn.on("close", function (code, reason) {
        console.log("Connection closed")
        var mes = {};
        mes.type = "leave";
        mes.data = conn.nickname + ' left'
        broadcast(JSON.stringify(mes))
    })
    conn.on("error", function(){
        console.log("handle err");
        console.log(err);
    })
}).listen(PORT)
console.log("websocket server listening on port" + PORT)
function broadcast(str){
    //server.connections取到server的所有连接
    server.connections.forEach(function(connection){
        connection.sendText(str)
    })
}
</pre>
index.html修改的内容比较少，我们只贴上需要修改的地方的代码
<pre>
function showMessage(str, type){
    var div = document.createElement("div");
    div.innerHTML = str;
    if(type == "enter"){
          div.style.color = "blue"
    }else if(type == "leave"){
          div.style.color = "red"
    }
    document.body.appendChild(div)
}
websocket.onmessage = function(e){
    console.log(e.data);
    var mes = JSON.parse(e.data)
    showMessage(mes.data, mes.type);
}
</pre>
<img src="https://snakexu.github.io/images/mooc/websocket_7.png">
<img src="https://snakexu.github.io/images/mooc/websocket_8.png">

6.终于进入正题，开始准备火拼俄罗斯的制作了，不过这里还是要先了解一下socket.io，官网：https://www.imooc.com/video/15322<br>
首先安装了socket.io之后，将我们之前的聊天室改为用socket.io编写<br>
index.html
<pre>
//客户端需要引入socket.io，我没有直接下载，用了官网的cdn
< script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js">< /script>
< input id="sendText" type="text" name="">
< button id="sendBtn">发送< /button>
< script type="text/javascript">
  var socket = io("ws://localhost:3000");
  function showMessage(str, type){
    var div = document.createElement("div");
    div.innerHTML = str;
    if(type == "enter"){
      div.style.color = "blue"
    }else if(type == "leave"){
      div.style.color = "red"
    }
    document.body.appendChild(div)
  }
  document.getElementById("sendBtn").onclick = function(){
    var txt = document.getElementById("sendText").value;
    if(txt){
      socket.emit('message',txt);
    }
  }
  socket.on("enter",function(data){
    showMessage(data,"enter")
  })
  socket.on("message",function(data){
    showMessage(data,"message")
  })
  socket.on("leave",function(data){
    showMessage(data,"leave")
  })
< /script>
</pre>
wsServer.js
<pre>
var app = require("http").createServer()
var io = require("socket.io")(app)
var PORT = 3000
var clientCount = 0;
app.listen(PORT);
io.on('connection',function(socket){
    clientCount++;
    socket.nickname = 'user' +  clientCount;
    io.emit("enter",socket.nickname + ' comes in');
    socket.on("message",function(str){
        io.emit("message",socket.nickname + 'says: ' + str)
    })
    socket.on("disconnect",function() {
        io.emit("leave",socket.nickname + ' left')
    })
})
console.log("websocket server listening on port" + PORT)
</pre>
很明显看到wsServer.js的代码精简了很多。<br>
socket.io官方网站是英文网站，我找到了别人博客里翻译的一些：
socket.io官方文档翻译1 https://www.jianshu.com/p/b30bbf448e57<br>
socket.io官方文档翻译2 https://www.jianshu.com/p/d1a6c1f46a9a<br>
socket.io官方文档翻译3 https://www.jianshu.com/p/6395be36cc45<br>
socket.io官方文档翻译4 https://www.jianshu.com/p/a0d8f7e8609c<br>
一下子看完确实不太可能，不过还是希望能多看一下。毕竟我们知其然也要知道其所以然。<br>
另外因为对于基础的，比如var app = require("http").createServer();var io = require("socket.io")(app);这些有疑问，简单的看了一下API。
(1)由require('socket.io')暴露
<pre>
new Server(httpServer[, options])
httpServer (http.Server) 服务器绑定.
options (Object)
用或者不用new实现：
const io = require('socket.io')();
// or
const Server = require('socket.io');
const io = new Server();
</pre>
(2)socket.emit(eventName[, …args][, ack])
<pre>
eventName (String)
args
ack (Function)
Returns Socket
通过字符串名称向socketio发出确定事件，可以包含其他任何参数，支持所有可序列化的数据结构，包括buffer。ack参数可选，并且与客户端返回内容一起调用
</pre>
(3)socket.on(eventName, callback)
<pre>
eventName (String)
callback (Function)
Returns Socket
为给定事件注册一个新的处理程序。
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/21/基于Websocket的火拼俄罗斯-基础/" data-id="ckdbzsilq004bjrxqqdlww1ye" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-模块化编程-4-2-3-依赖解析-依赖管理处理方案" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/20/网易微专业-模块化编程-4-2-3-依赖解析-依赖管理处理方案/" class="article-date">
  <time datetime="2019-12-20T03:16:54.000Z" itemprop="datePublished">2019-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/20/网易微专业-模块化编程-4-2-3-依赖解析-依赖管理处理方案/">网易微专业-模块化编程-4.2.3-依赖解析-依赖管理处理方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--https://www.cnblogs.com/beyonds/p/8992619.html-->
<p>1.源码<br><br>startUp.js</p>
<p><pre><br>(function(global) {<br>    var startUp = global.startUp = {<br>        version: “1.0.1”,<br>    }<br>    var data = {};<br>    var cache = {};<br>    var anonymousMeta = {};<br>    //模块的生命周期<br>    var status = {<br>        FETCHED: 1,<br>        SAVED: 2,<br>        LOADING: 3,<br>        LOADED: 4,<br>        EXECUTING: 5,<br>        EXECUTED: 6,<br>    }</pre></p>
<pre><code>var isArray = function(obj) {
    return toString.call(obj) === &quot;[object Array]&quot;;
}

var isFunction = function(obj) {
    return toString.call(obj) === &quot;[object Function]&quot;;
}

//是否使用了别名
function parseAlias(id) { //a  b
    var alias = data.alias; //配置
    return alias &amp;&amp; isString(alias[id]) ? alias[id] : id;
}

//不能以&quot;/&quot; &quot;:&quot;开头  结尾必须是一个&quot;/&quot; 后面跟随任意字符至少一个
var PATHS_RE = /^([^\/:]+)(\/.+)$/; //([^\/:]+)   路径的短名称配置

// 检测是否 书写路径短名称
function parsePaths(id) {
    var paths = data.paths; //配置
    if (paths &amp;&amp; (m = id.match(PATHS_RE)) &amp;&amp; isString(paths[m[1]])) {
        id = paths[m[1]] + m[2]
    }
    return id;
}

//检测是否添加后缀
function normalize(path) {
    var last = path.length - 1;
    var lastC = path.charAt(last);
    return (lastC === &quot;/&quot; || path.substring(last - 2) === &quot;.js&quot;) ? path : path + &quot;.js&quot;;

}

//添加根目录
function addBase(id, uri) {
    var result;
    if (id.charAt(0) === &quot;.&quot;) {
        result = relapath((uri ? uri.match(/[^?]*\//)[0] : data.cwd) + id);
    } else {
        result = data.cwd + id;
    }
    return result;
}

var DOT_RE = /\/.\//g; // 规范路径  &quot;/./&quot; =&gt; &quot;/&quot;   
function relapath(path) {
    path = path.replace(DOT_RE, &quot;/&quot;);
    return path;
}

//生成绝对路径  parent child
startUp.resolve = function(child, parent) {
    if (!child) return &quot;&quot;;
    child = parseAlias(child); //检测是否有别名
    child = parsePaths(child); // 检测是否有路径别名 依赖模块中引包的模块路径地址 require(&quot;app/c&quot;);
    child = normalize(child); //检测是否添加后缀
    return addBase(child, parent); //添加根目录
}

startUp.request = function(url, callback) {
    var node = document.createElement(&quot;script&quot;);
    node.src = url;
    document.body.appendChild(node);
    node.onload = function() {
        //node.onload = null;
        //document.body.removeChild(node); 
        callback();
    }
}

//构造函数  模块初始化数据
function Module(uri, deps) {
    this.uri = uri;
    this.deps = deps || [];
    this.exports = null;
    this.status = 0;
    this._waitings = {};
    this._remain = 0;
}

//分析主干 (左子树 | 右子树) 上的依赖项
Module.prototype.load = function() {
    var module = this;
    module.status = status.LOADING;
    var uris = module.resolve(); //获取主干上的依赖项
    var len = module._remain = uris.length;
    //console.log(uris)
    //加载主干上的依赖项(模块)
    var m;
    for (var i = 0; i &lt; len; i++) {
        m = Module.get(uris[i]); //  创建缓存信息
        if (m.status &lt; status.LOADED) {
            m._waitings[module.uri] = m._waitings[module.uri] || 1;
        } else {
            module._remain--;
        }
    }
    //如果依赖列表模块全都加载完毕
    if (module._remain == 0) {//考虑不全面，并没有考虑比如主模块依赖的a.js/b.js是否加载完毕
        module.onload();
    };

    //准备执行根目录下的依赖列表中的模块
    var requestCache = {};
    for (var i = 0; i &lt; len; i++) {
        m = Module.get(uris[i]);
        if (m.status &lt; status.FETCHED) {
            m.fetch(requestCache);
        }
    }

    for (uri in requestCache) {
        requestCache[uri]();
    }
}

//加载依赖列表中的模块
Module.prototype.fetch = function(requestCache) {
    var module = this;
    console.log(module)
    module.status = status.FETCHED;
    var uri = module.uri;
    requestCache[uri] = sendRequest; //Document.createElement(&quot;script&quot;) 

    function sendRequest() {
        startUp.request(uri, onRequest);
    }

    function onRequest() {
        if (anonymousMeta) {
            module.save(uri, anonymousMeta);
        }
        module.load(); //递归 模块加载策略
    }
}

Module.prototype.onload = function() {
    var mod = this;
    mod.status = status.LOADED;
    if (mod.callback) {
        mod.callback();
    }
    //伪递归
    _waitings = mod._waitings;
    var uri, m;
    for (uri in _waitings) {
        //console.log(uri);   //根目录对应的Module实例对象
        m = cache[uri];
        m._remain -= _waitings[uri];
        if (m._remain == 0) {
            m.onload()
        };
    }

}

//更改初始化数据 
Module.prototype.save = function(uri, meta) {
    var module = Module.get(uri); //是否在缓存
    module.id = uri;
    module.deps = meta.deps || [];
    module.factory = meta.factory;
    module.status = status.SAVED;
}

//获取模块对外的接口对象
Module.prototype.exec = function() {
    var module = this;
    //防止重复执行
    if (module.status &gt;= status.EXECUTING) {
        return module.exports;
    }
    module.status = status.EXECUTING; //5
    var uri = module.uri;

    function require(id) {
        //console.log(require.resolve(id));   //更新过后的数据
        return Module.get(require.resolve(id)).exec(); //获取接口对象
    }

    require.resolve = function(id) {
        return startUp.resolve(id, uri); 
    }

    var factory = module.factory;
    var exports = isFunction(factory) ? factory(require, module.exports = {}, module) : factory;

    if (exports === undefined) {
        exports = module.exports;
    }
    module.exports = exports;
    module.status = status.EXECUTED; 
    return exports;
}

//资源定位 解析依赖项生成绝对路径
Module.prototype.resolve = function() {
    var mod = this;
    var ids = mod.deps; //[&quot;./a&quot;,&quot;./b&quot;]
    var uris = [];
    for (var i = 0; i &lt; ids.length; i++) {
        uris[i] = startUp.resolve(ids[i], mod.uri); //依赖项   (主干| 子树)
    }
    //console.log(uris)
    return uris;
}

//定义一个模块
Module.define = function(factory) {
    var deps;
    if (isFunction(factory)) {
        //正则解析依赖项
        deps = parseDependencies(factory.toString());
    }
    //存储当前模块的信息
    var meta = {
        id: &quot;&quot;,
        uri: &quot;&quot;,
        deps: deps,
        factory: factory
    }
    anonymousMeta = meta;
}

//检测缓存对象上是否有当前模块信息
Module.get = function(uri, deps) {
    return cache[uri] || (cache[uri] = new Module(uri, deps));
}

Module.use = function(deps, callback, uri) {
    var module = Module.get(uri, isArray(deps) ? deps : [deps]);
    //所有模块都加载完毕
    module.callback = function() {
        var exports = []; //所以依赖项模块的接口对象
        var uris = module.resolve();
        for (var i = 0; i &lt; uris.length; i++) {
            exports[i] = cache[uris[i]].exec(); //获取模块对外定义的接口对象
        }
        if (callback) {
            callback.apply(global, exports);
        }
    }
    module.load();
}

var _cid = 0;

function cid() {
    return _cid++;
};

data.preload = [];
//获取当前项目文档的URL
data.cwd = document.URL.match(/[^?]*\//)[0];
Module.preload = function(callback) {
    var length = data.preload.length;
    if (!length) callback();
    //length !== 0 先加载预先设定模块
};

startUp.use = function(list, callback) {
    //检测有没有预先加载的模块  
    Module.preload(function() {
        Module.use(list, callback, data.cwd + &quot;_use_&quot; + cid()); //虚拟的根目录
    });
}

var REQUIRE_RE = /\brequire\s*\(\s*([&quot;&apos;])(.+?)\1\s*\)/g

function parseDependencies(code) {
    var ret = []
    code.replace(REQUIRE_RE, function(m, m1, m2) {
        if (m2) ret.push(m2);
    });
    return ret
};

global.define = Module.define;
</code></pre><p>})(this);<br><br>a.js</p>
<p><pre><br>define(function( require, exports, module){<br>    var age = “30”;<br>    var b = require(“b.js”);<br>    console.log(b.sex);<br>    exports.age = age;<br>});<br></pre><br>b.js</p>
<p><pre><br>define(function( require, exports, module){<br>    var sex = “男”;<br>    return {<br>        sex:sex,<br>    }<br>});<br></pre><br>html</p>
<p><pre><br>startUp.use([“a.js”, “b.js”], function(a, b) {<br>    console.log(a);<br>    console.log(b);<br>    console.log(“startUp…”);<br>});<br></pre><br>2.回顾<br><img src="https://snakexu.github.io/images/wangyi/module/4.2.3_1.png"><br><img src="https://snakexu.github.io/images/wangyi/module/4.2.3_2.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/20/网易微专业-模块化编程-4-2-3-依赖解析-依赖管理处理方案/" data-id="ckdbzsij3003bjrxq4jopazrg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-模块化编程-4-2-2-模块资源定位-异步加载" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/13/网易微专业-模块化编程-4-2-2-模块资源定位-异步加载/" class="article-date">
  <time datetime="2019-12-13T09:30:50.000Z" itemprop="datePublished">2019-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/13/网易微专业-模块化编程-4-2-2-模块资源定位-异步加载/">网易微专业-模块化编程-4.2.2-模块资源定位-异步加载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.资源定位-动态加载<br><img src="https://snakexu.github.io/images/wangyi/module/4.2.2_1.png"><br>2.源码<br>startUp.js</p>
<pre>
(function(global) {
    var startUp = global.startUp = {
        version: "1.0.1",
    }
    var data = {};
    var cache = {};
    var anonymousMeta  = {};
    //模块的生命周期
    var status = {
        FETCHED: 1,
        SAVED: 2,
        LOADING: 3,
        LOADED: 4,
        EXECUTING: 5,
        EXECUTED: 6,
    }

    var isArray = function(obj) {
        return toString.call(obj) === "[object Array]";
    }

    //是否使用了别名
    function parseAlias(id) { //a  b
        var alias = data.alias; //配置
        return alias && isString(alias[id]) ? alias[id] : id;
    }

    //不能以"/" ":"开头  结尾必须是一个"/" 后面跟随任意字符至少一个
    var PATHS_RE = /^([^\/:]+)(\/.+)$/; //([^\/:]+)   路径的短名称配置

    // 检测是否 书写路径短名称
    function parsePaths(id) {
        var paths = data.paths; //配置
        if (paths && (m = id.match(PATHS_RE)) && isString(paths[m[1]])) {
            id = paths[m[1]] + m[2]
        }
        return id;
    }

    //检测是否添加后缀
    function normalize(path) {
        var last = path.length - 1;
        var lastC = path.charAt(last);
        return (lastC === "/" || path.substring(last - 2) === ".js") ? path : path + ".js";

    }

    //添加根目录
    function addBase(id, uri) {
        var result;
        if (id.charAt(0) === ".") {
            result = relapath((uri ? uri.match(/[^?]*\//)[0] : data.cwd) + id);
        } else {
            result = data.cwd + id;
        }
        return result;
    }

    var DOT_RE = /\/.\//g; // 规范路径  "/./" => "/"   
    function relapath(path) {
        path = path.replace(DOT_RE, "/");
        return path;
    }

    //生成绝对路径  parent child
    startUp.resolve = function(child, parent) {
        if (!child) return "";
        child = parseAlias(child); //检测是否有别名
        child = parsePaths(child); // 检测是否有路径别名 依赖模块中引包的模块路径地址 require("app/c");
        child = normalize(child); //检测是否添加后缀
        return addBase(child, parent); //添加根目录
    }

    startUp.request = function(url, callback) {
        var node = document.createElement("script");
        node.src = url;
        document.body.appendChild(node);
        node.onload = function() {
            //node.onload = null;
            //document.body.removeChild(node); 
            callback();
        }
    }

    //构造函数  模块初始化数据
    function Module(uri, deps) {
        this.uri = uri;
        this.deps = deps || [];
        this.exports = null;
        this.status = 0;
        this._waitings = {};
        this._remain = 0;
    }

    //分析主干 (左子树 | 右子树) 上的依赖项
    Module.prototype.load = function() {
        var module = this;
        module.status = status.LOADING;
        var uris = module.resolve(); //获取主干上的依赖项
        var len = module._remain = uris.length;
        console.log(uris)
        //加载主干上的依赖项(模块)
        var m;
        for (var i = 0; i < len; i++) {
            m = Module.get(uris[i]); //  创建缓存信息
            if (m.status < status.LOADED) {
                m._waitings[module.uri] = m._waitings[module.uri] || 1;
            } else {
                module._remain--;
            }
        }
        //如果依赖列表模块全都加载完毕
        if (module._remain == 0) {
            module.onload();
        };

        //准备执行根目录下的依赖列表中的模块
        var requestCache = {};
        for (var i = 0; i < len; i++) {
            m = Module.get(uris[i]);
            if (m.status < status.FETCHED) {
                m.fetch(requestCache);
            }
        }

        for (uri in requestCache) {
            requestCache[uri]();
        }
    }

    //加载依赖列表中的模块
    Module.prototype.fetch = function(requestCache) {
        var module = this;
        console.log(module)
        module.status = status.FETCHED;
        var uri = module.uri;
        requestCache[uri] = sendRequest; //Document.createElement("script") 
        //document.cretaE

        function sendRequest() {
            startUp.request(uri, onRequest);
        }

        function onRequest() {
            if (anonymousMeta) {
                module.save(uri, anonymousMeta); 
            }
            module.load(); //递归 模块加载策略
        }
    }

    //更改初始化数据 
    Module.prototype.save = function(uri, meta){

    }

    //资源定位 解析依赖项生成绝对路径
    Module.prototype.resolve = function() {
        var mod = this;
        var ids = mod.deps; //["./a","./b"]
        var uris = [];
        for (var i = 0; i < ids.length; i++) {
            uris[i] = startUp.resolve(ids[i], mod.uri); //依赖项   (主干| 子树)
        }
        //console.log(uris)
        return uris;
    }

    //定义一个模块
    Module.define = function(factory) {

    }

    //检测缓存对象上是否有当前模块信息
    Module.get = function(uri, deps) {
        return cache[uri] || (cache[uri] = new Module(uri, deps));
    }

    Module.use = function(deps, callback, uri) {
        var module = Module.get(uri, isArray(deps) ? deps : [deps]);
        //所有模块都加载完毕
        module.callback = function() {

        }
        module.load();
    }

    var _cid = 0;

    function cid() {
        return _cid++;
    };

    data.preload = [];
    //获取当前项目文档的URL
    data.cwd = document.URL.match(/[^?]*\//)[0];
    Module.preload = function(callback) {
        var length = data.preload.length;
        if (!length) callback();
        //length !== 0 先加载预先设定模块
    };

    startUp.use = function(list, callback) {
        //检测有没有预先加载的模块  
        Module.preload(function() {
            Module.use(list, callback, data.cwd + "_use_" + cid()); //虚拟的根目录
        });
    }

    global.define = Module.define;
})(this);
</pre>
a.js
<pre>
define(function( require, exports, module){
    var age = "30";
    exports.age = age;
});
</pre>
b.js
<pre>
define(function( require, exports, module){
    var sex = "男";
    return {
        sex:sex,
    }
});
</pre>
html
<pre>
startUp.use(["a.js","b.js"], function(){
    console.log("startUp...");
});
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/13/网易微专业-模块化编程-4-2-2-模块资源定位-异步加载/" data-id="ckdbzsij00038jrxqu6gp642l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-模块化编程-4-2-1-Module构造器设计-模块数据初始化" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/13/网易微专业-模块化编程-4-2-1-Module构造器设计-模块数据初始化/" class="article-date">
  <time datetime="2019-12-13T07:02:59.000Z" itemprop="datePublished">2019-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/13/网易微专业-模块化编程-4-2-1-Module构造器设计-模块数据初始化/">网易微专业-模块化编程-4.2.1-Module构造器设计 模块数据初始化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.依赖加载策略<br><img src="https://snakexu.github.io/images/wangyi/module/4.2.1_1.png"><br>2.模块数据初始化<br><img src="https://snakexu.github.io/images/wangyi/module/4.2.1_2.png"><br><img src="https://snakexu.github.io/images/wangyi/module/4.2.1_3.png"><br>模块生命周期里的状态码存在的意义？<br>比如我们有个需求，a.js需要加载b.js，b.js又需要加载a.js，这时候会存在循环无限加载的问题么？不会的，因为我们有状态码，根据状态码决定是否要加载当前模块。比如我们当前模块状态码为6，那么我们是不会重复加载相同模块的。<br>3.源码<br>(1)startUp.js</p>
<pre>
(function(global){
    var startUp = global.startUp = {
        version = 1.0.1
    }
    var data = {}
    var cache = {}
    var status = {
        FETCHED : 1,
        SAVED : 2,
        LOADING : 3,
        LOADED : 4,
        EXECUTING : 5,
        EXECUTED : 6
    }
    var isArray = function(obj) {
        return toString.call(obj) === "[object Array]";
    }
    //构造函数  模块初始化数据
    function Module(uri, deps){
        this.uri = uri;
        this.deps = deps || [];
        this.exports = null;
        this.status = 0;
        this._waitings = {};
        this._remain = 0;
    }
    //分析主干 (左子树 | 右子树) 上的依赖项
    Module.prototype.load = function(){
        var module = this;
        module.status = status.loading;
        //var uris = module.resolve(); //获取主干上的依赖项
        //var len = module._remain = uris.length;  
        //加载主干上的依赖项(模块)
    }
    //资源定位
    Module.prototype.resolve = function(){

    }
    //定义一个模块
    Module.define = function(factory) {

    }
    //检测缓存对象上是否有当前模块信息
    Module.get = function(uri, deps){
        return cache[uri] || (cache[uri] = new Module(uri, deps));
    }
    Module.use = function(deps, callback, uri){
        var module = Module.get(uri, isArray(deps) ? deps : [deps]);
        //所有模块都加载完毕
        module.callback = function() {

        }
        module.load();
    }
    var _cid = 0;
    function cid(){
        return _cid++
    }
    data.preload = [];
    //获取当前项目文档的URL
    data.cwd = document.URL.match(/[^?]*\//)[0];
    Module.preload = funcrtion(callback){
        var length = data.preload.length;
        if(!length) calllback();
        //length !== 0 先加载预先设定模块
    }
    startUp.use = function(list, callback){
        //检测有没有预先加载的模块 
        Module.preload(function(){
            Module.use(list, callback, data.cwd + "_use" + cid())//虚拟根目录
        })
    }
    global.define = Module.define
})(this)
</pre>
a.js
<pre>
define(function( require, exports, module){
    var age = "30";
    exports.age = age;
});
</pre>
b.js
<pre>
define(function( require, exports, module){
    var sex = "男";
    return {
        sex:sex,
    }
});
</pre>
demo.html
<pre>
startUp.use(["a.js","b.js"], function(){
    console.log("startUp...");
});
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/13/网易微专业-模块化编程-4-2-1-Module构造器设计-模块数据初始化/" data-id="ckdbzsiiz0036jrxq9mzl4dpu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js算法简单了解-堆排序" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/13/js算法简单了解-堆排序/" class="article-date">
  <time datetime="2019-12-13T04:11:16.000Z" itemprop="datePublished">2019-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/13/js算法简单了解-堆排序/">js算法简单了解-堆排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/13/js算法简单了解-堆排序/" data-id="ckdbzsigl0004jrxqq5ti3t3a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js算法简单了解-快速排序" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/12/js算法简单了解-快速排序/" class="article-date">
  <time datetime="2019-12-12T02:28:59.000Z" itemprop="datePublished">2019-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/12/js算法简单了解-快速排序/">js算法简单了解-快速排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.描述<br>（1）从数列中选择一个数作为key值；<br>（2）将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；<br>（3）对左右两个小数列重复第二步，直至各区间只有1个数。<br>2.代码</p>
<p><pre><br><!--function partition(arr,low,high){
    //var low = 0, high = arr.length, i = 0, j = high;
    var i = 0, j = high;
    var cm = arr[low];
    var temp;
    while(true){
        while(arr[i] < cm && i < j){
            i++
        }
        while(arr[j] > cm && i < j){
            j--
        }
        if(i >= j)
            break;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    temp = arr[low];
    arr[low] = arr[j]
    arr[j] = tem;
}
function quicksort(arr,low,high){
    if(low > high)
        return
    var j = partition(arr,low,high);
    quicksort(arr,low,j-1);
    quicksort(arr,j,high)
}
console.log(quicksort([42,20,17,13,28,14,23,15],0,8))--><br>function quickSort(a,l,r){<br>    if(l &gt;= r)<br>        return;<br>    var i = l;<br>    var j = r;<br>    var key = a[l];//选择第一个数为key<br>    while(i &lt; j){<br>        while(i &lt; j &amp;&amp; a[j] &gt;= key){//从右向左找第一个小于key的值<br>            j–;<br>        }<br>        if(i &lt; j){<br>            a[i] = a[j];<br>            i++;<br>        }<br>        while(i &lt; j &amp;&amp; a[i] &lt; key){//从左向右找第一个大于key的值<br>            i++;<br>        }<br>        if(i &lt; j){<br>            a[j] = a[i];<br>            j–;<br>        }<br>    }<br>    //i == j<br>    a[i] = key;<br>    quickSort(a, l, i-1);//递归调用<br>    quickSort(a, i+1, r);//递归调用<br>    return a;<br> }<br> console.log(quickSort([42,20,17,13,28,14,23,15],0,7))<br></pre><br>3.平均-O(NlogN)，最好-O(NlogN)，最坏-O(N^2)；空间复杂度：O(longN).不稳定<br>4.额外<br>快速排序是一种优秀的排序算法，但是程序细节还是会对算法性能产生一些影响。算法第四版有一些相关阐述。<!--我还没看，阿哈哈哈哈--></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/12/js算法简单了解-快速排序/" data-id="ckdbzsigq0008jrxql50dxk7z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js算法简单了解-归并排序" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/11/js算法简单了解-归并排序/" class="article-date">
  <time datetime="2019-12-11T01:51:58.000Z" itemprop="datePublished">2019-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/11/js算法简单了解-归并排序/">js算法简单了解-归并排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.描述<br>先递归的分解数列，再合并数列（分治思想的典型应用）<br>（1）将一个数组拆成A、B两个小组，两个小组继续拆，直到每个小组只有一个元素为止。<br>（2）按照拆分过程逐步合并小组，由于各小组初始只有一个元素，可以看做小组内部是有序的，合并小组可以被看做是合并两个有序数组的过程。<br>（3）对左右两个小数列重复第二步，直至各区间只有1个数。<br>下面对数组[42,20,17,13,28,14,23,15]进行归并排序，模拟排序过程如下：<br>第一步：拆分数组，一共需要拆分三次（logN）;<br>第一次拆成[42,20,17,13]，[28,14,23,15];<br>第二次拆成[42,20]，[17,13]，[28,14]，[23,15];<br>第三次拆成[42]，[20]，[17]，[13]，[28]，[14]，[23]，[15];<br>第二步：逐步归并数组，采用合并两个有序数组的方法，每一步其算法复杂度基本接近于O(N);<br>第一次归并为[20,42]，[13,17]，[14,28]，[15,23];<br>第二次归并为[13,17,20,42]，[14,15,23,28];<br>第三次归并为[13, 14, 15, 17, 20, 23, 28, 42];<br>2.代码</p>
<pre>
function mergearr(arr1,arr2){
    //console.log('arr1:',arr1)
    //console.log('arr2:',arr2)
    var arr3 = new Array()
    var len1 = arr1.length;
    var len2 = arr2.length;
    var i=0,j=0,k=0;
    while(i < len1 && j < len2){
        if(arr1[i] < arr2[j]){
            arr3[k++] = arr1[i++]
        }else{
            arr3[k++] = arr2[j++]
        }
    }
    while(i < len1){
        arr3[k++] = arr1[i++]
    }
    while(j < len2){
        arr3[k++] = arr2[j++]
    }
    return arr3
}
function mergesort(arr){
    //console.log('mergesort',arr)
    var len = arr && arr.length;
    if(len < = 1){
        return arr;
    }
    var mid = Math.floor(len/2);
    var left = arr.slice(0,mid);
    var right = arr.slice(mid,len);
    return mergearr(mergesort(left),mergesort(right));
}
var sortresult = mergesort([42,20,17,13,28,14,23,15])
console.log('sortresult:',sortresult)
</pre>
上面代码的执行结果：
<img src="https://snakexu.github.io/images/algorithm/mergesort_1.png">
3.时间复杂度O(NlogN)  空间复杂度O(N) 稳定排序
4.额外的
上面是用递归的方法实现归并排序，但是算法(第四版)给我们提供了另外一种思路
<pre>
function mergearr(arr1,arr2){
    //console.log('arr1:',arr1)
    //console.log('arr2:',arr2)
    var arr3 = new Array()
    var len1 = arr1.length;
    var len2 = arr2.length;
    var i=0,j=0,k=0;
    while(i < len1 && j < len2){
        if(arr1[i] < arr2[j]){
            arr3[k++] = arr1[i++]
        }else{
            arr3[k++] = arr2[j++]
        }
    }
    while(i < len1){
        arr3[k++] = arr1[i++]
    }
    while(j < len2){
        arr3[k++] = arr2[j++]
    }
    return arr3
}
function mergesort(arr){
    var len = arr && arr.length; 
    var arrresult;
    if(len< =1)return arr;
    var sz = 1,i,arrresult;
    for( ; sz < len; sz+=sz){
        arrresult = []
        for(i=0; i < = len - sz; i+= sz + sz){
            var mid = i+sz
            var left = arr.slice(mid-sz,mid)
            var right = arr.slice(mid,Math.min(mid+sz,len))
            var midarr = mergearr(left,right)
            arrresult = arrresult.concat(midarr)
        }
        arr = arrresult
    }
    return arr
}
var sortresult = mergesort([42,20,17,13,28,14,23,15])
console.log('sortresult:',sortresult)
</pre>












      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/11/js算法简单了解-归并排序/" data-id="ckdbzsigt000bjrxqlygqxmjl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js算法简单了解-希尔排序" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/10/js算法简单了解-希尔排序/" class="article-date">
  <time datetime="2019-12-10T09:18:20.000Z" itemprop="datePublished">2019-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/10/js算法简单了解-希尔排序/">js算法简单了解-希尔排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.描述<br>插入排序对于大规模乱序数组排序很慢，希尔排序为了加快速度简单的改进了插入排序，交换不相邻元素以对数组的局部进行片排序，并最终用插入排序将局部有序数组排序。<br>（1）按照某一增量，将数组分为若干子序列，对子序列分别进行插入排序。<br>（2）逐渐减小增量，并重复此过程，直到增量为1，此时序列基本有序，最后进行插入排序。<br>2.代码</p>
<p><pre><br>function shellsort(arr){<br>    var len = arr &amp;&amp; arr.length;<br>    var h = 1;<br>    while(h &lt; len/3){ h = 3 * h + 1}//理论上这里h可以取任意大于0的正整数<br>    while(h &gt;= 1){<br>        for(var i = h; i &lt; len; i++){<br>            //这个for循环很有意思，相当于从当前第i个元素开始，再与它之前应属于同组的元素比较<br>            //也就是说，当循环到这个元素的时候，它之前的同组元素已经做好了插入排序<br>            for(var j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j-h]; j -= h){<br>                var temp = arr[j];<br>                arr[j] = arr[j-h];<br>                arr[j-h] = temp;<br>            }<br>        }<br>        //console.log(arr)<br>        h = parseInt(h / 3)<br>    }<br>}<br>var arr = [49,38,65,101,76,13,27,49,55,1]<br>shellsort(arr)<br></pre><br>3.时间复杂度O(N^1.5)   空间复杂度O(1)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/10/js算法简单了解-希尔排序/" data-id="ckdbzsigo0006jrxqptsre8gd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js算法简单了解-插入排序" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/10/js算法简单了解-插入排序/" class="article-date">
  <time datetime="2019-12-10T06:37:09.000Z" itemprop="datePublished">2019-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/10/js算法简单了解-插入排序/">js算法简单了解-插入排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.描述<br>插入排序的工作原理就是将未排序数据，对已排序数据序列从后向前扫描，找到对应的位置并插入。插入排序通常采用占位的形式，空间复杂度为O(1),因此，在从后向前扫描的过程中，需要反复的把已排序的元素逐步向后挪位，为新插入元素提供插入的位置。<br>(1）从第一个元素开始，该元素可以被认为已经被排序<br>(2）取出下一个元素，在已经排好序的序列中从后往前扫描<br>(3）直到找到小于或者等于该元素的位置<br>(4）将该位置后面的所有已排序的元素从后往前依次移一位<br>(5)将该元素插入到该位置<br>(6)重复步骤2-5<br>另外，插入排序所需的时间取决于输入中元素的初始顺序。<br>2.代码</p>
<p><pre><br>function insertsort(arr){<br>    var len = arr &amp;&amp; arr.length,i=1,j;<br>    for( ; i &lt; len; i++){<br>        for(j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1]; j–){<br>            var temp = arr[j];<br>            arr[j] = arr[j-1]<br>            arr[j-1] = temp;<br>        }<br>        //console.log(arr)这里是为了打印每轮比较的结果<br>    }<br>    return arr<br>}<br>var arr = [49,38,65,101,76,13,27,49,55,1]<br>insertsort(arr)<br></pre><br>结果打印<br><img src="https://snakexu.github.io/images/algorithm/insertsort_1.png"><br>3.时间复杂度最好为O(N) 最坏为(N^2) 平均为O(N^2)   空间复杂度为O(1) 稳定<br>4.额外<br>4.1数组是部分有序的：数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。下面是几种典型的部分有序的数组：<br>(1)数组中每个元素距离它最终位置都不远<br>(2)一个有序的大数组接一个小数组<br>(3)数组中只有几个元素的位置不正确<br>——以上来自：算法(第四版)<br><br>插入排序对这样的数组很有效。<br><br>4.2要大幅提高插入排序的速度并不难，只需要在内循环中将较大的元素都向右移动而不总是交换两个元素(这样访问数组的次数就能减半)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/10/js算法简单了解-插入排序/" data-id="ckdbzsigu000djrxqcqaz06dh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js算法简单了解-选择排序" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/10/js算法简单了解-选择排序/" class="article-date">
  <time datetime="2019-12-10T03:50:51.000Z" itemprop="datePublished">2019-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/10/js算法简单了解-选择排序/">js算法简单了解-选择排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.描述<br>在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；第二次遍历n-2个数，找到最小的数值与第二个元素交换；。。。第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。相较其他算法，选择排序的运行时间与数据初始状态无关，总会进行大约N2/2(N的平方除以2)次比较，而其他算法更善于利用数据初始状态<br>2.代码实现</p>
<p><pre><br>function selectsort(arr){<br>    var len = arr &amp;&amp; arr.length,i=0,j,min;<br>    for( ; i &lt; len - 1; i++){<br>        min = i;<br>        for(j = i+1; j &lt; len; j++){<br>            if(a[j] &lt; a[min])<br>                min = j;<br>        }<br>        if(min != i){<br>            var temp = a[i];<br>            a[i] = a[min];<br>            a[min] = temp;<br>        }<br>    }<br>    return arr<br>}<br></pre><br>3.时间复杂度均为O(N^2)    空间复杂度为O(1)  不稳定(不稳定的意思就是，如果有个数组arr = [4,5,2,3,3,1],在排序之后，a[3]依然在a[4]前边)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/10/js算法简单了解-选择排序/" data-id="ckdbzsigp0007jrxq3f8e6r72" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/13/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/拉勾/">拉勾</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾/">拉勾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业/">网易微专业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECMAScript新特性/" style="font-size: 10px;">ECMAScript新特性</a> <a href="/tags/JavaScript异步编程/" style="font-size: 10px;">JavaScript异步编程</a> <a href="/tags/TypeScript语言/" style="font-size: 10px;">TypeScript语言</a> <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/函数式编程范式/" style="font-size: 10px;">函数式编程范式</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/手写Promise源码/" style="font-size: 10px;">手写Promise源码</a> <a href="/tags/拉勾/" style="font-size: 20px;">拉勾</a> <a href="/tags/拉勾，自动化构建/" style="font-size: 10px;">拉勾，自动化构建</a> <a href="/tags/数据结构/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 17.5px;">算法</a> <a href="/tags/网易微专业/" style="font-size: 10px;">网易微专业</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/29/拉勾-规范化标准/">拉勾-规范化标准</a>
          </li>
        
          <li>
            <a href="/2020/07/28/拉勾-其他打包工具/">拉勾-其他打包工具</a>
          </li>
        
          <li>
            <a href="/2020/07/17/拉勾-Webpack打包/">拉勾-Webpack打包</a>
          </li>
        
          <li>
            <a href="/2020/07/15/拉勾-模块化开发/">拉勾-模块化开发</a>
          </li>
        
          <li>
            <a href="/2020/07/08/拉勾-自动化构建/">拉勾-自动化构建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>