<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="喵小喵的窝">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="喵小喵的窝">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-我的typescript学习-接口" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/06/我的typescript学习-接口/" class="article-date">
  <time datetime="2019-12-06T02:09:18.000Z" itemprop="datePublished">2019-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/06/我的typescript学习-接口/">我的typescript学习-接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.介绍<br>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。<br>2.接口初探<br>下面通过一个简单示例来观察接口是如何工作的：</p>
<p>function printLabel(labelledObj: { label: string }) {<br>  console.log(labelledObj.label);<br>}</p>
<p>let myObj = { size: 10, label: “Size 10 Object” };<br>printLabel(myObj);<br>类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：</p>
<p>interface LabelledValue {<br>  label: string;<br>}</p>
<p>function printLabel(labelledObj: LabelledValue) {<br>  console.log(labelledObj.label);<br>}</p>
<p>let myObj = {size: 10, label: “Size 10 Object”};<br>printLabel(myObj);<br>LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。<br>3.可选属性<br>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<p>interface SquareConfig {<br>  color?: string;<br>  width?: number;<br>}</p>
<p>function createSquare(config: SquareConfig): {color: string; area: number} {<br>  let newSquare = {color: “white”, area: 100};<br>  if (config.color) {<br>    newSquare.color = config.color;<br>  }<br>  if (config.width) {<br>    newSquare.area = config.width * config.width;<br>  }<br>  return newSquare;<br>}</p>
<p>let mySquare = createSquare({color: “black”});<br>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：</p>
<p>interface SquareConfig {<br>  color?: string;<br>  width?: number;<br>}</p>
<p>function createSquare(config: SquareConfig): { color: string; area: number } {<br>  let newSquare = {color: “white”, area: 100};<br>  if (config.clor) {<br>    // Error: Property ‘clor’ does not exist on type ‘SquareConfig’<br>    newSquare.color = config.clor;<br>  }<br>  if (config.width) {<br>    newSquare.area = config.width * config.width;<br>  }<br>  return newSquare;<br>}</p>
<p>let mySquare = createSquare({color: “black”});<br>4.只读属性<br>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p>
<p>interface Point {<br>    readonly x: number;<br>    readonly y: number;<br>}<br>你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。</p>
<p>let p1: Point = { x: 10, y: 20 };<br>p1.x = 5; // error!<br>TypeScript具有ReadonlyArray<t>类型，它与Array<t>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</t></t></p>
<p>let a: number[] = [1, 2, 3, 4];<br>let ro: ReadonlyArray&lt; number &gt; = a;<br>ro[0] = 12; // error!<br>ro.push(5); // error!<br>ro.length = 100; // error!<br>a = ro; // error!<br>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<p>a = ro as number[];<br>readonly vs const<br>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。<br>5.额外的属性检查<br>我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>
<p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说：</p>
<p>interface SquareConfig {<br>    color?: string;<br>    width?: number;<br>}</p>
<p>function createSquare(config: SquareConfig): { color: string; area: number } {<br>    // …<br>}</p>
<p>let mySquare = createSquare({ colour: “red”, width: 100 });<br>注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。</p>
<p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<p>// error: ‘colour’ not expected in type ‘SquareConfig’<br>let mySquare = createSquare({ colour: “red”, width: 100 });<br>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<p>let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);<br>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>
<p>interface SquareConfig {<br>    color?: string;<br>    width?: number;<br>    [propName: string]: any;<br>}<br>我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。</p>
<p>let squareOptions = { colour: “red”, width: 100 };<br>let mySquare = createSquare(squareOptions);<br>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。</p>
<p>6.函数类型<br>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<p>interface SearchFunc {<br>  (source: string, subString: string): boolean;<br>}<br>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<p>let mySearch: SearchFunc;<br>mySearch = function(source: string, subString: string) {<br>  let result = source.search(subString);<br>  return result &gt; -1;<br>}<br>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<p>let mySearch: SearchFunc;<br>mySearch = function(src: string, sub: string): boolean {<br>  let result = src.search(sub);<br>  return result &gt; -1;<br>}<br>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。</p>
<p>let mySearch: SearchFunc;<br>mySearch = function(src, sub) {<br>    let result = src.search(sub);<br>    return result &gt; -1;<br>}<br>7.可索引的类型<br>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<p>interface StringArray {<br>  [index: number]: string;<br>}</p>
<p>let myArray: StringArray;<br>myArray = [“Bob”, “Fred”];</p>
<p>let myStr: string = myArray[0];<br>上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。</p>
<p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p>
<p>class Animal {<br>    name: string;<br>}<br>class Dog extends Animal {<br>    breed: string;<br>}</p>
<p>// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!<br>interface NotOkay {<br>    [x: number]: Animal;<br>    [x: string]: Dog;<br>}<br>字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[“property”]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<p>interface NumberDictionary {<br>  [index: string]: number;<br>  length: number;    // 可以，length是number类型<br>  name: string       // 错误，<code>name</code>的类型与索引类型返回值的类型不匹配<br>}<br>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<p>interface ReadonlyStringArray {<br>    readonly [index: number]: string;<br>}<br>let myArray: ReadonlyStringArray = [“Alice”, “Bob”];<br>myArray[2] = “Mallory”; // error!<br>你不能设置myArray[2]，因为索引签名是只读的。<br>8.类类型<br>8-1.实现接口<br>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。<br>interface ClockInterface {<br>    currentTime: Date;<br>}</p>
<p>class Clock implements ClockInterface {<br>    currentTime: Date;<br>    constructor(h: number, m: number) { }<br>}<br>你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：<br>interface ClockInterface {<br>    currentTime: Date;<br>    setTime(d: Date);<br>}</p>
<p>class Clock implements ClockInterface {<br>    currentTime: Date;<br>    setTime(d: Date) {<br>        this.currentTime = d;<br>    }<br>    constructor(h: number, m: number) { }<br>}<br>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。<br>8-2.类静态部分与实例部分的区别<br>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：<br>interface ClockConstructor {<br>    new (hour: number, minute: number);<br>}</p>
<p>class Clock implements ClockConstructor {<br>    currentTime: Date;<br>    constructor(h: number, m: number) { }<br>}<br>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。<br>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。<br>interface ClockConstructor {<br>    new (hour: number, minute: number): ClockInterface;<br>}<br>interface ClockInterface {<br>    tick();<br>}</p>
<p>function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {<br>    return new ctor(hour, minute);<br>}</p>
<p>class DigitalClock implements ClockInterface {<br>    constructor(h: number, m: number) { }<br>    tick() {<br>        console.log(“beep beep”);<br>    }<br>}<br>class AnalogClock implements ClockInterface {<br>    constructor(h: number, m: number) { }<br>    tick() {<br>        console.log(“tick tock”);<br>    }<br>}</p>
<p>let digital = createClock(DigitalClock, 12, 17);<br>let analog = createClock(AnalogClock, 7, 32);<br>因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。<br>9.继承接口<br>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。<br>interface Shape {<br>    color: string;<br>}</p>
<p>interface Square extends Shape {<br>    sideLength: number;<br>}</p>
<p>let square = <square>{};<br>square.color = “blue”;<br>square.sideLength = 10;<br>一个接口可以继承多个接口，创建出多个接口的合成接口。<br>interface Shape {<br>    color: string;<br>}</square></p>
<p>interface PenStroke {<br>    penWidth: number;<br>}</p>
<p>interface Square extends Shape, PenStroke {<br>    sideLength: number;<br>}</p>
<p>let square = <square>{};<br>square.color = “blue”;<br>square.sideLength = 10;<br>square.penWidth = 5.0;<br>10.混合类型<br>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。<br>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。<br>interface Counter {<br>    (start: number): string;<br>    interval: number;<br>    reset(): void;<br>}</square></p>
<p>function getCounter(): Counter {<br>    let counter = <counter>function (start: number) { };<br>    counter.interval = 123;<br>    counter.reset = function () { };<br>    return counter;<br>}</counter></p>
<p>let c = getCounter();<br>c(10);<br>c.reset();<br>c.interval = 5.0;<br>在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。<br>11.接口继承类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/06/我的typescript学习-接口/" data-id="ckchm0rfv002g5ajha9yxldxp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-Undersocre-3-4-1-Underscore-partial偏函数or-memoize缓存" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/02/网易微专业-Undersocre-3-4-1-Underscore-partial偏函数or-memoize缓存/" class="article-date">
  <time datetime="2019-12-02T06:51:43.225Z" itemprop="datePublished">2019-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 网易微专业-Undersocre-3.4.1-Underscore <em>.partial偏函数or</em>.memoize缓存<br>date: 2019-12-02 14:51:43</p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><ol>
<li>_.parital<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.4.1_1.png"></li>
<li><p>_.memorize<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.4.1_2.png"><br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.4.1_3.png"><br>3.</p>
<pre>
//返回一个函数的副本
_.partial = function(func) {
 //提取参数
 var args = [].slice.call(arguments, 1);
 var bound = function() {
     var index = 0;
     var length = args.length;
     var ret = Array(length);
     for (var i = 0; i < length; i++) {
         ret[i] = args[i];
     }
     while (index < arguments.length) {
         ret.push(arguments[index++]);
     }
     return func.apply(this, ret);
 }
 return bound;
}
_.has = function(obj, key) {
 return obj != null && hasOwnProperty.call(obj, key);
};
//存储中间运算结果,提高效率
//参数 hasher是个function通过返回值来记录key
//_.memoize(function, [hashFunction])
// 适用于需要大量重复求值的场景
// 比如递归求解斐波那契数
_.memoize = function(func, hasher) {
 var memoize = function(key) {
     // 储存变量,方便使用
     var cache = memoize.cache;
     // 求 key
     // 如果传入了 hasher,则用 hasher 函数来记录 key
     // 否则用参数 key(即memoize 方法传入的第一个参数)当key
     var address = '' + (hasher ? hasher.apply(this, arguments) : key);
     // 如果这个 key 还没被求过值 先记录在缓存中.
     if (!_.has(cache, address)) {
         cache[address] = func.apply(this, arguments);
     }
     return cache[address];
 };

 // cache 对象被当做 key-value 键值对缓存中间运算结果
 memoize.cache = {};
 return memoize;
};
</pre>
<pre>
var add = function(a, b) {
 return a + b;
};
var partialAdd = _.partial(add, 5);  //提取出来
console.log(partialAdd(10)); //    提出来    => 15
</pre>
<pre>
var hasher = function() {
 var n = arguments[0];
 return n+"max";
}
var fibonacci = _.memoize(function(n) {
 return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
},hasher);
fibonacci(5);
console.log(fibonacci.cache);
</pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/02/网易微专业-Undersocre-3-4-1-Underscore-partial偏函数or-memoize缓存/" data-id="ckchm0rcz001x5ajhtxare64t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-Undersocre-3-3-2-Underscore-unique去重函数-源码拾遗" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/02/网易微专业-Undersocre-3-3-2-Underscore-unique去重函数-源码拾遗/" class="article-date">
  <time datetime="2019-12-02T02:05:46.000Z" itemprop="datePublished">2019-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/02/网易微专业-Undersocre-3-3-2-Underscore-unique去重函数-源码拾遗/">网易微专业-Undersocre-3.3.2-Underscore unique去重函数&amp;源码拾遗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>_.unique<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.3.2_1.png"></li>
<li>_.compact<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.3.2_2.png"><br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.3.2_3.png"></li>
<li>_.range<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.3.2_4.png"><br>4.<br><pre><br>_.unique = function(array, isSorted, iteratee, context){<br> //参数isSorted作用是被处理数组array是否是有序的<br> if(!_.isBoolean(isSorted)){<pre><code>context = iteratee;
iteratee = isSorted;
isSorted = false;
</code></pre> }<br> if(iteratee != null){<pre><code>iteratee = cb(iteratee,context)
</code></pre> }<br> var result = []<br> var seen<br> for(var i = 0; i &lt; array.length; i++){<pre><code>var computed = iteratee ? iteratee(value, i, array) : array[i];
// 如果是有序数组,则当前元素只需跟上一个元素对比即可
// 用 seen 变量保存上一个元素
if(isSorted){
    if(!i || !seen !== computed)
        result.push(computed);
    seen = computed;
}else if(result.indexOf(computed)=== -1){
        result.push(computed)
}
</code></pre> }<br>}<br>//predicate  真值检测(重点: 返回值)<br>_.filter = _.select = function(obj, predicate, context) {<br> var results = [];<br> predicate = cb(predicate, context);<br> _.each(obj, function(value, index, list) {<pre><code>if (predicate(value, index, list)) results.push(value);
</code></pre> });<br> return results;<br>};<br>//去掉数组中所有的假值   _.identity = function(value){return value};<br>_.compact = function(array) {<br> return _.filter(array, _.identity);<br>};<br>_.range = function(start, stop, step){<br> if(stop == null){<pre><code>stop = start || 0;
start = 0
</code></pre> }<br> step = step || 1;<br> var length = Math.max((Math.ceil(stop - start) / step), 0);<br> var range = Array(length);<br> for(var index = 0; index &lt; length; index++, start+=step){<pre><code>range[index] = start
</code></pre> }<br> return range<br>}<br></pre><br>这一节内容丰满了我们之前的_.unique的程序，添加了数组有序的情况下如何处理，在数组有序的情况下，如果再一一查找，显然是浪费性能的，这里给了一个更好的方法。上面的_.filter在判断是否是真值的时候用了很聪明的方法。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/02/网易微专业-Undersocre-3-3-2-Underscore-unique去重函数-源码拾遗/" data-id="ckchm0rd0001y5ajhk0yows9h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-Undersocre-3-3-1-Underscore数组定位与摊平数组" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/01/网易微专业-Undersocre-3-3-1-Underscore数组定位与摊平数组/" class="article-date">
  <time datetime="2019-12-01T13:42:29.000Z" itemprop="datePublished">2019-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/01/网易微专业-Undersocre-3-3-1-Underscore数组定位与摊平数组/">网易微专业-Undersocre-3.3.1-Underscore数组定位与摊平数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.<em>.initial与</em>.flatten<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.3.1_1.png"><br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.3.1_2.png"><br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.3.1_3.png"><br>2.代码</p>
<p><pre><br>//摊平数组<br>var flatten = function(array, shallow) {<br>    var ret = [];<br>    var index = 0;<br>    for (var i = 0; i &lt; array.length; i++) {<br>        var value = array[i]; //展开一次<br>        if (_.isArray(value) || _.isArguments(value)) {<br>            //递归全部展开<br>            if (!shallow) {<br>                value = flatten(value, shallow);<br>            }<br>            var j = 0,<br>                len = value.length;<br>            //个人以为，这个地方，思路值得学习<br>            ret.length += len;<br>            while (j &lt; len) {<br>                ret[index++] = value[j++];<br>            }<br>        } else {<br>            ret[index++] = value;<br>        }<br>    }<br>    return ret;<br>}<br>_.flatten = function(array, shallow) {<br>    return flatten(array, shallow);<br>}<br>//返回数组中除了最后一个元素外的其他全部元素。 在arguments对象上特别有用。<br>_.initial = function(array, n) {<br>    return [].slice.call(array, 0, Math.max(0, array.length - (n == null ? 1 : n)));<br>};<br>//返回数组中除了第一个元素外的其他全部元素。传递 n 参数将返回从n开始的剩余所有元素<br><em>.rest = function(array, n, guard) {<br>    return [].slice.call(array, n == null ? 1 : n);<br>};<br></em></pre><br>Underscore看到现在，这里应该是比较简单的一节了，这节摊平数组主要是递归函数，但是整理摊平出来的数组也就是递归语句下面生成新数组的思路，还是很值得学习的。.initial和_.rest很容易理解，就不多说了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/01/网易微专业-Undersocre-3-3-1-Underscore数组定位与摊平数组/" data-id="ckchm0rcx001u5ajhkqrdgvgy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-Underscore-3-2-3-乱序数组-洗牌算法" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/27/网易微专业-Underscore-3-2-3-乱序数组-洗牌算法/" class="article-date">
  <time datetime="2019-11-27T08:17:34.000Z" itemprop="datePublished">2019-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/27/网易微专业-Underscore-3-2-3-乱序数组-洗牌算法/">网易微专业-Underscore-3.2.3-乱序数组-洗牌算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.洗牌算法<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.2.3_1.png"><br>2.没啥说的，撸代码吧</p>
<pre>
_.clone = function(obj) {
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
};

//返回乱序之后的数组副本
_.shuffle = function(array){
   //array.length
   return _.sample(array,Infinity);
}
//抽样函数  10  11 
_.sample = function(array, n){
   if(n == null){
      return  array[_.random(array.length-1)];
   }
   var sample = _.clone(array);
   var length = sample.length;
   var last = length-1;
   n = Math.max(Math.min(n, length),0);
   for(var index = 0; index < n; index++){
       //随机数   index  n
       var rand = _.random(index, last);
       var temp = sample[index];
       sample[index] = sample[rand];   //交换
       sample[rand] = temp;  //交换
   }
   return sample.slice(0, n);
}
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/27/网易微专业-Underscore-3-2-3-乱序数组-洗牌算法/" data-id="ckchm0rcu001r5ajhd14g97b2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-Underscore-3-2-2-条件查询-背后索引查询器实现" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/27/网易微专业-Underscore-3-2-2-条件查询-背后索引查询器实现/" class="article-date">
  <time datetime="2019-11-27T06:44:38.000Z" itemprop="datePublished">2019-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/27/网易微专业-Underscore-3-2-2-条件查询-背后索引查询器实现/">网易微专业-Underscore-3.2.2-条件查询-背后索引查询器实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.indexOf lastIndexOf条件查询<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.2.2_1.png"><br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.2.2_2.png"><br>2.代码奉上<br>这节课，老师主要讲的其实是二分查找的算法。二分查找，就是在数组为有序数组的前提下，每次只查找数组长度的一半。最简单的来说，如果我们一个个按序对比，时间复杂度为n，如果采用二分查找，时间复杂度为log以2为底n的对数，在数据量大的时候，和明显二分查找效率更高</p>
<pre>
// (dir === 1 => 从前往后找)  (dir === -1 => 从后往前找) 
function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
        predicate = cb(predicate, context);  // _.isNaN
        var length = array.length;
        // 根据 dir 变量来确定数组遍历的起始位置
        var index = dir > 0 ? 0 : length - 1;

        for (; index >= 0 && index < length; index += dir) {
            // 找到第一个符合条件的元素
            // 并返回下标值
            if (predicate(array[index], index, array))   //true
                return index;
        }
        return -1;
    };
}
_.findIndex = createPredicateIndexFinder(1);
_.findLastIndex = createPredicateIndexFinder(-1);

_.isNaN = function(obj) {   // NaN
    return _.isNumber(obj) && obj !== obj;
};

_.sortedIndex = function(array, obj, iteratee, context) {
    // 重点:cb函数 if (iteratee == null) {return function(value){return value;}}
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0,
        high = array.length;
    // 二分查找
    while (low < high) {  //4  4 
        var mid = Math.floor((low + high) / 2);   //4
        if (iteratee(array[mid]) < value)    //  5 < 5
            low = mid + 1;  //4
        else
            high = mid;   //4
    }

    return low;     //4
};

function createIndexFinder(dir, predicateFind, sortedIndex) {
    // API 调用形式
    // _.indexOf(array, value, [isSorted])
    return function(array, item, idx) {
        var i = 0,
            length = array.length;
        // 第三个参数true用二分查找优化 否则 遍历查找
        if (sortedIndex && _.isBoolean(idx) && length) {
            // 能用二分查找加速的条件
            // 用 _.sortedIndex 找到有序数组中 item 正好插入的位置
            idx = sortedIndex(array, item);
            return array[idx] === item ? idx : -1;
        }

        //特殊情况 如果要查找的元素是 NaN 类型  NaN !== NaN
        if (item !== item) {
            idx = predicateFind(slice.call(array, i, length), _.isNaN);
            return idx >= 0 ? idx + i : -1;
        }

        // 非上述情况正常遍历
        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
            if (array[idx] === item) return idx;
        }

        return -1;
    };
}

//_.findIndex  特殊情况下的处理方案  NAN  
//_.sortedIndex 针对排序的数组做二分查找  优化性能
_.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
_.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/27/网易微专业-Underscore-3-2-2-条件查询-背后索引查询器实现/" data-id="ckchm0rcw001t5ajhsb4nm4j8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-Underscore-3-2-1-Map-reduce真值检测函数" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/26/网易微专业-Underscore-3-2-1-Map-reduce真值检测函数/" class="article-date">
  <time datetime="2019-11-26T13:27:48.000Z" itemprop="datePublished">2019-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/26/网易微专业-Underscore-3-2-1-Map-reduce真值检测函数/">网易微专业-Underscore-3.2.1-Map-reduce真值检测函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.map-reduce了解介绍<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.2.1_1.png"><br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.2.1_2.png"><br>2.map源码<br>这个内容在之前章节已经讲过，在此略过<br>3.reduce介绍<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.2.1_3.png"><br>4.真值检测函数<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.2.1_4.png"><br>5.上代码<br>(1)reduce的代码，关于这段代码，只想说，代码太厉害了，逻辑清晰又有深度……(省略万字溢美之词)</p>
<pre>
var optimizeCb = function(func, context, count) {
    if (context == void 0) {
        return func;
    }

    switch (count == null ? 3 : count) {
        case 1:
            return function(value) {
                return func.call(context, value);
            };
        case 3:
            return function(value, index, obj) {
                return func.call(context, value, index, obj);
            };
        case 4:
            return function(memo, value, index, obj) {
                return func.call(context, memo, value, index, obj);
            };
    }
}
var createReduce = function(dir) {
    //累加
    var reduce = function(obj, iteratee, memo, init) {
        var keys = !_.isArray(obj) && Object.keys(obj),
            length = (keys || obj).length,
            index = dir > 0 ? 0 : length - 1;
        //给memo设置了初始值memo = obj[0]
        //即要被操作的obj对象的第一个属性值
        if (!init) {
            memo = obj[keys ? keys[index] : index];
            index += dir; //1   
        };
        for (; index >= 0 && index < length; index += dir) {
            var currnteKey = keys ? keys[index] : index;
            memo = iteratee(memo, obj[currnteKey], currnteKey, obj)
        }
        return memo;
    }
    //memo  最终能累加的结果     每一次累加的过程
    return function(obj, iteratee, memo, context) {
        var init = arguments.length >= 3;
        return reduce(obj, optimizeCb(iteratee, context, 4), memo, init);
    }
}
//调用的时候，1为正向从obj[0]处理到obj[Object.keys(obj).length-1]
//-1为负向，从obj[Object.keys(obj).length-1]处理到obj[0]
_.reduce = createReduce(1); // 1 || -1
</pre>
(2)filter过滤器
<pre>
_.filter = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
        if (predicate(value, index, list)) results.push(value);
    });
    return results;
};
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/26/网易微专业-Underscore-3-2-1-Map-reduce真值检测函数/" data-id="ckchm0rcv001s5ajhoova8nul" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-Underscore-3-1-4-rest参数-Underscore创建对象方式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/25/网易微专业-Underscore-3-1-4-rest参数-Underscore创建对象方式/" class="article-date">
  <time datetime="2019-11-25T12:04:05.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/25/网易微专业-Underscore-3-1-4-rest参数-Underscore创建对象方式/">网易微专业-Underscore-3.1.4-rest参数-Underscore创建对象方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.rest参数<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.1.4_1.png"><br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.1.4_2.png"><br>2.Object.create.polyfill<br>这个没啥可说的，直接撸代码吧</p>
<p><pre><br>var Ctor = function(){};</pre></p>
<p>//Object.create polyfill   Object.create(object)   baseCreate(object)<br>var baseCreate = function(prototype) {<br>    if (!_.isObject(prototype)) return {};<br>    if (Object.create) return Object.create(prototype);<br>    Ctor.prototype = prototype;<br>    var result = new Ctor;<br>    Ctor.prototype = null;//要清空<br>    return result;<br>};<br><br>3.rest参数的实现<br>下面代码里的讲解，是以下面代码为例的</p>
<p><pre><br>function test(count, rest){<br>    console.log(rest);   //[2,3,4]<br>}<br>//包装器<br>var restTest = _.restArguments(test);<br>restTest(1,2,3,4);<br></pre></p>
<p><pre><br>// rest 参数<br>_.restArguments = function(func) {<br>    //rest参数位置<br>    var startIndex = func.length - 1;   //1<br>    return function() {<br>        var length = arguments.length - startIndex,<br>            rest = Array(length),<br>            index = 0;<br>        // rest数组中的成员  rest==[2,3,4]<br>        for (; index &lt; length; index++) {<br>            rest[index] = arguments[index + startIndex];  //1<br>        }<br>        //非rest参数成员的值一一对应  args  ===2  []<br>        var args = Array(startIndex + 1);<br>        for (index = 0; index &lt; startIndex; index++) {<br>            args[index] = arguments[index];  //args [1]<br>        }</pre></p>
<pre><code>    args[startIndex] = rest;   //args [1,[2,3,4]]
    return func.apply(this, args);
}
</code></pre><p>}<br><br>上面代码，关于index和startIndex的设定和应用很有技巧</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/25/网易微专业-Underscore-3-1-4-rest参数-Underscore创建对象方式/" data-id="ckchm0rcs001n5ajhka6t94x6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-Underscore-3-1-3-undefined的处理iteratee设计-源代码" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/25/网易微专业-Underscore-3-1-3-undefined的处理iteratee设计-源代码/" class="article-date">
  <time datetime="2019-11-25T10:07:46.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/25/网易微专业-Underscore-3-1-3-undefined的处理iteratee设计-源代码/">网易微专业-Underscore-3.1.3-undefined的处理iteratee设计-源代码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js部分代码</p>
<pre>
(function(root) {
    var push = Array.prototype.push;

    var _ = function(obj) {
        if (obj instanceof _) {
            return obj;
        }

        if (!(this instanceof _)) {
            return new _(obj);
        }
        this._wrapped = obj;
    }

    _.unique = function(arr, callback) {
        var ret = [];
        var target, i = 0;
        for (; i < arr.length; i++) {
            var target = callback ? callback(arr[i]) : arr[i];
            if (ret.indexOf(target) === -1) {
                ret.push(target);
            }
        }

        return ret;
    }

    //开启链接式的调用
    _.chain = function(obj) {
        var instance = _(obj);
        instance._chain = true;
        return instance;
    }

    //辅助函数    obj   数据结果
    var result = function(instance, obj) {
        return instance._chain ? _(obj).chain() : obj;
    }

    _.prototype.value = function() {
        return this._wrapped;
    }

    _.functions = function(obj) {
        var result = [];
        var key;
        for (key in obj) {
            result.push(key);
        }
        return result;
    }

    _.map = function(obj, iteratee, context) {
        //生成不同功能迭代器
        var iteratee = cb(iteratee, context);
        //分辨 obj是数组对象, 还是object对象
        var keys = !_.isArray(obj) && Object.keys(obj);
        var length = (keys || obj).length;
        var result = Array(length);

        for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            result[index] = iteratee(obj[currentKey], index, obj);
        }

        return result;
    }

    var cb = function(iteratee, context, count) {
        if (iteratee == null) {
            return _.identity;
        }

        if (_.isFunction(iteratee)) {
            return optimizeCb(iteratee, context, count);
        }
    }

    //optimizeCb优化迭代器
    var optimizeCb = function(func, context, count) {
        if (context == void 0) {
            return func;
        }

        switch (count == null ? 3 : count) {
            case 1:
                return function(value) {
                    return func.call(context, value);
                };
            case 3:
                return function(value, index, obj) {
                    return func.call(context, value, index, obj);
                };
        }
    }

   //默认迭代器
    _.identity = function(value) {
        return value;
    }


    _.each = function(target, callback) {
        var key, i = 0;
        if (_.isArray(target)) {
            var length = target.length;
            for (; i < length; i++) {
                callback.call(target, target[i], i);
            }
        } else {
            for (key in target) {
                callback.call(target, key, target[key]);
            }
        }

    }

    //类型检测
    _.isArray = function(array) {
        return toString.call(array) === "[object Array]";
    }

    _.each(["Function", "String", "Object", "Number"], function(name) {
        _["is" + name] = function(obj) {
            return toString.call(obj) === "[object " + name + "]";
        }
    });

    //mixin  
    _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
            var func = obj[name];

            _.prototype[name] = function() {
                var args = [this._wrapped];
                push.apply(args, arguments);
                // instance      去重之后的结果
                return result(this, func.apply(this, args));
            }
        });
    }

    _.mixin(_);
    root._ = _;
})(this);
</pre>
可以用如下js测试
<pre>
var obj = {name:"max"}
console.log(_.map([1, 2, 3], function(value, index, object){
    console.log(this)
    return value*3;
},obj));
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/25/网易微专业-Underscore-3-1-3-undefined的处理iteratee设计-源代码/" data-id="ckchm0rcr001l5ajhdwhr40fp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-Underscore-3-1-3-undefined的处理iteratee设计" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/25/网易微专业-Underscore-3-1-3-undefined的处理iteratee设计/" class="article-date">
  <time datetime="2019-11-25T09:06:17.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/25/网易微专业-Underscore-3-1-3-undefined的处理iteratee设计/">网易微专业-Underscore-3.1.3-undefined的处理iteratee设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.undefined的处理<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.1.3_1.png"><br>2.iteratee<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.1.3_2.png"><br>3.cb<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.1.3_3.png"><br>4.optimizeCb<br><img src="https://snakexu.github.io/images/wangyi/Underscore/3.1.3_4.png"><br>5.撸代码<br>这里主要是讲iteratee，上一节内容，_.map()函数内容为空，没有进行处理，这节课我们学习怎么处理</p>
<p><pre><br><em>.map = function(obj, iteratee, context) {<br>    //生成不同功能迭代器<br>    var iteratee = cb(iteratee, context);<br>    //分辨 obj是数组对象, 还是object对象<br>    var keys = !</em>.isArray(obj) &amp;&amp; Object.keys(obj);<br>    var length = (keys || obj).length;<br>    var result = Array(length);</pre></p>
<pre><code>for (var index = 0; index &lt; length; index++) {
    var currentKey = keys ? keys[index] : index;
    result[index] = iteratee(obj[currentKey], index, obj);
}

return result;
</code></pre><p>}</p>
<p>var cb = function(iteratee, context, count) {<br>    if (iteratee == null) {<br>        return _.identity;<br>    }</p>
<pre><code>if (_.isFunction(iteratee)) {
    return optimizeCb(iteratee, context, count);
}
</code></pre><p>}</p>
<p>//optimizeCb优化迭代器<br>var optimizeCb = function(func, context, count) {<br>    if (context == void 0) {<br>        return func;<br>    }</p>
<pre><code>switch (count == null ? 3 : count) {
    case 1:
        //私以为，这个返回写的很腻害哇
        return function(value) {
            return func.call(context, value);
        };
    case 3:
        //私以为，这个返回写的很腻害哇
        return function(value, index, obj) {
            return func.call(context, value, index, obj);
        };
}
</code></pre><p>}</p>
<p>//默认迭代器<br>_.identity = function(value) {<br>    return value;<br>}<br><br>这节课还有一个知识点，就是类型判定，这次代码给了更优雅的类型判定的写法</p>
<p><pre><br>_.each([“Function”, “String”, “Object”, “Number”], function(name) {<br>    _[“is” + name] = function(obj) {<br>        return toString.call(obj) === “[object “ + name + “]”;<br>    }<br>});<br></pre><br>这节课完整代码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/25/网易微专业-Underscore-3-1-3-undefined的处理iteratee设计/" data-id="ckchm0rct001p5ajhipbwk6de" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/14/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/拉勾/">拉勾</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾/">拉勾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业/">网易微专业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECMAScript新特性/" style="font-size: 10px;">ECMAScript新特性</a> <a href="/tags/JavaScript异步编程/" style="font-size: 10px;">JavaScript异步编程</a> <a href="/tags/TypeScript语言/" style="font-size: 10px;">TypeScript语言</a> <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/函数式编程范式/" style="font-size: 10px;">函数式编程范式</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/手写Promise源码/" style="font-size: 10px;">手写Promise源码</a> <a href="/tags/拉勾/" style="font-size: 20px;">拉勾</a> <a href="/tags/拉勾，自动化构建/" style="font-size: 10px;">拉勾，自动化构建</a> <a href="/tags/数据结构/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 17.5px;">算法</a> <a href="/tags/网易微专业/" style="font-size: 10px;">网易微专业</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/08/拉勾-自动化构建/">拉勾-自动化构建</a>
          </li>
        
          <li>
            <a href="/2020/07/03/拉勾-脚手架工具/">拉勾-脚手架工具</a>
          </li>
        
          <li>
            <a href="/2020/07/03/拉勾-工程化概述/">拉勾-工程化概述</a>
          </li>
        
          <li>
            <a href="/2020/06/28/拉勾-JavaScript性能优化/">拉勾-JavaScript性能优化</a>
          </li>
        
          <li>
            <a href="/2020/06/26/拉勾-TypeScript语言/">拉勾-TypeScript语言</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>