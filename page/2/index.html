<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="喵小喵的窝">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="喵小喵的窝">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-拉勾-工程化概述" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/03/拉勾-工程化概述/" class="article-date">
  <time datetime="2020-07-03T06:31:24.000Z" itemprop="datePublished">2020-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/03/拉勾-工程化概述/">拉勾-工程化概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.工程化的定义和主要解决的问题<br>主要解决的问题:传统语言或语法的弊端，无法使用模块化/组件化，重复的机械式工作，代码风格统一、质量保证，依赖后端服务接口支持，整体依赖后端项目<br>2.一个项目过程中工程化表现<br>一切以提高效率、降低成本、质量保证为目的的手段都属于”工程化”<br>一切重复的工作都应该被自动化<br>创建项目(创建项目结构，创建特定类型文件)(通过脚手架工具自动帮我们完成基础结构 的搭建)<br>编码(格式化代码，校验代码风格，编译、构建、打包)(借助工程化工具自动化帮我们做一些的代码的格式化，代码风格的校验)<br>预览/测试(Web Server/Mock,Live Reloading/HMR,Source Map)(借助现代化webserver实现热更新体验等)<br>提交(GitHooks,Lint-staged，持续集成)(githook自动化在代码提交之前做项目代码整体的检查)<br>部署(CI/CD，自动发布)<br>3.工程化不等于工具<br>工程化不等于某个工具。工程化的核心是对项目整体的规划/架构，工具是对这种规划的落地的手段<br>规划项目的整体结构，类似下图<br><img src="https://snakexu.github.io/images/lagou/part_2/engineering/3_1.png"><br>一些成熟的工程化集成:create-react-app/vue-cli/angular-cli/gatsby-cli<br>4.工程化与Node.js<br>Node.js对现在工程化开发起到了很大作用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/03/拉勾-工程化概述/" data-id="ckeeij2zw000wjoxqmr4c8ssa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工程化/">工程化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-JavaScript性能优化" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/28/拉勾-JavaScript性能优化/" class="article-date">
  <time datetime="2020-06-28T12:06:17.000Z" itemprop="datePublished">2020-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/28/拉勾-JavaScript性能优化/">拉勾-JavaScript性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.课程概述<br>·性能优化不可避免<br>·哪些内容可以看作性能优化：本质上来说任何一种可以提高运行效率，降低运行开销的行为都可以认为是性能优化<br>·无处不在的前端性能优化：例如请求资源时用到的网络，数据的传输方式，开发过程中所使用的框架等等都可以进行优化<br>本阶段的核心是JavaScript语言的优化，内容概要<br>·内存管理<br>·垃圾回收与常见GC算法<br>·V8引擎的垃圾回收<br>·Performance工具<br>·代码优化实例<br>2.内存管理<br>2-1.内存为什么需要管理<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/2_1.png"><br>从图中可以看到，我们一下子给数组索引值很大的地方添加了一个变量，导致内存泄漏性性能损耗很大<br>2-2.内存管理介绍<br>·内存:由可读写单元组成，表示一片可操作空间<br>·管理:人为的去操作一片空间的申请、使用和释放<br>·内存管理:开发者主动申请空间、使用空间、释放空间<br>·管理流程:申请-使用-释放<br>2-3.JavaScript中的内存管理<br>由于JavaScript没有提供相应的API，所以不能像一些语言可以由开发者主动调用API来完成相应空间的管理。但是我们可以通过js脚本来演示在内部一个空间的生命周期是怎样完成的</p>
<p><pre><br>//申请<br>let obj = {}<br>//使用<br>obj.name = “lg”<br>//释放<br>obj = null<br></pre><br>3.JavaScript中的垃圾回收<br>3-1.JavaScript中的垃圾<br>·JavaScript中内存管理是自动的<br>·对象不再被引用时是垃圾<br>·对象不能从根上访问到时是垃圾<br>3-2.JavaScript中的可达对象<br>·可以访问到的对象就是可达对象(引用、作用域链)<br>·可达的标准就是从根出发是否能够被找到<br>·JavaScript中的根就可以理解为是全局变量对象</p>
<p><pre><br>let obj = {name:’xm’}//空间被引用,obj是可达的<br>let ali = obj //被引用，多了一次引用，引用数值变化<br>obj = null//obj的引用被断掉了，但是{name:’xm’}的空间是存在的，因为遍历ali还存在<br></pre><br>下面这个例子会可以更多理解</p>
<p><pre><br>function objGroup(obj1,obj2){<br>    obj1.next = obj2<br>    obj2.prev = obj1<br>    return {<br>        o1:obj1,<br>        o2:obj2<br>    }<br>}<br>let obj = objGroup({name:’obj1’},{name:’obj2’})<br>console.log(obj)<br>//{<br>//  o1: <ref *1=""> {<br>//    name: ‘obj1’,<br>//    next: { name: ‘obj2’, prev: [Circular <em>1] }<br>//  },<br>//  o2: &lt;ref </em>2&gt; {<br>//    name: ‘obj2’,<br>//    prev: <ref *1=""> { name: ‘obj1’, next: [Circular *2] }<br>//  }<br>//}<br></ref></ref></pre><br>我们结合上面的代码和下面的图一起来看<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/3_1.png"><br>我们从全局global出发，找到可达obj对象，通过函数调用指向一个内存空间，内存空间中有o1和o2，在o1和o2里边我们又通过相应的属性去指向obj1的空间和obj2的空间，对于obj1和obj2，又通过next和prev做了一个互相的引用。目前来说我们代码中出现的对象都可以从根上进行查找到。如果此时我们通过delete obj.o1和delete obj2.prev，我们去掉obj对o1的引用以及obj2对o1的引用，那么此时我们很难再通过什么方式找到obj1的空间<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/3_2.png"><br>上图红线部分表示我们delete操作之后的情况，此时obj1就会被认为是垃圾，被JavaScript引擎进行回收。<br>4.GC算法介绍<br>4-1.GC定义与作用<br>·GC就是垃圾回收机制的简写<br>·GC可以找到内存中的垃圾、并释放和回收空间<br>4-2.GC里的垃圾是什么<br>·程序中不再需要使用的对象</p>
<p><pre><br>function func(){<br>    name = ‘lg’<br>    return <code>${name} is a coder</code><br>}<br>func()<br></pre><br>·程序中不能再访问到的对象</p>
<p><pre><br>function func(){<br>    const name = ‘lg’<br>    return <code>${name} is a coder</code><br>}<br>func()<br></pre><br>4-3.GC算法是什么<br>·GC算法是一种机制，垃圾回收器完成具体的工作<br>·工作内容就是查找垃圾释放空间、回收空间<br>·算法就是工作时查找和回收所遵循的规则<br>4-4.常见GC算法<br>·引用计数<br>·标记清除<br>·标记整理<br>·分代回收<br>5.引用计数算法实现原理<br>·核心思想:设置引用数，判断当前引用数是否为0<br>·引用计数器<br>·引用关系改变时修改引用数字<br>·引用数字为0时立即回收</p>
<p><pre><br>const user1 = {age:11}<br>const user2 = {age:22}<br>const user3 = {age:33}<br>const nameList = [user1.age,user2.age,user3.age]<br>function fn(){<br>    num1 = 1<br>    num2 = 2<br>}<br>fn()<br></pre><br>这种情况下当前全局有user1、user2、user3、nameList、num1、num2变量，这些变量的引用计数都不为0。如果我们稍作修改</p>
<p><pre><br>function fn(){<br>    const num1 = 1<br>    const num2 = 2<br>}<br></pre><br>那么在fn执行完毕后，在外部全局作用域不能找到num1、num2，num1、num2的引用计数为0，会被作为垃圾回收。而user1、user2、user3被nameList引用，即使脚本执行完毕，user1、user2、user3的引用计数器都不为0，不会被作为垃圾回收。<br>6.引用计数算法优缺点<br>优点：<br>·发现垃圾时立即回收<br>·最大限度减少程序暂停(应用程序执行必然对内存有消耗，而我们执行平台的内存是有上限的，内存肯定有占满的时候，由于引用计数算法时刻监控着引用数值为0的情况，即使内存即将被占满，由于有引用计数时刻监测着引用为0的变量，进行垃圾回收，保证了当前内存不会有占满的时候)<br>缺点：<br>·无法回收循环引用的对象<br>·时间开销大(当前引用计数需要维护一个数值的变化，就需要时刻监控当前对象的引用数值是否发生变化，数值修改本身就需要消耗时间，如果内存中很多对象都需要变化时间就会显得更大一些)</p>
<p><pre><br>//循环引用对象<br>function fn(){<br>    const obj1 = {}<br>    const obj2 = {}<br>    obj1.name = obj2<br>    obj2.name = obj1<br>    return ‘lg is a coder’<br>}<br>fn()<br></pre><br>虽然在fn执行完毕后，外部不再有对obj1、obj2的引用，但是函数内部o bj1和obj2互相引用，造成引用计数无法为0，无法释放变量空间，造成内存的浪费<br>7.标记清除算法实现原理<br>·核心思想:分标记和清除二个阶段完成<br>·遍历所有对象找标记活动对象<br>·遍历所有对象清除没有标记对象<br>·回收相应的空间<br> <img src="https://snakexu.github.io/images/lagou/part_1/performance/7_1.png"><br> 在标记阶段找到所有可达对象(会递归查找，比如图中global找到A再找到D)，将可达对象进行标记；标记完成之后进行清除，找到没有标记的对象，进行清除，同时将标记阶段做的标记清除，这样就完成了一次垃圾的回收，还会将回收的空间放到空闲列表上，方便后续的程序申请使用。而上图中的a1、b1可能是当前局部作用域，而当前局部作用域执行完成以后空间就会被回收，在global链条下找不到a1、b1，GC机制认为a1、b1是垃圾对象，不进行标记，a1、b1被垃圾回收。<br>8.标记清除算法的优缺点<br>相比引用计数，标记清除解决了循环引用的问题。缺点是容易造成内存空间的碎片化，也就是回收的内存空间在地址上不是连续在一起的，不能使空间得到最大化的使用<br>9.标记整理算法实现原理<br>·标记整理可以看作是标记清除的增强<br>·标记阶段的操作和标记清除一致<br>·清除阶段会先执行整理，移动对象位置<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/9_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/performance/9_2.png"><br>10.常见GC算法总结<br>常见GC算法：<br>·引用计数<br>  可以即时回收垃圾对象<br>  可以即时回收垃圾对象<br>  减少程序卡顿时间<br>  无法回收循环引用的对象<br>  资源消耗较大<br>·标记清除<br>  可以回收循环引用的对象<br>  容易产生碎片化空间，浪费空间<br>  不会立即回收垃圾对象<br>·标记整理<br>  减少碎片化空间<br>  不会立即回收垃圾对象<br>11.认识V8<br>·V8是一款主流的JavaScript执行引擎(chrome浏览器，node平台都是在用V8执行代码)<br>·V8采用即时编译<br>·V8内存设限(V8是为浏览器制造的，现有内存大小对网页应用来说足够使用了；V8内部的垃圾回收机制来说这个内存限制也是合理的)<br>12.V8垃圾回收策略<br>在程序使用过程中我们需要用到很多数据，包括原始数据、对象数据。对于原始数据来说都是程序语言自身来进行控制的，所以我们提到的垃圾回收主要还是存在堆区里的对象数据，因此这个过程是离不开内存操作的，而V8对内存是设置了上限的，因为我们想知道在这种情况下是怎么进行垃圾回收的<br>V8垃圾回收策略<br>·采用分代回收的思想<br>·内存分为新生代、老生代(后面介绍如何划分新生代、老生代)<br>·针对不同对象采用不同算法<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/12_1.png"><br>V8中常用GC算法<br>·分代回收<br>·空间复制<br>·标记清除<br>·标记整理<br>·标记增量<br>13.V8如何回收新生代对象<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/13_1.png"><br>V8内存分配<br>·V8内存空间一分为二(上面图中左边带白色部分为新生代，右边老生代存储区有写明)<br>·小空间用于存储新生代对象(32M|16M)<br>·新生代指的是存活时间较短的对象<br>新生代对象回收实现<br>·回收过程中采用复制算法+标记整理<br>·新生代内存区分为二个等大小空间<br>·使用空间为From，空闲空间为To<br>·活动对象存储于from空间<br>·标记整理后将活动对象拷贝至To(可以得到连续的存储空间)<br>·From与To交换空间完成释放<br>回收细节说明<br>·拷贝过程中可能出现晋升<br>·晋升就是将新生代对象移动至老生代<br>·一轮GC还存活的新生代需要晋升<br>·To空间的使用率超过25%需要晋升(怕将来交换之后新进对象没有操作空间)<br>14.V8如何回收老生代对象<br>老生代对象说明<br>·老生代对象存放在右侧老生代区域<br>·64位操作系统1.4G，32位操作系统700M<br>·老生代对象就是指存活时间较长的对象(例如全局变量，一些闭包中的变量数据)<br>老生代对象回收实现<br>·主要采用标记清除、标记整理、增量标记算法<br>·首先使用标记清除完成垃圾空间的回收<br>·采用标记整理进行空间优化(发现老生代存储空间不满足需求的情况下)<br>·采用增量标记进行效率优化<br>细节对比<br>·新生代区域垃圾回收使用空间换时间<br>·老生代垃圾回收不适合复制算法(相对新生代空间，老生代空间较大，采用复制算法消耗较大)<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/14_1.png"><br>标记增量:将我们当前一整段的垃圾回收拆分成多个小步去实现，从而去替代之前一口气完成的垃圾回收，从而完成程序执行与垃圾回收交替运行，时间安排更加合理<br>15.V8垃圾回收总结<br>·V8是一款主流的JavaScript执行引擎<br>·V8内存设置上限<br>·V8采用基于分代回收思想实现垃圾回收<br>·V8内存分为新生代和老生代<br>·V8垃圾回收常见的GC算法<br>16.Performance工具介绍<br>为什么使用Performance<br>·GC的目的是为了实现内存空间的良性循环<br>·良性循环的基石是合理使用<br>·时刻关注才能确定是否合理<br>·Performance提供多种监控方式<br>通过Performance时刻监控内存<br>Performance使用步骤<br>·打开浏览器输入目标网址<br>·进入开发人员工具面板，选择性能<br>·开启录制功能，访问具体界面<br>·执行用户行为，一段时间后停止录制<br>·分析界面中记录的内存信息<br>17.内存问题的体现<br>内存问题的外在表现<br>·页面出现延迟加载或经常性暂停<br>在网络环境正常的情况下，一般判定内存有问题，而且与GC频繁的垃圾回收操作相关——程序代码中存在瞬间让程序爆掉的代码<br>·页面持续性出现糟糕的性能<br>有可能存在内存膨胀——当前界面为了去达到最佳使用速度会去申请一定的内存空间，而申请的内存空间远大于当前设备所能提供的内存大小<br>·页面的性能随时间延长越来越差<br>通常伴随着内存的泄漏<br>18.监控内存的几种方式<br>界定内存问题的标准<br>·内存泄漏：内存使用持续升高<br>·内存膨胀：在多数设备上都存在性能问题<br>·频繁垃圾回收：通过内存变化图进行分析<br>监控内存的几种方式<br>·浏览器任务管理器<br>·Timeline时序图记录<br>·堆快照查找分离DOM<br>·判断是否存在频繁的垃圾回收<br>19.任务管理器监控内存</p>
<p><pre><br>&lt; button id=”btn” &gt;Add&lt; /button &gt;<br>&lt; script &gt;<br>    const oBtn = document.getElementById(‘btn’);<br>    oBtn.onclick = function(){<br>        let arrList = new Array(1000000)<br>    }<br>&lt; /script &gt;<br></pre><br>写完上面代码，我们打开浏览器，shift+ESC调出浏览器任务管理器，在浏览器任务管理器上右键单击，选择JavaScript内存，在浏览器的任务管理器上会多出JavaScript内存一列<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/19_1.png"><br>上图中内存一列和JavaScript内存一列有什么不同呢？内存一列是原生内存，可以理解为浏览器中DOM节点占据的内存，如果这个值持续增大，那么代表界面中在不断持续的创建新的DOM。JavaScript内存是表示JavaScript堆，这列中我们需要关注的是小括号内的值，表示的是界面中所有可达对象正在使用的内存大小，这个值增大表示，要么在创建新对象，要么当前对象一直在增长。我们点击几次刚才的button，再来看浏览器任务管理器，会看到JavaScript内存变大。借助这样一个方式，我们监控当前浏览器内存的变化。如果JavaScript内存的值一直增大，可以断定程序有问题，但是想知道有什么问题，不是浏览器任务管理器能满足的了。<br>20.Timeline记录内存</p>
<p><pre><br>&lt; button id=”btn” &gt;Add&lt; /button &gt;<br>&lt; script &gt;<br>    const arrList = []<br>    function test(){<br>        for(var i =0; i &lt; 100000; i++){<br>            document.body.appendChild(document.createElement(‘p’))<br>        }<br>        arrList.push(new Array(100000).join(‘x’))//这些操作都是为了引起页面性能明显变化<br>    }<br>    document.getElementById(‘btn’).addEventListener(‘click’,test)<br>&lt; /script &gt;<br></pre><br>打开浏览器开发者工具，选择性能，开始录制，多次点击按钮，结束录制，只展示内存变化<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/20_1.png"><br>这里性能有升有降，证明垃圾回收机制正常起作用了。如果一直是在上升而不下降，那么就有可能是内存泄漏，我们可以具体查看时间线上的节点判断哪里出问题。<br>21.堆快照查找分离DOM<br>什么是分离DOM<br>·界面元素存活在DOM树上<br>·垃圾对象时的DOM节点<br>·分离状态的DOM节点</p>
<p><pre><br>&lt; button id=”btn” &gt;Add&lt; /button &gt;<br>&lt; script &gt;<br>var tmpEle<br>function fn(){<br>    var ul = document.createElement(‘ul’)<br>    for(var i =0; i &lt; 100000; i++){<br>        var li = document.createElement(‘li’)<br>        ul.appendChild(li)<br>    }<br>    tmpEle = ul//我们并没有把新创建的DOM添加到页面中，属于分离DOM的一种<br>}<br>document.getElementById(‘btn’).addEventListener(‘click’,fn)<br>&lt; /script &gt;<br></pre><br>首先我们在页面没有进行操作的时候点击一下堆快照<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/21_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/performance/21_2.png"><br>然后筛选deta，发现没有内容。当我们点击当前页面按钮，再次执行上面的操作，拍摄快照，筛选内容<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/21_3.png"><br>就会发现当前页面有我们在代码里创建的分离DOM，解决方案就是把分离DOM置空</p>
<p><pre><br>&lt; button id=”btn” &gt;Add&lt; /button &gt;<br>&lt; script &gt;<br>var tmpEle<br>function fn(){<br>    var ul = document.createElement(‘ul’)<br>    for(var i =0; i &lt; 100000; i++){<br>        var li = document.createElement(‘li’)<br>        ul.appendChild(li)<br>    }<br>    tmpEle = ul<br>    tmpEle = null<br>}<br>document.getElementById(‘btn’).addEventListener(‘click’,fn)<br>&lt; /script &gt;<br></pre><br>22.判断是否存在频繁GC<br>为什么确定频繁垃圾回收<br>·GC工作时应用程序是停止的<br>·频繁且过长的GC会导致应用假死<br>·用户使用中感知应用卡顿<br>确定频繁的垃圾回收<br>·Timeline中频繁的上升下降<br>·任务管理器中数据频繁的增加减小<br>23.Performance总结<br>·Performance使用流程<br>·内存问题的相关分析<br>·Performance时序图监控内存变化<br>·任务管理器监控内存变化<br>·堆快照查找分离DOM<br>24.代码优化介绍<br>如何精准测试JavaScript性能<br>·本质上就是采集大量的执行样本进行数学统计和分析<br>·使用基于Benchmark.js的 <a href="https://jsperf.com/" target="_blank" rel="noopener">https://jsperf.com/</a> 完成<br>Jsperf使用流程<br>·使用GitHub账号登陆<br>·填写个人信息(非必填)<br>·填写详细的测试用例信息(title、slug)<br>·填写准备代码(DOM操作时经常使用)<br>·填写必要有setup与teardowm代码<br>·填写测试代码片段<br>25.慎用全局变量<br>为什么要慎用<br>·全局变量定义在全局执行上下文，是所有作用域链的顶端(一直会查找到全局作用域，影响性能)<br>·全局执行上下文一直存在于上下文执行栈，直到程序退出(全局变量一直存在影响GC)<br>·如果某个局部作用域出现了同名变量则会遮蔽或污染全局<br>之前我们讲过注册jsperf，然后在jsperf上执行代码，查看差异，就能看出全局变量与局部变量的执行差异<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/25_1.png"><br>26.缓存全局变量<br>将使用中无法避免的全局变量缓存到局部</p>
<p><pre><br>&lt; input type=”button” value=”btn” id=”btn1” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn2” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn3” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn4” &gt;<br>  &lt; p &gt;1111&lt; /p &gt;<br>  &lt; input type=”button” value=”btn” id=”btn5” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn6” &gt;<br>  &lt; p&gt;222&lt; /p&gt;<br>  &lt; input type=”button” value=”btn” id=”btn7” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn8” &gt;<br>  &lt; p&gt;333&lt; /p&gt;<br>  &lt; input type=”button” value=”btn” id=”btn9” &gt;<br>  &lt; input type=”button” value=”btn” id=”btn10” &gt;</pre></p>
<p>  &lt; script &gt;<br>    function getBtn() {<br>      let oBtn1 = document.getElementById(‘btn1’)<br>      let oBtn3 = document.getElementById(‘btn3’)<br>      let oBtn5 = document.getElementById(‘btn5’)<br>      let oBtn7 = document.getElementById(‘btn7’)<br>      let oBtn9 = document.getElementById(‘btn9’)<br>    }</p>
<pre><code>function getBtn2() {
  let obj = document
  let oBtn1 = obj.getElementById(&apos;btn1&apos;)
  let oBtn3 = obj.getElementById(&apos;btn3&apos;)
  let oBtn5 = obj.getElementById(&apos;btn5&apos;)
  let oBtn7 = obj.getElementById(&apos;btn7&apos;)
  let oBtn9 = obj.getElementById(&apos;btn9&apos;)
}
</code></pre><p>  &lt; /script &gt;<br><br>这里要在jsperf中执行上面代码，因为有html代码所以需要一点不同的操作，同学们自己了解一下，执行代码效果<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/26_1.png"><br>27.通过原型对象添加附加方法<br>通过原型新增方法，在原型对象上新增实例对象需要的方法</p>
<p><pre><br>var fn1 = function() {<br>  this.foo = function() {<br>    console.log(11111)<br>  }<br>}<br>let f1 = new fn1()<br>var fn2 = function() {}<br>fn2.prototype.foo = function() {<br>  console.log(11111)<br>}<br>let f2 = new fn2()<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_1/performance/27_1.png"><br>28.避开闭包陷阱<br>闭包特点<br>·外部具有指向内部的引用<br>·在”外部”作用域访问”内部”作用域的数据(这里内、外的概念用的并不是很标准，以后慢慢了解)<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/28_1.png"><br>关于闭包<br>·闭包是一种很强大的语法<br>·闭包使用不当很容易出现内存泄漏<br>·不要为了闭包而闭包</p>
<p><pre><br>function foo(){<br>  var el = document.getElementById(‘btn’);//html页面上存在的一个元素<br>  el.onclick = function(){<br>    console.log(el.id)<br>  }<br>  //如果元素在页面被移除，而上面还调用了el，导致元素引用计数不为0，不能被垃圾回收导致内存泄漏<br>  //这里el置空使btn元素引用计数为0，可以顺利被垃圾回收<br>  el = null<br>}<br></pre><br>29.避免属性访问方法使用<br>JavaScript中的面向对象<br>·JavaScript不需属性的访问方法，所有属性都是外部可见的<br>·使用属性访问方法只会增加一层重定义，没有访问的控制力</p>
<p><pre><br>function Person() {<br>  this.name = ‘icoder’<br>  this.age = 18<br>  this.getAge = function() {<br>    return this.age<br>  }<br>}<br>const p1 = new Person()<br>const a = p1.getAge()<br>//与上面代码进行执行效率对比<br>function Person() {<br>  this.name = ‘icoder’<br>  this.age = 18<br>}<br>const p2 = new Person()<br>const b = p2.age<br></pre><br>上面代码中两种访问方式执行效率对比，得出直接访问属性效率更高<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/29_1.png"><br>30.For循环优化</p>
<p><pre><br>var arrList = []<br>arrList[10000] = ‘icoder’<br>for (var i = 0; i &lt; arrList.length; i++) {<br>  console.log(arrList[i])<br>}<br>for (var i = arrList.length; i; i–) {<br>  console.log(arrList[i])<br>}<br></pre><br>这里主要是想说明如果提前获取要遍历元素的长度比在for循环中每次i &lt; arr.length执行效率要高，尤其在被遍历元素量级很大的时候会比较明显<br>31.选择最优的循环方法</p>
<p><pre><br>arrList.forEach(function(item) {<br>  console.log(item)<br>})<br>for (var i = arrList.length; i; i–) {<br>  console.log(arrList[i])<br>}<br>for (var i in arrList) {<br>  console.log(arrList[i])<br>}<br></pre><br>这里主要对比三种遍历方式执行效率的差异(这里注意for循环是提前计算length，而不是每次循环i &lt; length 这种)<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/31_1.png"><br>可以看出性能角度forEach &gt; for &gt; for…in<br>32.文档随便优化节点添加<br>节点的添加操作必然有回流和重绘， 这两个操作对性能消耗比较大</p>
<p><pre><br>//第一种添加方式<br>for (var i = 0; i &lt; 10; i++) {<br>      var oP = document.createElement(‘p’)<br>      oP.innerHTML = i<br>      document.body.appendChild(oP)<br>}<br>//第二种添加方式<br>const fragEle = document.createDocumentFragment()<br>for (var i = 0; i &lt; 10; i++) {<br>    var oP = document.createElement(‘p’)<br>    oP.innerHTML = i<br>    fragEle.appendChild(oP)<br>}<br>document.body.appendChild(fragEle)<br></pre><br>对比两种添加节点对方式，明显第二种方式添加效率比较好<br><img src="https://snakexu.github.io/images/lagou/part_1/performance/32_1.png"><br>33.克隆优化节点操作<br>当我们要去新增节点，可以先找到一个相似节点去克隆，再把克隆的节点添加到界面(被克隆到节点可能已经具有样式/属性，我们不用再额外添加)</p>
<p><pre><br>//传统方法<br>for (var i = 0; i &lt; 3; i++) {<br>    var oP = document.createElement(‘p’)<br>    oP.innerHTML = i<br>    document.body.appendChild(oP)<br>}<br>//克隆方法<br>var oldP = document.getElementById(‘box1’)//假设已经存在box1节点<br>for (var i = 0; i &lt; 3; i++) {<br>    var newP = oldP.cloneNode(false)<br>    newP.innerHTML = i<br>    document.body.appendChild(newP)<br>}<br></pre><br>采用第二种克隆方法性能优于传统添加节点方式<br>34.直接量替换new Object</p>
<p><pre><br>// 采用字面量<br>var a = [1, 2, 3]<br>// 采用new<br>var a1 = new Array(3)<br>a1[0] = 1<br>a1[1] = 2<br>a1[2] = 3<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_1/performance/34_1.png"><br>采用字面量优于new去创建 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/28/拉勾-JavaScript性能优化/" data-id="ckeeij36n005ajoxq898nyrsd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-TypeScript语言" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/26/拉勾-TypeScript语言/" class="article-date">
  <time datetime="2020-06-26T10:32:05.000Z" itemprop="datePublished">2020-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/26/拉勾-TypeScript语言/">拉勾-TypeScript语言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.课程概述<br>解决JavaScript类型系统的问题，TypeScript大大提高代码的可靠程度。我们这里其实主要讨论的是JavaScript自有类型系统的问题以及如何借助一些优秀的方案解决这些问题，TypeScript是在这个过程中我们涉及到的一门语言，因为TypeScript目前是此类问题最终级的解决方案，所以我们会着重学习TypeScript。本章主要学习:<br>(1)强类型与弱类型<br>(2)静态类型与动态类型<br>(3)JavaScript自有类型系统的问题<br>(4)Flow静态类型检查方案<br>(5)TypeScript语言规范与基本应用<br>2.强类型与弱类型<br>·强类型与弱类型(类型安全)<br>·静态类型与动态类型(类型检查)<br>强类型:在语言层面限制函数的实参类型必须与形参类型相同<br><img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/2_1.png"><br>弱类型:在语言层面不会限制实参的类型<br><img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/2_2.png"><br>由于这种强弱之分并不是某一个权威机构的定义，导致大家在细节方面的认知略有不同，不过总体上是强类型有更强的类型约束，而弱类型中几乎没有什么约束。老师个人认为强类型语言中不能有任意类型的隐式类型转换，而弱类型语言则允许任意的数据隐式类型转换，比如下图我们在终端做了字符串与数字类型的减法操作，并没有报错，因为JavaScript会做隐式类型转换<br><img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/2_3.png"><br>有人会说，JavaScript也会报类型错误，比如<br><img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/2_4.png"><br>这里要注意，我们说的强类型是在语言的语法层面就限制了不允许传入不同类型的值，如果我们传入不同类型的值在编译就报类型错误，而不是等到运行阶段再通过逻辑判断去限制。在JavaScript中所有报出的类型错误都是在代码层面在运行时通过逻辑判断的。<br>总结：强类型不允许随意的隐式转换，而弱类型允许。变量类型允许随时改变的特点不是强弱类型的差异<br>3.静态类型与动态类型<br>静态类型:一个变量声明的时候它的类型就是明确的，声明过后，它的类型就不允许再修改<br>动态类型:运行阶段才能够明确变量类型，而且变量类型可以随时改变<br>在JavaScript中<br><img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/3_1.png"><br>在运行时才明确var定义的foo变量是NUMBER类型，再将number类型的foo修改为字符串，也是允许的。那我们也可以说动态类型语言中的变量没有类型，变量中存放的值是有类型的。JavaScript是一门标准的动态类型语言。<br>4.JavaScript类型系统特征<br>弱类型且动态类型，本身类型系统非常薄弱，所以类型是非常灵活的，也带来了缺点-缺失了类型系统的可靠性。为什么JavaScript不能设计成强类型/静态类型的语言？因为早期JavaScript应用简单，几十行代码是非常够用的，这时候类型系统就显得很多余了；另外就是JavaScript是一门脚本语言，没有编译环节，而静态类型语言需要在编译阶段做静态类型检查。基于以上原因，JavaScript成为了一门更灵活(弱类型/静态类型)的语言。而随着JavaScript开发的项目规模越来越大，这些曾经的优势变为了短板。<br>5.弱类型的问题</p>
<pre>
const obj = {}
obj.foo()//报错，运行时才能发现错误
function sum(a,b){
    return a+b
}
console.log(sum(100,100))
console.log(sum(100,'100'))//变成了字符串拼接，类型不明确导致函数功能发生改变
obj[true] = 100
console.log(obj['true'])//在对象中属性名默认为string，对对象索引器的错误用法 
</pre>
综上，在代码规模比较小的情况下，弱类型的弱势并不是很明显，但是在开发周期长的大型项目中，弱类型的弱势就很明显了，而君子协议的约定是有隐患的，强制约定才是一种保障，提前消灭一大部分异常而不必等到运行时再慢慢debug
6.强类型的优势
6-1.错误更早暴露
6-2.代码更智能，编码更准确
6-3.重构更牢靠
6-4.减少不必要的类型判断
7.Flow概述
JavaScript的类型检查器。可以在需要的地方写上类型，而在生产环境可以通过babel等消除，而且不必对每一个变量都写类型注解，可以说非常方便
8.Flow快速上手
创建一个项目，安装flow
//老师课程里是用yarn安装使用的flow，我在本地项目用的npm按装使用，用npm安装和普通插件安装一样，如何使用参考
//https://blog.csdn.net/qq_38785020/article/details/89642800
<pre>
// @flow//这里必须要写，是告诉flow，我需要你检查这个文件
function sum (a: number, b: number) {
  return a + b
}
sum(100, 100)
sum(100, '100')//Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ 01-getting-started.js:7:10
               //Cannot call sum with '100' bound to b because string [1] is incompatible with
               //number [2]. [incompatible-call]
</pre>
执行npm run flow的部分结果如下图
<img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/6_1.png">
9.Flow编译移除注解
为了类型检查，我们给代码添加了一些注解，这些注解并不是JavaScript的标准语法，以至于js是无法正常运行的，如果想运行，那么就要在开发过后移除这些类型注解。移除这些注解，现在有两种方式，一种就是官方推荐的flow-remove-types，这是最快速最简单的办法。首先安装flow-remove-types，然后在package.json文件的script中添加"remove":"flow-remove-types . -d dist"，此时执行npm run remove就可以看到当前目录下生成了dist文件夹，dist文件夹中无类型注解。
flow-remove-types命令:flow-remove-types 要移除注解的文件夹 -d 输出文件夹
另外一个方法就是通过babel去移除。这里需要安装@babel/core(babel的核心模块)、@babel/cli、@babel/preset-flow。然后添加.babelrc文件，文件中内容
{
    "preset":["@babel/preset-flow"]
}
执行的命令是:babel 执行目录 -d 输出目录
这两种方案选哪种合适？如果你的项目中已经引入babel，那么babel/preset-flow就挺好的，其实到底用哪种自己根据项目考虑最合适的就好
9.Flow开发工具插件
上面我们都是在命令行执行flow检查错误，并不能在代码中直观看到问题到底在哪儿，用户体验差了一些，我们可以在vscode中搜索Flow Language Support，这个是Flow官方提供的插件
https://flow.org/en/docs/editors flow官网对编辑器插件支持的情况
10.Flow 类型推断
Flow会根据我们的代码聪明的做一些类型推断
<pre>
function square(n){
    return n*n
}
square('10')//即使我们在没有给函数添加类型注解的情况下，如果我们输入字符串作为参数，也会报错
</pre>
11.Flow 类型注解
尽管flow很聪明的帮我们做一些类型推断，但是我们还是写上注解比价好，这样方便程序的理解。另外Flow的几个基础用法
<pre>
/**类型注解
*
*@flow
*/
function square(n:number){
    return n*n
}
let num:number = 10
function foo():number{//返回值类型为number，如果没有返回值，可以写void
    //return 101//不报错
    //return 'string'//报错
}
</pre>
13.Flow 原始类型
<pre>
const a: string = 'foobar'
const b: number = Infinity // NaN // 100
const c: boolean = false // true
const d: null = null
const e: void = undefined
const f: symbol = Symbol()
</pre>
14.Flow 数组类型
<pre>
/**
 * 数组类型
 *
 * @flow
 */
const arr1: Array< number > = [1, 2, 3]//这里和tyescript很像，指定了数组里所有元素的类型都为number
const arr2: number[] = [1, 2, 3]
// 元组
const foo: [string, number] = ['foo', 100]
</pre>
15.Flow 对象类型
<pre>
/**
 * 对象类型
 *
 * @flow
 */
const obj1: { foo: string, bar: number } = { foo: 'string', bar: 100 }
const obj2: { foo?: string, bar: number } = { bar: 100 }//?是可选项
const obj3: { [string]: string } = {}//默认给对象添加属性的方法是可以的
obj3.key1 = 'value1'
obj3.key2 = 'value2'
</pre>
16.Flow 函数类型
<pre>
/**
 * 函数类型
 *
 * @flow
 */
function foo (callback: (string, number) => void) {
  callback('string', 100)
}
foo(function (str, n) {
  // str => string
  // n => number
})
</pre>
在之前，我们已经把基础的函数类型注解了解过了，这里主要是如果函数参数是callback函数如何注解
17.Flow 特殊类型
<pre>
/**
 * 特殊类型
 *
 * @flow
 */

// 字面量类型
const a: 'foo' = 'foo'
const type: 'success' | 'warning' | 'danger' = 'success'
// ------------------------
// 声明类型
type StringOrNumber = string | number
const b: StringOrNumber = 'string' // 100
// ------------------------
// Maybe 类型
const gender: ?number = undefined
// 相当于
// const gender: number | null | void = undefined
</pre>
18.Flow Mixed与Any
Mixed和Any都可以接收任意类型的值，但是不同点在于Mixed更接近于强类型的概念，Any更接近于弱类型的概念
<pre>
/**
 * Mixed Any
 *
 * @flow
 */
// string | number | boolean | ....
function passMixed (value: mixed) {
  //value.substr(1)
  //value * value////先按字符串类型运算再按数值类型运算会报错
  if (typeof value === 'string') {
    value.substr(1)
  }
  if (typeof value === 'number') {
    value * value
  }
}
passMixed('string')
passMixed(100)
// ---------------------------------
function passAny (value: any) {
  value.substr(1)
  value * value//先按字符串类型运算再按数值类型运算不会报错
}
passAny('string')
passAny(100)
</pre>
19.Flow 类型小结
https://flow.org/en/docs/types/ 对flow中所有类型的一个总结，因为我们不会逐个讲flow的类型
https://www.saltycrane.com/cheat-sheets/flow-type/latest/ 一个第三方的类型手册，可以更方便做查询
20.Flow 运行环境API
Flow在不同的运行环境，比如在浏览器和在node会有一些不同的类型注解
<pre>
/**
 * 运行环境 API
 *
 * @flow
 */
const element: HTMLElement | null = document.getElementById('app')
</pre>
一些API说明文件的链接
<img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/20_1.png">
21.TypeScript概述
TypeScript是基于JavaScript基础之上的编程语言，很多时候我们都在说是JavaScript的超集。由于TypeScript可以编译为JavaScript，那么任何支持JavaScript的运行环境都支持TypeScript。TypeScript功能比Flow更为强大，生态也更健全更完善。可以是TypeScript是前端开发的第二语言。但是再好的语言也会有一些缺点
缺点一:语言本身多了很多概念
TypeScript属于“渐进式”，就是即使我们对TypeScript的概念并不了解，仍可以按照JavaScript的标准语法去编写TypeScript代码，在开发过程中了解一个特性就可以使用一个特性
缺点二:项目初期，TypeScript会增加一些成本
但是随着项目的发展，这些一开始的开销反而会变成优势
22.TypeScript快速上手
首先新建项目，在项目中安装typescript，安装完成后我们在node_modules文件夹下看到.bin目录，在.bin目录下看到tsc，这是一个命令，这个命令的作用就是帮我们编译typescript代码。新建一个typescript文件01-getting-started.ts。虽然我们还不了解typescript，但是完全可以按照JavaScript的标准语法先来编写typescript的代码，而且typescript支持最新的ECMAScript标准。
<pre>
const hello = (name)=>{
    console.log(`hello ${name}`)
}
hello('TypeScript')
</pre>
在命令行执行tsc 01-getting-started.ts命令，然后就可以看到在项目的根目录下多了一个同名的js文件，js文件的内容是
<pre>
var hello = function (name) {
    console.log("hello " + name);
};
hello('TypeScript');
</pre>
通过tsc命令可以把我们的代码转换成了ES3标准的代码。另外对于类型检验，和Flow很像，比如
<pre>
const hello = (name:string)=>{
    console.log(`hello ${name}`)
}
hello('TypeScript')
hello(100)//执行tsc命令的时候报错
</pre>
tsc命令实际上就是TypeScript compile，这个命令去编译ts文件。在编译过程中，首先会检查typescript的类型使用是否异常，然后移除类型注解之类的扩展语法，并且在这个过程中会自动转换ES新特性为ES3标准的JavaScript
23.TypeScript配置文件
tsc命令不仅可以编译单个文件，还可以编译整个项目或者说整个工程。在编译整个项目之前，我们会先给这个项目创建一个typescript的配置文件，在命令行执行tsc --init 命令，可以看到生成了一个tsconfig.json文件。打开这个文件，我们简单看一下，这里大部分内容都被注释掉了，这里我们简单了解几个
<pre>
"target": "es5", //tsc命令将ts代码转换为甚么标准，这里是转换为es5标准
"module": "commonjs", //以commonjs标准执行模块化
"sourceMap": true,  //开启源代码映射
"outDir": "dist",  //tsc命令编译结果输出文件夹
"rootDir": "src",  //项目源代码文件夹
"strict": true,  //开启严格模式
</pre>
在严格模式下，不能不指定类型注解(在非严格模式下，不写类型注解被默认推断为any，在严格模式下，即使是any类型也要明确指定)。如果我们已经有配置文件，但是依然编译单个文件而不是整个项目，那么配置文件是不生效的，只有在用tsc命令编译整个项目的时候，配置文件才生效。此时执行tsc命令编译整个项目，会报错:
error TS6059: File '/myTypeScript/01-getting-started.ts' is not under 'rootDir' '/myTypeScript/src'. 'rootDir' is expected to contain all source files.
Found 1 error.
说明我们的配置文件已经生效了。
现在我们在项目下新建src文件夹，把之前编译生成的js文件删除，把ts文件移到src文件夹中，再次执行tsc命令，就会看到在根目录下多了dist文件夹，文件夹下有01-getting-started.js文件和01-getting-started。map文件。js文件内容如下
<pre>
"use strict";
var hello = function (name) {
    console.log("hello " + name);
};
hello('TypeScript');
//# sourceMappingURL=01-getting-started.js.map
</pre>
24.TypeScript原始类型
TypeScript大部分原始类型的用法和Flow很像。
<pre>
const a:string = 'foo'
const b:number = 100 //NaN //Infinity
const c:boolean = true //false
const d:string = null //严格模式下会报错
</pre>
上面这些在非严格模式下是允许为空/null，在非严格模式下是不允许为空的。tsconfig中的strict是开启所有严格检查的选项，如果只是检查变量不能为空，可以使用
<pre>
"strictNullChecks": true, 
</pre>
<pre>
const e:void=undefined//在函数没有返回值的时候标记返回值类型，只能存放undefined/null,严格模式下只能存放undefined
const f:null = null
const g:undefined = undefined
const h:symbol = Symbol()//报错，为什么报错？下回分解
</pre>
25.TypeScript标准库声明
<pre>
const h:symbol = Symbol()//报错，为什么报错，需要设置"target": "es2015"
</pre>
symbol是ES2015中新增的标准类型，symbol自身也是有类型的，而且这些类型在typescript中已经帮我们定义好了。在页面中写Array，然后在Array上单击右键，点击Goto Definition
<img src="https://snakexu.github.io/images/lagou/part_1/TypeScript/25_1.png">
能看到lib.es5.d.ts，这里声明了所有内置对象定义的类型，但是我们看到文件名中包含es5，这是一个es5所对应的标准库声明，但是symbol是es2015定义的内置类型，所以在es5定义的标准库中不能正确声明。但是如果我们既想编译到es5标准又想用es2015的标准怎么办呢？找到tsconfig配置文件中的lib选项
<pre>
lib": ["ES2015"],
</pre>
但是打开ts文件会发现console报错了，真是让人秃头，你猜怎么解决，没错，再次找到配置文件(因为console是浏览器环境下BOM对象提供的，所以要添加相应的标准库，谁让我们刚才写ES2015之后，别的标准库就被覆盖了呢)，然后在lib中添加DOM(ts中DOM和BOM合并成为DOM，可以少写几个字母，开心么)
<pre>
lib": ["ES2015","DOM"],
</pre>
总结一下就是标准库就是内置对象所对应的声明，在代码中使用内置对象就要引用所对应的标准库，否则ts就找不到对应的标准类型就会报错
26.TypeScript中文错误消息
ts会根据使用编辑器的语言来显示信息，但是很无奈，我们用的编辑器大部分都是英文的，不过ts还是有办法的，在执行tsc命令的时候
<pre>
tsc --locale zh-CN
</pre>
编辑器其实也有相应的语言转换插件，但是不建议使用，毕竟英文更有助于我们搜索问题
27.TypeScript作用域问题
我们在不同文件中定义const a，那么如果是在全局作用域中定义的话，就会报错，比如
<pre>
a.ts
const a:string = 'foo'
b.ts
const a:number = 1
</pre>
一种解决方案就是把他们放到不同的作用域中，例如我们可以用一个立即执行函数
<pre>
a.ts
const a:string = 'foo'
b.ts
(function(){
    const a:number = 1
})
</pre>
或者添加一个exprot，这样变量就变成模块的局部成员了
<pre>
a.ts
const a:string = 'foo'
b.ts
const a:number = 1
exports{}
</pre>
28.TypeScript Object类型
ts中的Object泛指所有非原始类型，对象、数组、函数
<pre>
export{}//确保与其他示例没有成员冲突
const foo:object = function(){}//[]//{}
const obj:{foo:string,bar:number}={foo:'123',bar:456}//必须一一对应，最好用接口类型
</pre>
29.TypeScript 数组类型
<pre>
export {} // 确保跟其它示例没有成员冲突
// 数组类型的两种表示方式
const arr1: Array< number > = [1, 2, 3]
const arr2: number[] = [1, 2, 3]
// 案例 -----------------------
// 如果是 JS，需要判断是不是每个成员都是数字
// 使用 TS，类型有保障，不用添加类型判断
function sum (...args: number[]) {
  return args.reduce((prev, current) => prev + current, 0)
}
sum(1, 2, 3) // => 6
sum(1,2,3,'p')//报错
</pre>
30.TypeScript 元组类型
元组就是一种特殊的数据结构，明确元素数量和元素类型的数组，各个元素的类型不必要完全相同。在ts中可以使用类似数组字面量来定义元组的类型
<pre>
const tuple: [number, string] = [18, 'zce']
// const age = tuple[0]
// const name = tuple[1]
const [age, name] = tuple
// ---------------------
const entries: [string, number][] = Object.entries({
  foo: 123,
  bar: 456
})
const [key, value] = entries[0]
// key => foo, value => 123
</pre>
31.TypeScript 枚举类型
枚举类型有两个特点：(1)可以给一组数值取一个更好理解的名字(2)一个枚举中只会存在固定的值，并不会有超出范围的可能性
在传统语言中枚举是很常见的数据结构，但是在JavaScript中并没有这种数据结构，很多时候都是使用一个对象模拟枚举
<pre>
// 用对象模拟枚举
const PostStatus = {
  Draft: 0,
  Unpublished: 1,
  Published: 2
}
// 标准的数字枚举
enum PostStatus {
  Draft = 0,//枚举类型的值可以不用等号去指定
  Unpublished = 1,//如果不指定值，默认枚举中的值从0开始累加
  Published = 2
}
const post = {
  title: 'Hello TypeScript',
  content: 'TypeScript is a typed superset of JavaScript.',
  status: PostStatus.Draft // 3 // 1 // 0 //使用枚举 枚举名称.成员名称
}
// 字符串枚举
enum PostStatus {
  Draft = 'aaa',//字符串不能自增，所以必须指定每个值
  Unpublished = 'bbb',
  Published = 'ccc'
}
</pre>
枚举类型会入侵到我们运行时代码——会影响我们编译后的结果。我们在ts中使用的大多数类型都会在编译完成后移除掉，因为它只是我们在编译过程中做的类型检查。而枚举会编译为一个双向的键值对对象(双向键值对->可以通过键获取值，也可以通过值获取键)。我们可以试着编译一下我们刚才写的代码
<pre></pre>
32.TypeScript 函数类型
函数的类型约束，无外乎就是对函数的输入输出进行类型限制，输入就是参数，输出就是返回值。不过在js中有两种函数定义的方式，分别是函数声明和函数表达式。
<pre>
function func1(a:number,b:number):string{
    return 'func1'
}
function func2(a:number,b?:number):string{//?参数是可选的
    return 'func2'
}
function func3(a:number,b:number = 1):string{//设置参数默认值
    return 'func3'
}
//可选参数、默认值都要设置在最后一个参数
function func4(a:number,b:number,...rest:number[]):string{//任意个数的参数
    return 'func4'
}
const func5: (a: number, b: number) => string = function (a: number, b: number): string {
  return 'func5'
}
</pre>
33.TypeScript 任意类型
<pre>
function stringify (value: any) {
  return JSON.stringify(value)
}
stringify('string')
stringify(100)
stringify(true)
let foo: any = 'string'
foo = 100
foo.bar()
// any 类型是不安全的
</pre>
any类型约等于不执行任何类型检查
34.TypeScript 隐式类型推断
在ts中如果一个变量没有通过类型注解标记一个变量的类型，ts会通过变量使用情况推断变量的类型——隐式类型推断
<pre>
let age = 18 // 被推断为number类型
// age = 'string'//再把number类型赋值为字符串类型会被报错
let foo//定义的时候没有标记类型注解，ts推断为any类型
foo = 100
foo = 'string'
</pre>
建议为每个变量添加明确的类型标注，后期可以更直观的了解代码
35.TypeScript 类型断言
<pre>
// 假定这个 nums 来自一个明确的接口
const nums = [110, 120, 119, 112]
const res = nums.find(i => i > 0)//这里我们能明确，一定会有大于0的值，但是ts不明确，它会以为有可能返回的是undefined
//const square = res * res//使用的时候不能确定是数字，于是我们断言一定会是数字的
const num1 = res as number //这里是一种断言方式
const num2 = <number>res //另外一种断言方式 // JSX 下不能使用
</number></pre>
这里要明确，类型断言不等于类型转换，并不是把一个类型转换成另外一个类型，类型转换是代码在运行时的一个概念，类型断言是编译过程中的一个概念，在编译过后，类型断言就不会存在了，有本质上的差异
36.TypeScript 接口
理解成一种规范、契约，约定一个对象的结构，去使用一个接口就一定要去遵循这个接口全部的约定。接口最直观的体现就是约定对象中有哪些成员，这些成员的类型是什么样的
<pre>
interface Post {
  title: string
  content: string
}
function printPost (post: Post) {
  console.log(post.title)
  console.log(post.content)
}
printPost({
  title: 'Hello TypeScript',
  content: 'A javascript superset'
})
</pre>
接口就是用来约束对象的结构，一个对象要实现一个接口就要拥有这个对象中所有的成员。如果我们编译一下这个代码会发现编译后的js文件中并没有任何与接口有关的痕迹，ts中的接口只是为我们有结构的数据进行类型约束，在实际运行中没有太大的意义
37.TypeScript 接口补充
<pre>
interface Post {
  title: string
  content: string
  subtitle?: string//可选成员
  readonly summary: string//只读成员
}
const hello: Post = {
  title: 'Hello TypeScript',
  content: 'A javascript superset',
  summary: 'A javascript'
}
hello.summary = 'other'//只读成员初始化完成修改之后再修改会报错
interface Cache {
  [prop: string]: string//动态成员，prop这个不是固定的名字，可以按需求自己设置
}
const cache: Cache = {}
cache.foo = 'value1'
cache.bar = 'value2'
</pre>
38.TypeScript 类的基本使用
类-描述一类具体事物的抽象特征，用来描述一类具体对象的抽象成员。ES6以前，js通过函数+原型模拟实现类，ES6开始有了专门的class。TypeScript增强了class的相关语法
<pre>
class Person {
  name: string // = 'init name'
  age: number  //在下面赋值之前要先定义
  constructor (name: string, age: number) {
    this.name = name
    this.age = age
  }
  sayHi (msg: string): void {
    console.log(`I am ${this.name}, ${msg}`)
  }
}
</pre>
39.TypeScript 类的访问修饰符
<pre>
class Person {
  public name: string // = 'init name'
  private age: number
  protected gender: boolean
  constructor (name: string, age: number) {
    this.name = name
    this.age = age
    this.gender = true
  }
  sayHi (msg: string): void {
    console.log(`I am ${this.name}, ${msg}`)
    console.log(this.age)
  }
}
class Student extends Person {
  private constructor (name: string, age: number) {
    super(name, age)
    console.log(this.gender)
  }
  //private只能在类内被访问，所以定义静态方法在类内实例化
  static create (name: string, age: number) {
    return new Student(name, age)
  }
}
const tom = new Person('tom', 18)
console.log(tom.name)
// console.log(tom.age)
// console.log(tom.gender)
const jack = Student.create('jack', 18)
</pre>
40.TypeScript 类的只读属性
<pre>
class Person {
  public name: string // = 'init name'
  private age: number
  // 只读成员
  protected readonly gender: boolean
  constructor (name: string, age: number) {
    this.name = name
    this.age = age
    this.gender = true
  }
  sayHi (msg: string): void {
    console.log(`I am ${this.name}, ${msg}`)
    console.log(this.age)
  }
}
const tom = new Person('tom', 18)
console.log(tom.name)
// tom.gender = false//只读属性只能赋值一次，并且赋值之后不能再修改
</pre>
41.TypeScript 类与接口
<pre>
//其实Eat与Run两个接口可以合并成一个接口，但是简单细化更好
interface Eat {
  eat (food: string): void
}
interface Run {
  run (distance: number): void
}
class Person implements Eat, Run {
  eat (food: string): void {
    console.log(`优雅的进餐: ${food}`)
  }

  run (distance: number) {
    console.log(`直立行走: ${distance}`)
  }
}
class Animal implements Eat, Run {
  eat (food: string): void {
    console.log(`呼噜呼噜的吃: ${food}`)
  }

  run (distance: number) {
    console.log(`爬行: ${distance}`)
  }
}
</pre>
42.TypeScript 抽象类
抽象类与接口有点像，都是约束子类中必须有某一个成员，区别在于抽象类可以包含一些具体实现，但是接口只能是成员的抽象，不能包含具体的实现。
<pre>
//抽象类 抽象类只能被继承，不能被new
abstract class Animal {
  eat (food: string): void {
    console.log(`呼噜呼噜的吃: ${food}`)
  }
  //抽象方法，不需要方法体 父类如果有抽象方法，子类必须实现这个抽象方法
  abstract run (distance: number): void
}
//继承抽象类
class Dog extends Animal {
  run(distance: number): void {
    console.log('四脚爬行', distance)
  }

}
const d = new Dog()
d.eat('嗯西马')
d.run(100)
</pre>
43.TypeScript 泛型
在定义函数、接口、类的时候没有指定具体的类型，等到使用的时候再具体指定一个类型。泛型就是声明函数的时候不去指定具体的类型，等到调用的时候再传递具体的类型，为了最大程度复用代码
<pre>
function createNumberArray (length: number, value: number): number[] {
  //由于Array对象默认创建的是any类型的数组，需要指定一下元素类型，这里通过泛型参数传递一个类型
  //这里Array是一个泛型类，在ts中定义这个类的时候并不知道我们会用它存放什么样类型的数据，所以使用泛型参数，再调用的时候再传递一个具体类型
  const arr = Array< number >(length).fill(value)
  return arr
}
const res = createNumberArray(3, 100)
res => [100, 100, 100
</pre>
上面我们定义了一个数字数组，如果我们又需要一个字符串数组，难道要再定义一个？
<pre>
function createStringArray (length: number, value: string): string[] {
  const arr = Array< string >(length).fill(value)
  return arr
}
</pre>
这么做有点傻，更好的方法是使用泛型
<pre>
function createArray< T > (length: number, value: T): T[] {
  const arr = Array< T >(length).fill(value)
  return arr
}
const res = createArray< string >(3, 'foo')
</pre>
44.TypeScript 类型声明
我们经常在使用npm安装一些第三方模块的时候不一定是ts编写的，这个时候可以用类型声明，即一个成员在定义的时候没有明确的类型声明，我们在使用的时候可以定义一个类型声明
<pre>
import { camelCase } from 'lodash' //假设lodash没有ts版本的声明模块
declare function camelCase (input: string): string
const res = camelCase('hello typed')
</pre>
如果有ts声明模块我们可以安装ts模块，比如lodash有types声明文件 @types/lodash，我们可以在开发环境安装声明文件，因为不会提供具体代码，只是提供类型声明。而query-string模块有类型声明文件，我们可以直接使用
<pre>
import qs from 'query-string'
qs.parse('?key=value&key2=value2')
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/26/拉勾-TypeScript语言/" data-id="ckeeij38n005kjoxqttxz43uj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-ECMAScript新特性" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/拉勾-ECMAScript新特性/" class="article-date">
  <time datetime="2020-06-21T10:12:12.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/拉勾-ECMAScript新特性/">拉勾-ECMAScript新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.课程介绍<br>这里主要是对本章节课程简单概述，就不详细记录了<br>2.ECMAScript概述<br>ECMAScript也是一门脚本语言，通常缩写为es，通常看作JavaScript的标准化规范。实际上JavaScript是ECMAScript的扩展语言。 ECMAScript只提供了最基本的语法，也就说约定了代码该如何编写，例如该怎么定义变量和函数以及分支、循环之类的语句。JavaScript实现了ECMAScript的语言标准并且在这个基础之上实现了一些扩展，使得我们可以在浏览器环境中操作DOM和BOM，在node环境中可以做读写文件之类的操作。总之，浏览器环境中的JavaScript就是ECMAScript和webAPI(也就是我们所说的DOM和BOM)。在node环境中的JavaScript就是ECMAScript和node环境提供的API(fs,net…)。JavaScript语言本身指的就是ECMAScript。从2015年ECMAScript就保持着每年一个大版本的迭代，导致JavaScript这门语言本身变得越来越高级，越来越便捷。下图是目前为止所有ECMAScript的标准名称和版本号、发行时间<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/2_1.png"><br>其中ES2015是一个比较重要的点，也是从2015开始按照年份命名，由于一下子没适应从之前的版本号命名变成年份命名，所以ES2015也被称为ES6。<br>3.ES2015概述<br>ES2015也可以叫做ES6，可以说是新时代ECMAScript标准的代表版本——相比上一个版本变化比较大，自此命名规则发生变化。有人喜欢用ES6泛指ES6之后所有的新标准，例如有人说使用ES6之中的async/await，但是实际上async/await是ES2017中制定的新标准。所以需要注意分辨资料中的ES6是特指还是泛指。如果可以，建议阅读ES2015完整语言规格文件，因为包含了新特性/新特性之后的所有语言标准规范。这是链接<a href="https://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">https://www.ecma-international.org/ecma-262/6.0/</a><br>本章节主要介绍ES5.1基础之上的变化，并且主要介绍一些变化大/值得我们单独了解的新特性。主要归为4类:<br>·解决原有语法上的一些问题/不足(如let、const的块级作用域)<br>·对原有语法进行增强(如解构、默认值)<br>·全新的对象/全新的方法/全新的功能(promise、proxy等)<br>·全新的数据类型/数据结构(symbol/set等)<br>4.ES2015准备工作<br>可以使用node环境，也可以使用最新版本的chrome浏览器，老师用的node版本为12.13.0。同时还需要nodemon的小工具，修改完代码后自动执行<br>5.ES2015 let与块级作用域<br>作用域-代码中某个成员能够起作用的范围，在ES2015之前，es只有两种类型的作用域，分别是<br>·全局作用域<br>·函数作用域<br>在ES2015中新增了一个<br>·块级作用域<br>块——在代码中用花括号包裹起来的范围。以前块没有独立作用域</p>
<pre>
for(var i=0; i < 3; i++){
    for(var i=0; i < 3; i++){
        console.log(i)
    }
    console.log('内层结束 i = '+i)
}
</pre>
执行结果
//0
//1
//2
//内层结束 i = 3
造成以上执行结果的原因是:外层声明了i过后，内层再次声明了这个变量，而且都是使用var去声明变量的，也就是说并不是一个块级作用域内的成员，而是全局成员，那么内层声明i就会覆盖掉之前声明的i，内层循环结束后，i=3，那么外层拿到的i也就是i=3，不满足外层循环的条件，自然就不会循环了。如果把var换成let，那么就能解决我们遇到的这个问题，因为let有块级作用域。但是我们这里不鼓励这种同名变量，对于以后程序的理解有很大麻烦。
在我们循环注册事件时，在事件的处理函数中，要访问循环的计数器，这种情况下，以前机会出现一些问题
<pre>
var elements = [{},{},{}]
for(var i=0; i < elements.length;i++){
    elements[i].onclick = function(){
        console.log(i)//获取的是外层的i，在执行完后，无论从哪里调用，i的值都已经是3了
    }
}
elements[0].onclick()//3
elements[1].onclick()//3
elements[2].onclick()//3
</pre>
通过闭包解决这个问题——借助函数作用域摆脱全局作用域所产生的影响
<pre>
var elements = [{},{},{}]
for(var i=0; i < elements.length;i++){
    elements[i].onclick = (function(){
        console.log(i)
    })(i)
}
elements[0].onclick()//0
elements[1].onclick()//1
elements[2].onclick()//2
</pre>
借助let的块级作用域解决问题
<pre>
var elements = [{},{},{}]
for(let i=0; i < elements.length;i++){
    elements[i].onclick = function(){
        console.log(i)
    }
}
elements[0].onclick()//0
elements[1].onclick()//1
elements[2].onclick()//2
</pre>
其实在上面代码中本质也是闭包的机制， onclick执行的时候，循环已经结束，实际的i已经被销毁了，通过闭包的机制才能拿到相应的i
<pre>
for(let i=0; i < elements.length;i++){
    let i = 'foo'
    console.log(i)//得到三次foo
}
</pre>
上面代码表明两个i没有相互影响，没有在同一个作用域当中。如果这样不好理解，那我们把上面的代码拆解开，用if的方式去演示
<pre>
let i = 0;
if(i < 3){

    let i = 'foo'
    console.log(i)
}
i++
if(i < 3){
    let i = 'foo'
    console.log(i)
}
i++
if(i < 3){
    let i = 'foo'
    console.log(i)
}
i++
</pre>
上面代码模拟了循环的完整过程
另外let不会像var一样发生变量提升的情况，至于为什么不继续用var升级而改用let，主要是考虑到很多项目如果这样升级势必造成影响。
6.ES2015 const
定义一个恒量/常量，在let的基础上多了一个"只读"特性，即变量声明之后不可以再修改
<pre>
const name = "zce"
name = "jack"//报错
</pre>
声明的同时要赋值
<pre>
const name
name = "zce"//报错
</pre>
其实这里说的声明的成员不能被修改，指的是不允许在声明过后重新指向一个内存地址，并不是说不允许修改恒量中的成员
<pre>
const obj = {}
obj.name = "zce"//不报错，没有修改obj指向的内存地址，修改了内存地址空间的数据
obj = {}//报错，因为重新为obj指了一个新的地址
</pre>
老师的个人最佳实践是不用var(比如先使用后定义并不是一个好的编程习惯)，主要用const(更明确代码中的成员是否会被修改)，配合let定义必须要修改的值
7.ES2015数组的解构
<pre>
const arr = [100,200,300]
const [foo,bar,baz] = arr
console.log(foo,bar,baz) //100,200,300
//或者如果只想获取第三个成员
const [,,baz] = arr // 300
//提取从当前位置往后的所有成员
const [foo,...rest] = arr //...rest的用法只能在最后一个位置使用
console.log(rest) //[200,300]
//解构成员数组长度小于被解构数组长度，会从前到后提取
const [foo,bar] = arr
console.log(foo,bar); //100,200
//如果解构成员长度大于数组长度，提取到的是undefined
const [foo,bar,baz,more] = arr
console.log(more)//undefined
//如果需要给提取到的下标设置默认值
const [foo,bar,baz,more = 'defalut value'] = arr
console.log(bar,more)//200"defalut value"
</pre>
举例用到解构的好处
<pre>
const path = "/foo/bar/baz";
//const tmp = path.split('/');
//const rootdir = tmp[1]//这种方案需要多用到一个中间变量
const [,rootdir] = path.split('/')
console.log(rootdir)
</pre>
8.ES2015对象的解构
对象的解构和数组的解构很相似，不同之处在于对象没有下标，我们通过变量解构
<pre>
const obj = { name:'zce',age:18}
const { name } = obj
console.log(name)
const { age } = obj
console.log(age)
</pre>
没有匹配到的成员值为undefined，也可以设置默认值。在对象中我们解构的变量名同时用来匹配被解构对象当中的属性名，所以如果当前作用域中有同名的成员就会产生冲突
<pre>
const obj = { name:'zce',age:18}
const name = 'tom'
const { name } = obj
console.log(name)//报错
</pre>
解决的方式是重命名
<pre>
const obj = { name:'zce',age:18}
const name = 'tom'
const { name:objName = 'jace' } = obj//jack为设置默认值
console.log(objName)//zce
</pre>
应用场景的例子
<pre>
const { log } = console
log('foo')
log('bar')
</pre>
简化了代码的编写，减小了代码整体的体积
9.ES2015模版字符串
<pre>
const str = `hello es2015,this is a \`string\``
console.log(str)//hello es2015,this is a `string`
const str1 = `hello es2015,
this is a \`string\``//支持换行
const name = 'tom' 
//${可以嵌入任何标准的js语句}，例如变量
const msg = `hey,${name}---${1+2}---${Math.random()}`//hey,tom---3---0.2061239309540519
</pre>
10.ES2015带标签的模版字符串
<pre>
const str = tag`hello world`//tag是一个标签，是一个特殊的模版字符串函数，这里没有tag这个函数，所以这里会报错
const str1 = console.log`hello world`//console.log作为模版字符串的标签//['hello','world']
</pre>
为什么打印的是数组呢？我们一步步探寻
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings){
    console.log(strings)
}
const result = myTagFunc`hey,${name} is a ${gender}`
</pre>
<img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/10_1.png">
上面打印的数组就是我们模版字符串内容分割过后的结果，模版字符串中可能有嵌入的表达式，所以数组就是按照表达式分割过后的静态内容，所以是数组。除了数组以外，这个函数还可以接收所以在模版字符串中出现的函数表达式的返回值。
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    console.log(strings,name,gender)
}
const result = myTagFunc`hey,${name} is a ${gender}`//["hey,", " is a ", "", raw: Array(3)] "tom" true
</pre>
函数的返回值就是带标签的模版字符串对应的返回值
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    //console.log(strings,name,gender)
    return '123'
}
const result = myTagFunc`hey,${name} is a ${gender}`//123
</pre>
如果想返回正常的返回值
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    return strings[0]+name+strings[1]+gender+strings[2]
}
const result = myTagFunc`hey,${name} is a ${gender}`
console.log(result)//hey,tom is a true
</pre>
标签函数的作用就是对模版字符串进行加工
<pre>
const name = 'tom'
const gender = true
function myTagFunc(strings,name,gender){
    const sex = gender ? 'man' : 'woman'
    return strings[0]+name+strings[1]+sex+strings[2]
}
const result = myTagFunc`hey,${name} is a ${gender}`
console.log(result)//hey,tom is a man
</pre>
11.ES2015字符串的扩展方法
·includes()
·startsWith()
·endsWith()
<pre>
const message = 'Error:foo is not defined.'
console.log(message.startsWith('Error'))//true
console.log(message.endsWith('.'))//true
console.log(message.includes('foo'))//true
</pre>
12.ES2015参数默认值
过去是通过逻辑参数来设置默认值
<pre>
function foo(enable){
    enable = enable || true
    console.log('foo invoked - enable:')
    console.log(enable)
}
foo(true)
//foo invoked - enable:
//true
</pre>
但是上面代码有个问题，就是如果传入的是false，会引起错误，所以我们不要使用短路设置默认值
<pre>
function foo(enable){
    enable = enable === undefined ? true : enable
    console.log('foo invoked - enable:')
    console.log(enable)
}
foo(true)
//foo invoked - enable:
//true
</pre>
而有了参数默认值新功能过后，这一切都会变得简单的多
<pre>
function foo(enable = true){
    console.log('foo invoked - enable:')
    console.log(enable)
}
foo(false)
//foo invoked - enable:
//false
</pre>
如果有多个参数，那么带有默认值的参数一定要放在参数列表的最后，因为参数是按照次序传递的，如果有参数的默认值不在最后面的话，默认值将无法正常工作
13.ES2015剩余参数
<pre>
function foo(...args){
    console.log(args)
}
foo(1,2,3,4 )//[1, 2, 3, 4]
</pre>
因为接收的是剩余的所有参数，所以只能出现在参数列表的最后一位，且只能出现一次
14.ES2015展开数组
把数组当中的每一个成员按照次序传递
<pre>
const arr = ['foo','bar','baz'];
console.log(...arr)//foo bar baz
</pre>
15.ES2015箭头函数
<pre>
const inc = n => n+1
console.log(inc(100))
</pre>
对比一下普通函数，会发现箭头函数使我们的代码更简短更易读
<pre>
const arr = [1,2,3,4,5,6,7]
arr.filter(function(item){
    return itme % 2
})
arr.filter(item => item % 2 )
</pre>
16.ES2015箭头函数与this
箭头函数不会改变this的指向
<pre>
const person = {
    name : 'tom',
    sayHi : function(){
        console.log(`hi, my name is ${this.name}`)
    }
}
person.sayHi()//hi, my name is tom
</pre>
对比上面的代码，我们把sayHi方法改变为箭头函数
<pre>
const person = {
    name : 'tom',
    sayHi : () => {
        console.log(`hi, my name is ${this.name}`)
    }
}
person.sayHi()//hi, my name is undefined
</pre>
这种特性可以解决一些问题
<pre>
const person = {
    name : 'tom',
    sayHi : () => {
        console.log(`hi, my name is ${this.name}`)
    },
    // sayHiAsync:function(){
    //      const _this = this //我们要拿到this的指向
    //     setTimeout(function(){
    //         console.log(_this.name)
    //     },1000)
    // }//这里是ES5的方法
    sayHiAsync:function(){
        setTimeout(() => {
            console.log(_this.name)
        })
    }
}
person.sayHiAsync()
</pre>
17.ES2015对象字面量的增强
<pre>
const bar = '123'
const obj = {
    foo:123,
    // bar:bar,//传统方式
    bar,
    // method:function(){
        // console.log('method111')
    // }//传统方式
    method(){
        console.log('method111')
        console.log(this)
    },
    //ES2015动态添加变量属性的方法
    [Math.random()]:123,//计算属性名，表达式的执行结果作为属性的属性名
}
console.log(obj)//{foo: 123, bar: "123", method: ƒ}
console.log(obj.method())//{foo: 123, bar: "123", method: ƒ}
obj[Math.random()] = 123//过去动态添加变量属性的方法 
</pre>
18.ES2015 Object.assign
将多个源对象的属性复制到一个目标对象中，如果对象中有相同的属性，源对象中的属性会覆盖掉目标对象中的属性(从源对象中取，往目标对象中放)
<pre>
const source1 = {
    a:123,
    b:123
}
const target = {
    a:456,
    c:456
}
const result = Object.assign(target,source1)
// console.log(result)//{a: 123, c: 456, b: 123}
// console.log(target)//{a: 123, c: 456, b: 123}
// console.log(result === target)//true
const source2 = {
    b:789,
    d:789
}
const result = Object.assign(target,source1,source2)
console.log(result)//{a: 123, c: 456, b: 789, d: 789}
console.log(target)//{a: 123, c: 456, b: 789, d: 789}
console.log(result === target)//true
</pre>
本质就是用源对象中的属性覆盖目标对象中的属性，用法举例
<pre>
function func(obj){
    obj.name = 'func obj'
    console.log(obj)//{name: "func obj"}
}
const obj = { name : "global obj"}
func(obj)
console.log(obj)//{name: "func obj"}
</pre>
在上面代码中如果在函数内部直接修改对象参数的属性，外界对应的对象也会发生变化，如果只想在函数内部修改属性
<pre>
function func(obj){
    const funcObj = Object.assign({},obj)
    funcObj.name = 'func obj'
    console.log(funcObj)//{name: "func obj"}
}
const obj = { name : "global obj"}
func(obj)
console.log(obj)//{name: "global obj"}
</pre>
19.ES2015 Object.is
<pre>
console.log(
// 0 === false //false
// 0 == false  //true
// NaN === NaN //false,过去认为NaN是一种无限可能的值，所以认为两个NaN不相等
// +0 === -0   //true
//针对NaN!==NaN和+0===-0两种不符合我们日常需求的运算，我们可以用Object.is
// Object.is(NaN,NaN) //true
Object.is(+0,-0) //false
)
</pre>
虽然Object.is在一些地方很好用，但是日常开发还是建议使用===和==运算符
20.ES2015 Proxy
如果我们要监视某个对象的读写，我们需要Object.defineProperty这样的方法来为我们的对象添加属性，这样我们就能捕获对象属性的读写过程。这样的方法使用的非常广泛，比如vue3.0之前就是使用的这样的方法完成双向数据绑定。在ES2015中设计了Proxy类型，为对象设置访问代理器的。相对于Object.defineProperty，proxy功能更为强大使用起来也更为方便。
<pre>
const person = {
    name:'zce',
    age:20
}
const personProxy = new Proxy(person,{
    get(target,prototype){
        console.log(target,prototype);//{name: "zce", age: 20} "name"
        return 100
    },
    set(){}
})
console.log(personProxy.name) //100
</pre>

<pre>
const person = {
    name:'zce',
    age:20
}
const personProxy = new Proxy(person,{
    get(target,prototype){
        return prototype in target ? target[prototype] : 'default'
    },
    set(){}
})
console.log(personProxy.name) //zce
console.log(personProxy.xxx) //default
</pre>

<pre>
const person = {
    name:'zce',
    age:20
}
const personProxy = new Proxy(person,{
    get(target,prototype){
        return prototype in target ? target[prototype] : 'default'
    },
    set(target, prototype, value){
        console.log(target, prototype, value)//{name: "zce", age: 20} "gender" true
    }
})
personProxy.gender = true
</pre>

<p><pre><br>const person = {<br>    name:’zce’,<br>    age:20<br>}<br>const personProxy = new Proxy(person,{<br>    get(target,prototype){<br>        return prototype in target ? target[prototype] : ‘default’<br>    },<br>    set(target, prototype, value){<br>        if(prototype === ‘age’){<br>            if(!Number.isInteger(value)){<br>                throw new TypeError(<code>${value} is not an int</code>)<br>            }<br>        }<br>        target[prototype] = value<br>    }<br>})<br>personProxy.age = ‘aaa’//报错 aaa is not an int<br>personProxy.gender = true<br></pre><br>21.ES2015 Proxy对比defineProperty<br>21-1.Object.defineProperty只能监视到对象属性的读写，proxy能监视到更多对象操作：比如proxy可以监视到delete操作或对对象中方法的调用等</p>
<p><pre><br>const person = {<br>    name:’zce’,<br>    age:20<br>}<br>const personProxy = new Proxy(person,{<br>    deleteProperty(target,prototype){<br>        console.log(‘delete’,prototype);//delete age<br>        delete target[prototype]<br>    }<br>})<br>delete personProxy.age<br>console.log(person)//{name: “zce”}<br></pre><br>下图列举了proxy可以监视的对象的操作<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/21_1.png"><br>21-2.Proxy更好的支持数组对象的监视<br>以往通过Object.defineProperty监视数组的操作往往通过重写数组的操作方法来实现(通过自定义的方法覆盖掉数组原型上的操作)</p>
<p><pre><br>const list = []<br>const listProxy = new Proxy(list,{<br>    set(target, prototype, value){<br>        console.log(‘set’,prototype,value)<br>        target[prototype] = value<br>        return true//表示设置成功<br>    }<br>})<br>listProxy.push(100)<br>//set 0 100<br>//set length 1<br></pre><br>21-3.Proxy是以非侵入的方式监管了对象的读写<br>对一个已经定义好的对象，不需要对对象本身进行任何操作就可以监视到它内部成员的读写，而Object.defineProperty需要我们通过特定的方式单独去定义对象中的需要被监视的属性，对已经存在的对象，我们需要做很多额外的操作</p>
<p><pre><br>const person = {}<br>Object.defineProperty(person,’name’,{<br>    get(){<br>        console.log(‘name 被访问’)<br>        return person._name<br>    },<br>    set(value){<br>        console.log(‘name 被设置’)<br>        person._name = value<br>    }<br>})<br>Object.defineProperty(person,’age’,{<br>    get(){<br>        console.log(‘age 被访问’)<br>        return person._age<br>    },<br>    set(value){<br>        console.log(‘age 被设置’)<br>        person._age = value<br>    }<br>})<br>person.name = ‘jack’<br>console.log(person.name)<br></pre><br>22.ES2015 Reflect<br>统一的对象操作，是一个静态类，也就是说不能通过new去实例化一个对象，只能调用静态类中的一些静态方法(例如Reflect.get())。Relect内部封装了一系列对对象底层的操作，一共13个(定义了14个，但是其中一个已经废弃掉了)，仔细看这13个方法的方法名与Proxy对象中的处理对象方法成员是一致的，相当于是Proxy处理对象方法的默认实现，如果觉得这句话不好理解，可以通过下面的例子理解。</p>
<p><pre><br>const obj = {<br>    foo:’123’,<br>    bar:’456’<br>}<br>const proxy = new Proxy(obj,{<br>    get(target,property){<br>        console.log(‘watch logic~’)<br>        return Reflect.get(target,property)<br>    }<br>})<br>console.log(proxy.foo)//123<br></pre><br>Reflect的主要意义在于提供了一套统一的用于操作对象的API</p>
<p><pre><br>const obj = {<br>    foo:’123’,<br>    bar:’456’<br>}<br>//console.log(‘name’ in obj)//传统判断对象属性是否存在<br>//console.log(delete obj[‘age’])//传统删除对象属性<br>//console.log(Object.keys(obj))//传统遍历对象属性<br>console.log(Reflect.has(obj,’name’))//判断对象属性是否存在<br>console.log(Reflect.deleteProperty(obj,’age’))//删除对象属性<br>console.log(Reflect.ownKeys(obj))//获取对象中所有属性名<br></pre><br>23.ES2015 Promise<br>一种更优的异步编程解决方案，解决了传统异步编程中回调函数嵌套过深的问题<br>24.ES2015 class类<br>从前定义一个类，我们要通过函数、原型去实现</p>
<p><pre><br>function Person(name){<br>    this.name = name<br>}<br>Person.prototype.say = function(){<br>    console.log(<code>hi, my name is ${this.name}</code>)<br>}<br></pre><br>现在我们用class去实现</p>
<p><pre><br>class Person{<br>    constructor(name){<br>        this.name = name<br>    }<br>    say(){<br>        console.log(<code>hi, my name is ${this.name}</code>)<br>    }<br>}<br>const p = new Person(‘tom’)<br>p.say()<br></pre><br>25.ES2015静态方法<br>在类中通常有实例方法和静态方法，实例方法就是通过构造的实例对象去调用，静态方法是通过类型本身去调用。以前实现静态方法就是在构造函数对象去挂载方法来实现，因为在js中函数也是对象，可以添加一些方法成员。ES2015中新增添加静态成员的static关键词</p>
<p><pre><br>class Person{<br>    constructor(name){<br>        this.name = name<br>    }<br>    say(){<br>        console.log(<code>hi, my name is ${this.name}</code>)<br>    }<br>    static create(name){<br>        return new Person(name)<br>    }<br>}<br>const tom = Person.create(‘tom’)<br>tom.say()//hi, my name is tom<br></pre><br>因为静态方法是在当前类中定义的，所以在静态方法内部，this不会指向某一个实例对象而是当前的类型<br>26.ES2015 类的继承<br>通过继承的特性我们就能抽象出来相似的类型之间重复的地方，在ES2015之前大多数情况我们都会通过原型的方式实现继承，在ES2015专门出现了用于继承的关键词extends</p>
<p><pre><br>class Person{<br>    constructor(name){<br>        this.name = name<br>    }<br>    say(){<br>        console.log(<code>hi, my name is ${this.name}</code>)<br>    }<br>}<br>class Student extends Person{<br>    constructor(name,number){<br>        super(name)<br>        this.number = number<br>    }<br>    hello(){<br>        super.say()<br>        console.log(<code>my school number is ${this.number}</code>)<br>    }<br>}<br>const s = new Student(‘jack’,100)<br>s.hello()<br>//hi, my name is jack<br>//my school number is 100<br></pre><br>extends继承比原型继承更方便更清楚一些<br>27.ES2015 Set<br>ES2015提供的全新的数据结构，可以把它理解为集合，与传统的数组非常类似，不过set内部的成员不允许重复，也就是说每一个值在同一个set内部是唯一的。它是一个类型，我们通过用这个类型构造的实例就能用来存放不重复的数据，可以通过集合的add方法往集合中添加数据。由于add方法可以返回集合对象本身，我们可以链式调用，如果我们用add添加了之前已经存在的值，那么这个值就会被忽略掉。想要遍历集合当中的数据，我们可以用forEach方法，也可以通过for…of…。可以通过size属性获取整个集合的长度</p>
<p><pre><br>const s = new Set()<br>s.add(1).add(2).add(3).add(4).add(2)<br>console.log(s)//Set {1,2,3,4}<br>s.forEach(i =&gt; console.log(i))<br>//1<br>//2<br>//3<br>//4<br>for(let i of s){<br>    console.log(i)<br>}<br>//1<br>//2<br>//3<br>//4<br>console.log(s.size)//4<br>console.log(s.has(100))//false，判断集合中是否存在某个特定的值<br>console.log(s.delete(3))//删除集合中某个指定的值，删除成功的话返回true<br>s.clear()//清楚当前集合中全部的内容<br>console.log(s)//Set {}<br></pre><br>最常见的应用场景就是为数组中的元素去重</p>
<p><pre><br>const arr = [1,2,1,3,1,4]<br>const result = new Set(arr)<br>console.log(result)//Set { 1, 2, 3, 4 }<br>//可以用Array.from/[…展开]把Set再次转化成数组<br>const result1 = Array.from(new Set(arr))//[ 1, 2, 3, 4 ]<br>const result2 = […new Set(arr)]//[ 1, 2, 3, 4 ]<br></pre><br>28.ES2015 Map<br>与对象非常相似，本质上都是键值对的集合，但是对象中的键只能是字符串类型，所以说存放复杂数据结构时会有一些问题。有人说我也可以用其他类型的数据做为对象的键，这里我们一起来尝试一下</p>
<p><pre><br>const obj={}<br>obj[true] = ‘value’<br>obj[123] = ‘value’<br>obj[{a:1}] = ‘value’<br>console.log(Object.keys(obj))//[ ‘123’, ‘true’, ‘[object Object]’ ]<br></pre><br>从上面打印结果来看，我们设置的布尔/对象/数字 类型的非字符串类型的键，都被内部toString的结果作为键。看上面的打印结果，我们应该能想到一些问题，设想我们用对象存储学生的考试成绩，假定我们用对象存储每个学生的考试成绩。如果我们用学生对象作为键，那不管每个对象键中的属性有何不同，但是toString的结果都是一样的，就没有办法做到区分</p>
<p><pre><br>console.log(obj[{}])//value<br>console.log(obj[‘[object Object]’])//value<br></pre><br>现在我们明白了问题的所在，Map就是为了解决这样的问题。Map才能算严格意义上的键值对的集合，用来去映射两个任意类型数据之间的关系</p>
<p><pre><br>const m = new Map()<br>const tom = { name:’tom’ }<br>m.set(tom,90)<br>console.log(m)//Map { { name: ‘tom’ } =&gt; 90 }<br>console.log(m.get(tom))//90<br>//m.has()//判断某个键是否存在<br>//m.delete()//删除某个键<br>//m.clear()//清空s所有键值<br>m.forEach((value,key)=&gt;{//遍历<br>    console.log(value,key)<br>})//90 { name: ‘tom’ }<br></pre><br>对象只能用字符串作为键，而Map可以用任意类型数据作为键<br>28.ES2015 Symbol<br>在ES2015之前对象的属性名只能是字符串，字符串是可能会产生冲突的。比如我们设置了全局缓存对象变量cache，而在不同的js文件中我们设置了同一个对象属性，那么就会产生问题，在过去，我们会通过约定来尽量规避这种情况<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/28_1.png"><br>但是约定的方式只是规避了问题，并不是彻底解决问题，ES2015提供了Symbol类型来彻底解决这个问题，作用就是表示一个独一无二的值</p>
<p><pre><br>const s = Symbol()<br>console.log(s)//Symbol()<br>console.log(typeof s)//symbol<br></pre><br>这种类型最大的特点就是独一无二，也就说通过这种方式创建的每一个值都是唯一的，永远不会重复</p>
<p><pre><br>console.log(Symbol() === Symbol())//false<br></pre><br>考虑到在开发过程中的调试，允许我们传入一个字符串作为这个值的描述文本，对于我们多次使用Symbol的情况，就能在控制台中区分出来到底是哪一个对应的Symbol</p>
<p><pre><br>console.log(Symbol(‘foo’))//Symbol(foo)<br>console.log(Symbol(‘bar’))//Symbol(bar)<br>console.log(Symbol(‘baz’))//Symbol(baz)<br></pre><br>从ES2015开始，对象就可以使用Symbol类型的值作为属性名</p>
<p><pre><br>const obj = {}<br>obj[Symbol()] = ‘123’<br>obj[Symbol()] = ‘456’<br>console.log(obj)//{ [Symbol()]: ‘123’, [Symbol()]: ‘456’ }<br>//或者<br>const obj1 = {<br>    [Symbol()]:123<br>}<br>console.log(obj1)//{ [Symbol()]: 123 }<br></pre><br>我们可以通过Symbol的特性来模拟对象的私有成员，假定我们创建了a.js文件</p>
<p><pre><br>//a.js<br>const name = Symbol()<br>const person = {<br>    [name] : ‘zce’,<br>    say(){<br>        console.log(this[name])<br>    }<br>}<br>//b.js<br>//person[Symbol()]//不能访问，因为Symbol成员不能产生完全一样的值<br>person.say()<br></pre><br>在b.js中，我们没有办法再去创建一个完全相同的Symbol，所以无法访问person对象中的Symbol变量的成员，只能访问对象中普通名称的成员。Symbol目前最主要的作用就是为对象添加独一无二的属性名。截止到ES2019，一共定义了6种原始类型和Object数据类型，一共7种数据类型。在未来还会新增一个叫BigInt的原始数据类型，用于去存放更长的数字，目前处于stage-4阶段，预计在下一个版本能正式被标准化，那么ES就是8种数据类型了<br>28.ES2015 Symbol补充<br>Symbol每次生成的都是全新的一个值，如果想去全局复用，可以用全局变量的方式或者使用Symbol类型提供的静态方法，也就是for方法，可以接收一个字符串作为一个参数，相同的字符串一定会返回相同的Symbol类型的值，因为在方法内部维护了一个全局的注册表，为我们的字符串和Symbol提供了一一对应的关系。因为方法内部维护的是字符串与Symbol的关系，也就是说如果我们传入的不是字符串，方法内部会自动转换成字符串，会导致比如传入布尔值的true和传入字符串的true拿到的值是一样的</p>
<p><pre><br>const s1 = Symbol.for(‘foo’)<br>const s2 = Symbol.for(‘foo’)<br>console.log(s1 === s2)//true<br>console.log(Symbol.for(true) === Symbol.for(‘true’))<br></pre><br>Symbol方法中还定义了很多内置的Symbol常量来作为内部方法的标识，可以让一些自定义对象实现js当中内置的一些接口</p>
<p><pre><br>//Symbol.iterator<br>//Symbol.hasInstance<br>const obj = {}<br>console.log(obj.toString())//[object Object]-&gt;我们把这样的字符串叫做对象的toString标签<br>//自定义对象的toString标签，可以在对象中添加一个特定的成员去标识<br>//考虑到使用字符串添加标识可能会跟内部的一些成员产生重复，所以es要求我们使用Symbol实现接口<br>const obj1 = {<br>    [Symbol.toStringTag]:’XObject’<br>}<br>console.log(obj1.toString())//[object XObject]<br>//toStringTag是Symbol内置的一个常量，这种Symbol在后面我们为对象实现迭代器时常用到<br></pre><br>Symbol作为对象的属性名，通过传统的for…in…循环/Object.keys()是无法拿到的，通过JSON.stringify序列化对象为一个字符串，Symbol属性也会被忽略掉，种种特性使得Symbol特别适合作为私有属性</p>
<p><pre><br>const obj = {<br>    [Symbol()]:’symbol value’,<br>    foo:’normal value’<br>}<br>for(var key in obj){<br>    console.log(key)<br>}<br>Object.keys(obj)<br></pre><br>如果想获取Symbol类型的属性名，可以通过Object.getOwnPropertySymbols(obj)。Object.getOwnPropertySymbols类似于Object.keys，所不同的是Object.keys只能获取到字符串类型的属性名，而Object.getOwnPropertySymbols获取到的是Symbol属性名<br>31.ES2015 for…of循环<br>在es中有很多遍历数据的方法，比如for循环适合遍历普通数组，for…in…适合遍历键值对，还有一些函数式的遍历方法，例如forEach方法。但是这些遍历方法都有一些局限性，所以ES2015借鉴其他语言引入了一种新的遍历方法for…of循环，这种遍历方式以后会作为遍历所有数据结构的统一方式。下面先了解for…of循环的基本用法</p>
<p><pre><br>const arr = [100,200,300,400]<br>for(const item of arr){<br>    console.log(item)<br>}<br>//100<br>//200<br>//300<br>//400<br></pre><br>这种循环方式就可以取代我们之前常用的数组循环方式forEach，并且for…of循环可以随时用break关键词终止循环，这一点比forEach表现好，因为forEach循环无法终止遍历</p>
<p><pre><br>const arr = [100,200,300,400]<br>for(const item of arr){<br>    console.log(item)<br>    if(item &gt; 100){<br>        break;<br>    }<br>}<br></pre><br>除了数组可以用for…of循环遍历，一些伪数组对象也是可以用for…of循环遍历的，例如函数中的arguments，DOM节点的列表。这些伪数组对象的遍历和普通数组对象的遍历没有什么区别，这里不再演示。但是一些Set(其实和遍历数组基本一样，拿到的是元素本身)、Map对象，我们还是了解一下吧</p>
<p><pre><br>const s = new Set([‘foo’,’bar’])<br>for(const item of s){<br>    console.log(item)<br>}<br>//foo<br>//bar<br></pre></p>
<p><pre><br>const m = new Map()<br>m.set(‘foo’,’123’)<br>m.set(‘bar’,’345’)<br>for(const item of m){<br>    console.log(item)<br>}<br>//[ ‘foo’, ‘123’ ]//当前被遍历的键和值<br>//[ ‘bar’, ‘345’ ]<br>//配合数组的解构语法，可以直接拿到数组的键和值了<br>for(const [key,value] of m){<br>    console.log(key,value)<br>}<br>//foo 123<br>//bar 345<br></pre><br>上面基本都成功了，但是当我们试图变量普通对象的时候，却报错了</p>
<p><pre><br>const obj = {foo:123,bar:456}<br>for(item of obj){<br>    console.log(item)<br>}<br>//for(item of obj){<br>            ^<br>//TypeError: obj is not iterable<br></pre><br>说好的能遍历所有的数据结构呢？预知原因几何，且听下回分解<br>32.ES2015 可迭代接口<br>上节课说到for…of循环说好的能遍历所有的数据结构，但是居然不能遍历普通对象，这是因为：ES中能够表示有结构的数据类型越来越多，例如数组、对象到ES2015的set、map等，开发者甚至可以组合使用这种类型去定义一些符合自己业务需求的数据结构，为了给各种各样的数据结构提供统一的遍历方式，ES2015提供了一种Iterable的接口，意思就是可迭代的(如果不太理解编程语言当中的接口概念，可以把接口理解为一种规格标准，例如在ES中任意一种数据类型都有toString方法，是因为它们都实现了统一的规格标准。而在编程语言当中更专业的说法是它们都实现了统一的接口)。实现Iterable接口就是for…of的前提。我们可以在浏览器的控制台中查看一下我们之前定义的Map、Set等对象的数据结构<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_1.png"><br>可以看到我们每个可以用for…of循环遍历的数据结构都有Symbol.iterator，在Symbol.iterator中有个next方法，我们调用这个next方法<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_2.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_3.png"><br>我们能看到next方法返回的又是一个对象，当我们多次调用next方法之后可以看到<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/32_4 .png"><br>我们可以想到，在迭代器当中维护了一个数据指针，我们每调用一次next，数据都会往后移一位，而途中done属性的作用就是表示我们 内部的数据是否遍历完了。我们通过尝试，了解了实现iterable接口数据类型的特点。我们来总结一下，所有能实现for…of循环的数据类型都要实现iterable的接口，在内部必须挂载一个iterator的方法，这个iterator的方法需要返回一个带有next方法的对象，我们不断调用next方法就能实现对内部所有数据的遍历。那么我们再反过来看一下Set</p>
<p><pre><br>const s = new Set([‘foo’,’bar’,’baz’])<br>const iterator = s<a href="">Symbol.iterator</a><br>console.log(iterator.next())//{ value: ‘foo’, done: false }<br>console.log(iterator.next())//{ value: ‘bar’, done: false }<br>console.log(iterator.next())//{ value: ‘baz’, done: false }<br>console.log(iterator.next())//{ value: undefined, done: true }<br></pre><br>这就是for…of循环内部的实现原理，其实我们也可以使用while循环实现相同的遍历<br>33.ES2015 实现可迭代接口<br>上节课我们了解了可迭代接口iterable，也就是说如果我们给对象实现iterable接口，那么也可以通过for…of循环去遍历普通对象。在ES中实现iterable实际上就是在对象中挂载iterator方法，在这个方法中返回一个迭代器对象</p>
<p><pre><br>const obj = {<br>    [Symblo.iterator]:function(){//实现了可迭代接口iterable<br>        return {//实现了迭代器接口iterator<br>            next:function(){<br>                return {//迭代结果接口iterationResult<br>                    value:’zce’,//当前被迭代到的数据，值可以是任意类型，本例中为了方便理解，随便赋了一个值<br>                    done:true   //布尔值，表示迭代是否结束<br>                }<br>            }<br>        }<br>    }<br>}<br>//我们试着调用for…of<br>for(const item of obj){<br>    console.log(‘循环体’)<br>}<br></pre><br>我们试着调用for…of循环，发现并没有报错(虽然也没有执行，但是不报错已经是一个好的开始，毕竟我们把done属性设置为true)，那我们在上面代码的基础上进行修改</p>
<p><pre><br>const obj = {<br>    store:[‘foo’,’bar’,’baz’],//对象中添加一个数组，里面放一些值得被遍历的数据<br>    [Symbol.iterator]:function(){//实现了可迭代接口iterable<br>        let index = 0//既然要在next方法中迭代数组，我们就要维护一个下标<br>        const self = this//在next函数中的this并没有指向当前对象，定义self来接收当前的this<br>        return {//实现了迭代器接口iterator<br>            next:function(){<br>                const result =  {//迭代结果接口iterationResult<br>                    value:self.store[index],//当前被迭代到的数据，值可以是任意类型<br>                    done:index &gt;= self.store.length   //布尔值，表示迭代是否结束<br>                }<br>                index++<br>                return result<br>            }<br>        }<br>    }<br>}<br>for(const item of obj){<br>    console.log(‘循环体’,item)<br>}<br>//循环体 foo<br>//循环体 bar<br>//循环体 baz<br></pre><br>虽然我们实现了对象的迭代器，但是好像也没觉得有什么用处，难道实现起来真的没有意义么？<br>34.ES2015 迭代器模式<br>上节课我们实现了对象的迭代器，但是感觉并不是很实用？这节课我们来学习下迭代器模式，看看能不能派上用场。不过不要被这个名字吓到，我们来了解下就知道了。假如我们合作一个任务清单应用，这里老师的任务是设计一个用于存放所有任务的对象，我的任务是把所有的任务项全部罗列、呈现到界面上。<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/34_1.png"><br>从上图可以看到，用一般的思维方式去完成这个任务，我的代码和老师的代码严重耦合，老师的代码只要修改了，我的代码就需要修改。此时如果老师的数据结构能够对外提供一个统一的遍历接口，对于我(调用者而言)也就不用再关心老师的代码内部的数据结构是怎样的了，更不用担心老师的代码内部结构改变过后产生的影响<br><img src="https://snakexu.github.io/images/lagou/part_1/ECMAScript/34_2.png"><br>实现可迭代接口其实是相同的道理，对外提供统一的遍历接口，让外部不用再担关心内部数据的结构是什么样的，ES2015在语言层面实现了迭代器模式，适用于任何数据结构，只需要在需要的地方实现iterator方法就可以</p>
<p><pre><br>//老师的代码===============================<br>const todos = {<br>    life: [‘吃饭’, ‘睡觉’, ‘打豆豆’],<br>    learn: [‘语文’, ‘数学’, ‘外语’],<br>    work: [‘喝茶’],<br>    // 提供统一遍历访问接口<br>    each: function (callback) {<br>        const all = [].concat(this.life, this.learn, this.work)<br>        for (const item of all) {<br>            callback(item)<br>        }<br>    },<br>    // 提供迭代器（ES2015 统一遍历访问接口）<br>    [Symbol.iterator]: function () {<br>        const all = […this.life, …this.learn, …this.work]<br>        let index = 0<br>        return {<br>            next: function () {<br>                return {<br>                      value: all[index],<br>                      done: index++ &gt;= all.length<br>                }<br>            }<br>        }<br>    }<br>}<br>// 我的代码 ===============================<br>todos.each(function (item) {<br>  console.log(item)<br>})<br>console.log(‘——————————-‘)<br>for (const item of todos) {<br>  console.log(item)<br>}<br>/*吃饭<br>睡觉<br>打豆豆<br>语文<br>数学<br>外语</pre></p>
<h2 id="喝茶"><a href="#喝茶" class="headerlink" title="喝茶"></a>喝茶</h2><p>吃饭<br>睡觉<br>打豆豆<br>语文<br>数学<br>外语*/<br><br>35.ES2015 生成器<br>生成器是为了避免异步编程过程中回调嵌套过深，提供更好的异步编程解决方案。我们先来了解一下生成器函数的语法以及基本应用</p>
<p><pre><br>function* foo(){<br>    console.log(‘zce’)//并未被打印<br>    return 100<br>}<br>const result = foo()<br>//console.log(result)//Object [Generator] {}<br>console.log(result.next())<br>//zce<br>//{ value: 100, done: true }//生成器接口也实现了iterator接口，也即是迭代器接口的协议<br></pre><br>这里我们单独用生成器函数并没有什么体会，因为平时使用生成器函数都会配合yield关键词使用</p>
<p><pre><br>function * foo () {<br>  console.log(‘1111’)<br>  yield 100<br>  console.log(‘2222’)<br>  yield 200<br>  console.log(‘3333’)<br>  yield 300<br>}<br>const generator = foo()<br>console.log(generator.next()) // 第一次调用，函数体开始执行，遇到第一个 yield 暂停<br>//1111<br>//{ value: 100, done: false }<br>console.log(generator.next())//第二次调用，从暂停位置继续，直到遇到下一个 yield 再次暂停<br>//2222<br>//{ value: 200, done: false }<br>console.log(generator.next())<br>//3333<br>//{ value: 300, done: false }<br>console.log(generator.next())// 第四次调用，已经没有需要执行的内容了，所以直接得到 undefined<br>//{ value: undefined, done: true }<br>console.log(generator.next())<br>//{ value: undefined, done: true }<br></pre><br>生成器函数自动帮我们返回一个生成器对象，我们调用这个对象的next方法才会让这个函数的函数体开始执行，在执行过程中一旦遇到yield关键词，函数的执行就会被暂停，而且yield后面的值将会被作为next的结果返回，如果我们继续调用生成器对象next，函数就会从暂停的位置继续开始执行，周而复始知道函数的执行完全结束，next所返回done的值也就变成了true。生成器函数最大的特点就是惰性执行，就是我们调用一下next就执行一次。<br>36.ES2015 生成器应用<br>了解了生成器，我们简单应用一下<br>(1)实现一个发号器</p>
<p><pre><br>function * createIdMaker(){<br>    let id = 1;<br>    while(true){//虽然这里是执行条件是true，但是因为有yield，每次只执行一遍就会停下<br>        yield id++<br>    }<br>}<br>const idMaker = createIdMaker()<br>console.log(idMaker.next().value)//1<br>console.log(idMaker.next().value)//2<br>console.log(idMaker.next().value)//3<br>console.log(idMaker.next().value)//4<br></pre><br>(2)实现对象的iterator方法<br>虽然生成器本身是有iterator接口的，我们用生成器实现iterator接口要比之前简单很多</p>
<p><pre><br>const todos = {<br>  life: [‘吃饭’, ‘睡觉’, ‘打豆豆’],<br>  learn: [‘语文’, ‘数学’, ‘外语’],<br>  work: [‘喝茶’],<br>  [Symbol.iterator]: function * () {<br>    const all = […this.life, …this.learn, …this.work]<br>    for (const item of all) {<br>      yield item<br>    }<br>  }<br>}<br>for (const item of todos) {<br>  console.log(item)<br>}<br></pre><br>37.ES2015 ES Modules<br>会在后面相关内容做介绍，这里不讲<br>38.ES2016 概述<br>ES2016与ES2015相比只是一个小版本的迭代<br>(1)Array.prototype.includes检查数组是否包含指定元素变得更加简单<br>过去我们用indexOf查找元素是否存在，但是indexOf不能查找NaN，includes可以查找NaN</p>
<p><pre><br>const arr = [‘foo’,1,NaN,false]<br>console.log(arr.includes(‘foo’))//true<br>console.log(arr.includes(NaN))//true<br></pre><br>(2)指数运算符<br>过去我们求2的10次放就是Math.pow(2,10)，ES2016的指数运算就是语言本身的运算符，在ES2016中2的10次方就是console.log( 2 ** 10 )<br>39.ES2017 概述<br>(1)Object.values()<br>返回对象的值数组<br>(2)Object.entries()<br>以数组的形式返回对象中的所有键值对</p>
<p><pre><br>const obj = {<br>    foo:’value1’,<br>    bar:’value2’<br>}<br>console.log(Object.values(obj))//[ ‘value1’, ‘value2’ ]<br>for(let [key,value] of Object.entries(obj)){<br>    console.log(key,value)<br>}<br>//foo value1<br>//bar value2<br>console.log(new Map(Object.entries(obj)))<br>//Map { ‘foo’ =&gt; ‘value1’, ‘bar’ =&gt; ‘value2’ }<br></pre><br>(3)Object.getOwnPropertyDescriptor()<br>获取对象中属性的完整描述信息。自从ES5之后我们可以给对象定义getter/setter属性，getter/setter是不能通过Object. assign去完全复制的，只会把getter/setter去当成一个普通的属性来复制</p>
<p><pre><br>const p1 = {<br>    firstName : ‘lei’,<br>    lastName : ‘wang’,<br>    get fullName(){<br>        return this.firstName+’ ‘+this.lastName<br>    }<br>}<br>// console.log(p1.fullName)<br>// const p2 = Object.assign({},p1)<br>// p2.firstName = ‘zce’<br>// console.log(p2.fullName)//lei wang<br>// console.log(p2)//{ firstName: ‘zce’, lastName: ‘wang’, fullName: ‘lei wang’ }<br>const descriptors = Object.getOwnPropertyDescriptors(p1)<br>// console.log(descriptor)<br>//{<br>//  firstName: {<br>//    value: ‘lei’,<br>//    writable: true,<br>//    enumerable: true,<br>//    configurable: true<br>//  },<br>//  lastName: {<br>//    value: ‘wang’,<br>//    writable: true,<br>//    enumerable: true,<br>//    configurable: true<br>//  },<br>//  fullName: {<br>//    get: [Function: get fullName],<br>//    set: undefined,<br>//    enumerable: true,<br>//    configurable: true<br>//  }<br>//}<br>const p2 = Object.defineProperties({},descriptors)<br>p2.firstName = ‘zce’<br>console.log(p2.fullName)//zce wang<br></pre><br>(4)String.prototype.padStart/String.prototype.padEnd<br>用给定的字符串填充指定(字符串开始位置或者字符串结束位置)位置</p>
<p><pre><br>const books = {<br>    html:5,<br>    css:16,<br>    javascript:128<br>}<br>for(const [name,count] of Object.entries(books)){<br>    console.log(<code>${name.padEnd(16,&#39;-&#39;)}|${count.toString().padStart(3,&#39;0&#39;)}</code>)<br>}<br>//html————|005<br>//css————-|016<br>//javascript——|128<br></pre><br>(5)在函数参数中添加尾逗号</p>
<p><pre><br>function foo(bar,baz,){<br>    //…<br>}<br></pre><br>(6)Async/Await<br>在异步编程中详细介绍过</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/21/拉勾-ECMAScript新特性/" data-id="ckeeij3bx0060joxq5wgn1fl6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-移动端APP开发工程师-微信小程序-3-1-1-创建微信小程序项目" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/20/网易微专业-移动端APP开发工程师-微信小程序-3-1-1-创建微信小程序项目/" class="article-date">
  <time datetime="2020-06-20T00:51:32.000Z" itemprop="datePublished">2020-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/20/网易微专业-移动端APP开发工程师-微信小程序-3-1-1-创建微信小程序项目/">网易微专业-移动端APP开发工程师-微信小程序-3.1.1-创建微信小程序项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这里主要讲解了一下注册小程序账号，下载微信开发者工具，初步了解开发者工具，所以不赘述。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/20/网易微专业-移动端APP开发工程师-微信小程序-3-1-1-创建微信小程序项目/" data-id="ckeeij323003rjoxqhpwr462a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网易微专业/">网易微专业</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-手写Promise源码" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/18/拉勾-手写Promise源码/" class="article-date">
  <time datetime="2020-06-18T00:56:08.000Z" itemprop="datePublished">2020-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/18/拉勾-手写Promise源码/">拉勾-手写Promise源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.Promise类核心逻辑的实现<br>首先我们来分析一下Promise的一些特性:<br>·Promise就是一个类，在执行这个类的时候需要传递一个执行器进去，执行器会立即执行<br>·Promise中有三种状态，分别为 等待-pending 成功-fulfilled 失败-rejected<br>  pending -&gt; fulfilled<br>  pending -&gt; rejected<br>  一旦状态确定就不可更改<br>·resolve和reject函数是用来更改状态的<br>  resolve:fulfilled<br>  reject:rejected<br>·then方法内部做的事情就是判断状态。如果状态是成功，调用成功的回调函数；如果状态是失败，调用失败的回调函数。then方法是被定义在原型对象中的<br>·then成功回调有一个参数，表示成功之后的值；then失败回调有一个参数，表示失败后的原因<br>下面开始用代码实现这些功能(也就是模拟promise的实现)<br>myPromise.js</p>
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //接收执行器，并且这个执行器是立即执行的
        executor(this.resolve,this.reject)
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
    }
    then(successCallback,failCallback){
        //判断状态
        if(this.status === FULFILLED){
            successCallback(this.value)
        }else if(this.status === REJECTED){
            failCallback(this.reason)
        }
    }
}
module.exports = myPromise;
</pre>
index.js
<pre>
const myPromise = require('./myPromise')
const promise = new myPromise((resolve,reject)=>{
    //resolve('成功')
    reject('失败')
})
promise.then(value=>{
    console.log(value)
},reason =>{
    console.log(reason)
})
</pre>
2.在Promise类中加入异步逻辑
myPromise.js
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //接收执行器，并且这个执行器是立即执行的
        executor(this.resolve,this.reject)
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //成功回调
    successCallback = undefined;
    //失败回调
    failCallback = undefined;
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
        //判断成功回调是否存在，如果存在就调用
        this.successCallback && this.successCallback(this.value)
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
        //判断失败回调是否存在，如果存在就调用
        this.failCallback && this.failCallback(this.reason)
    }
    then(successCallback,failCallback){
        //判断状态
        if(this.status === FULFILLED){
            successCallback(this.value)
        }else if(this.status === REJECTED){
            failCallback(this.reason)
        }else{
            //走到这里证明当前状态是等待pending
            //将成功回调和失败回调存储起来
            this.successCallback = successCallback
            this.failCallback = failCallback
        }
    }
}
module.exports = myPromise;
</pre>
index.js
<pre>
const myPromise = require('./myPromise')
const promise = new myPromise((resolve,reject)=>{
    setTimeout(()=>{
        resolve('成功')
    },2000)
    // reject('失败')
})
promise.then(value=>{
    console.log(value)
},reason =>{
    console.log(reason)
})
</pre>
3.实现then方法多次调用添加多个处理函数
同一个promise对象下面的then方法是可以被多次调用的，当then方法被多次调用，每一次then方法当中传递的回调函数都是要被执行的，如何执行呢？
myPromise.js
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //接收执行器，并且这个执行器是立即执行的
        executor(this.resolve,this.reject)
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //成功回调
    successCallback = [];//数组才可以存储多个可能的then方法的回调函数，failCallback同理
    //失败回调
    failCallback = [];
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
        //判断成功回调是否存在，如果存在就调用
        //this.successCallback && this.successCallback(this.value)//用数组存储回调事件，这里就不能再用了
        while(this.successCallback.length){
            this.successCallback.shift()(this.value)
        }
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
        //判断失败回调是否存在，如果存在就调用
        //this.failCallback && this.failCallback(this.reason)
        while(this.failCallback.length){
            this.failCallback.shift()(this.reason)
        }
    }
    then(successCallback,failCallback){
        //判断状态
        if(this.status === FULFILLED){
            successCallback(this.value)
        }else if(this.status === REJECTED){
            failCallback(this.reason)
        }else{
            //走到这里证明当前状态是等待pending
            //将成功回调和失败回调存储起来
            this.successCallback.push(successCallback)
            this.failCallback.push(failCallback)
        }
    }
}
module.exports = myPromise;
</pre>
index.js
<pre>
const myPromise = require('./myPromise')
const promise = new myPromise((resolve,reject)=>{
    // setTimeout(()=>{
    //     resolve('成功')
    // },2000)
    resolve('成功')
    // reject('失败')
})
promise.then(value=>{
    console.log(1)
    console.log(value)
},reason => {
    console.log(reason)
})
promise.then(value=>{
    console.log(2)
    console.log(value)
},reason => {
    console.log(reason)
})
promise.then(value=>{
    console.log(3)
    console.log(value)
},reason => {
    console.log(reason)
})
</pre>
4.实现then方法的链式调用(一) && 5.实现then方法的链式调用(二)
myPromise.js
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //接收执行器，并且这个执行器是立即执行的
        executor(this.resolve,this.reject)
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //成功回调
    successCallback = [];//数组才可以存储多个可能的then方法的回调函数，failCallback同理
    //失败回调
    failCallback = [];
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
        //判断成功回调是否存在，如果存在就调用
        //this.successCallback && this.successCallback(this.value)//用数组存储回调事件，这里就不能再用了
        while(this.successCallback.length){
            this.successCallback.shift()(this.value)
        }
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
        //判断失败回调是否存在，如果存在就调用
        //this.failCallback && this.failCallback(this.reason)
        while(this.failCallback.length){
            this.failCallback.shift()(this.reason)
        }
    }
    then(successCallback,failCallback){
        let promise2 = new myPromise((resolve,reject) => {
            //判断状态
            if(this.status === FULFILLED){
                let  x = successCallback(this.value);
                //resolve(x)
                //判断x的值是普通值还是promise对象
                //如果是普通值，直接resolve
                //如果是promise对象，查看promise对象返回的结果
                //再根据promise对象返回的结果，决定调用resolve还是reject
                resolvePromise(x, resolve, reject)
            }else if(this.status === REJECTED){
                failCallback(this.reason)
            }else{
                //走到这里证明当前状态是等待pending
                //将成功回调和失败回调存储起来
                this.successCallback.push(successCallback)
                this.failCallback.push(failCallback)
            }
        });
        return promise2 
    }
}
function resolvePromise(x, resolve, reject){
    if(x instanceof myPromise){
        //promise对象
        //x.then(value=>resolve(value),reason=>reject(reason))
        x.then(resolve,reject)
    }else{
        //普通值
        resolve(x)
    }
}
module.exports = myPromise;
</pre>
index.js
<pre>
const myPromise = require('./myPromise')
const promise = new myPromise((resolve,reject)=>{
    resolve('成功')
    // reject('失败')
})
function other(){
    return new myPromise((resolve,reject)=>{
        resolve('other')
    })
}
promise.then(value=>{
    console.log(value)
    return other()
}).then(value =>{
    console.log(value)
})
</pre>
6.then方法链式调用识别Promise对象返回自
如果循环调用本身的promise对象，如下面代码
<pre>
var promise = new Promise(function(resolve,reject){
    resolve(100)
})
var p1 = promise.then(function(value)=>{
    console.log(value)
    p1
})
</pre>
那么程序是会报错的，我们如何判断这种情况呢
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //接收执行器，并且这个执行器是立即执行的
        executor(this.resolve,this.reject)
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //成功回调
    successCallback = [];//数组才可以存储多个可能的then方法的回调函数，failCallback同理
    //失败回调
    failCallback = [];
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
        //判断成功回调是否存在，如果存在就调用
        //this.successCallback && this.successCallback(this.value)//用数组存储回调事件，这里就不能再用了
        while(this.successCallback.length){
            this.successCallback.shift()(this.value)
        }
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
        //判断失败回调是否存在，如果存在就调用
        //this.failCallback && this.failCallback(this.reason)
        while(this.failCallback.length){
            this.failCallback.shift()(this.reason)
        }
    }
    then(successCallback,failCallback){
        let promise2 = new myPromise((resolve,reject) => {
            //判断状态
            if(this.status === FULFILLED){
                //在所有同步代码执行完毕后再执行，能顺利获取promise2
                setTimeout(()=>{
                    let  x = successCallback(this.value);
                    //resolve(x)
                    //判断x的值是普通值还是promise对象
                    //如果是普通值，直接resolve
                    //如果是promise对象，查看promise对象返回的结果
                    //再根据promise对象返回的结果，决定调用resolve还是reject
                    resolvePromise(promise2, x, resolve, reject)
                },0)
            }else if(this.status === REJECTED){
                failCallback(this.reason)
            }else{
                //走到这里证明当前状态是等待pending
                //将成功回调和失败回调存储起来
                this.successCallback.push(successCallback)
                this.failCallback.push(failCallback)
            }
        });
        return promise2 
    }
}
function resolvePromise(promise2, x, resolve, reject){
    if(promise2 === x){
        return reject(new TypeError('Chaining cycle detected for promise #< promise >'))
    }
    if(x instanceof myPromise){
        //promise对象
        //x.then(value=>resolve(value),reason=>reject(reason))
        x.then(resolve,reject)
    }else{
        //普通值
        resolve(x)
    }
}
module.exports = myPromise;
</pre>
index.js
<pre>
const myPromise = require('./myPromise')
const promise = new myPromise((resolve,reject)=>{
    resolve('成功')
    // reject('失败')
})
function other(){
    return new myPromise((resolve,reject)=>{
        resolve('other')
    })
}
let p1 = promise.then(value=>{
    console.log(value)
    return p1
})
p1.then(value =>{
    console.log(value)
},reason=>{
    console.log(reason.message)
})
</pre>
7.捕获错误及then链式调用其他状态代码补充
8.将then方法变成可选参数(确认参数是否存在，不存在设置默认参数返回)
9.Promise.all方法的实现
首先我们了解下Promise.all方法的主要特点，以我们下面的代码为例
<pre>
function p1(){
    return new Promise(function(resolve,reject){
        setTimeout(function(){
            resolve('p1')
        },2000)
    })
}
function p2(){
    return new Promise(function(resolve,reject){
        resolve('p2')
    })
}
Promise.all(['a','b',p1(),p2(),'c']).then(function(result){
    //result->['a','b','p1','p2','c']
})
</pre>
Promise.all主要是解决异步代码的并发问题，允许我们按照异步代码调用的顺序得到异步代码执行的结果，上面代码，如果先调用p1，再调用p2，那么p2会先执行，因为p1有setTimeout定时器延时，但是如果我们把p1，p2放入Promise.all方法，会按放入的先后顺序执行，也就是先放入p1就执行p1。
Promise.all方法接收一个数组作为参数，在数组中我们可以放入任何值，包括普通值和promise对象，数组中值的顺序一定是我们得到的结果中的顺序。Promise.all的返回值也是一个Promise对象，所以我们也可以链式调用then方法。如果all方法中所有promise对象的状态都是成功的，则all方法最好的结果也是成功的，如果有一个失败的，那么all方法就是失败的。
myPromise.js
<pre>
//把状态定义成常量，编辑器会有提示，同时也有利于代码的复用
const PENDING = 'pending' //等待
const FULFILLED = 'fulfilled' //成功
const REJECTED = 'rejected' //失败
class myPromise{
    constructor(executor){
        //捕获执行过程中的错误
        try{
            //接收执行器，并且这个执行器是立即执行的
            executor(this.resolve,this.reject)
        } catch(e){
            this.reject(e)
        }
    }
    //promise状态
    status = PENDING;
    //每一个promise对象成功之后都有自己成功的值
    value = undefined;
    //每一个promise对象失败之后都有自己失败的原因
    reason = undefined;
    //成功回调
    successCallback = [];//数组才可以存储多个可能的then方法的回调函数，failCallback同理
    //失败回调
    failCallback = [];
    //定义成箭头函数是因为箭头函数在定义的时候就确定this的指向
    resolve = value => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为成功
        this.status = FULFILLED
        //保存成功之后的值
        this.value = value
        //判断成功回调是否存在，如果存在就调用
        //this.successCallback && this.successCallback(this.value)//用数组存储回调事件，这里就不能再用了
        while(this.successCallback.length){
            this.successCallback.shift()()
        }
    }
    reject = reason => {
        //如果状态不是等待，阻止程序向下执行
        if(this.status !== PENDING) return ;
        //将状态更改为失败
        this.status = REJECTED
        //保存失败之后的原因
        this.reason = reason
        //判断失败回调是否存在，如果存在就调用
        //this.failCallback && this.failCallback(this.reason)
        while(this.failCallback.length){
            this.failCallback.shift()()
        }
    }
    then(successCallback,failCallback){
        successCallback = successCallback ? successCallback : value => value ;
        failCallback = failCallback ? failCallback : reason => {throw reason} ;
        let promise2 = new myPromise((resolve,reject) => {
            //判断状态
            if(this.status === FULFILLED){
                //在所有同步代码执行完毕后再执行，能顺利获取promise2
                setTimeout(()=>{
                    try{
                        let  x = successCallback(this.value);
                        //resolve(x)
                        //判断x的值是普通值还是promise对象
                        //如果是普通值，直接resolve
                        //如果是promise对象，查看promise对象返回的结果
                        //再根据promise对象返回的结果，决定调用resolve还是reject
                        resolvePromise(promise2, x, resolve, reject)
                    }catch(e){
                        reject(e)
                    }
                },0)
            }else if(this.status === REJECTED){
                setTimeout(()=>{
                    try{
                        let  x = failCallback(this.reason);
                        //resolve(x)
                        //判断x的值是普通值还是promise对象
                        //如果是普通值，直接resolve
                        //如果是promise对象，查看promise对象返回的结果
                        //再根据promise对象返回的结果，决定调用resolve还是reject
                        resolvePromise(promise2, x, resolve, reject)
                    }catch(e){
                        reject(e)
                    }
                },0)
            }else{
                //走到这里证明当前状态是等待pending
                //将成功回调和失败回调存储起来
                this.successCallback.push(()=>{
                    setTimeout(()=>{
                        try{
                            let  x = successCallback(this.value);
                            //resolve(x)
                            //判断x的值是普通值还是promise对象
                            //如果是普通值，直接resolve
                            //如果是promise对象，查看promise对象返回的结果
                            //再根据promise对象返回的结果，决定调用resolve还是reject
                            resolvePromise(promise2, x, resolve, reject)
                        }catch(e){
                            reject(e)
                        }
                    },0)
                })
                this.failCallback.push(()=>{
                    setTimeout(()=>{
                        try{
                            let  x = failCallback(this.reason);
                            //resolve(x)
                            //判断x的值是普通值还是promise对象
                            //如果是普通值，直接resolve
                            //如果是promise对象，查看promise对象返回的结果
                            //再根据promise对象返回的结果，决定调用resolve还是reject
                            resolvePromise(promise2, x, resolve, reject)
                        }catch(e){
                            reject(e)
                        }
                    },0)
                })
            }
        });
        return promise2 
    }
    //类相当于实例的原型，所有在类中定义的方法，都会被实例继承。
    //如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，
    //而是直接通过类来调用（通过类调用指在该类之外调用），这就称为“静态方法”。
    static all(array){
        let result = []
        let index = 0
        return new myPromise((resolve,reject)=>{
            function addData(key, value){
                result[key] = value;
                index++
                if(index === array.length){
                    resolve(result)
                }
            }
            for(let i=0;i<array.length;i++){ let="" current="array[i];" if(current="" instanceof="" mypromise){="" 是一个promise对象，要执行这个对象="" current.then(value=""> addData(i,value),reason => reject(reason))
                }else{
                    //current 是一个普通值
                    addData(i,array[i])
                }
            }
            //resolve(result)
        })
    }
}
function resolvePromise(promise2, x, resolve, reject){
    if(promise2 === x){
        return reject(new TypeError('Chaining cycle detected for promise #<promise>'))
    }
    if(x instanceof myPromise){
        //promise对象
        //x.then(value=>resolve(value),reason=>reject(reason))
        x.then(resolve,reject)
    }else{
        //普通值
        resolve(x)
    }
}
module.exports = myPromise;
</promise></array.length;i++){></pre>
index.js
<pre>
const myPromise = require('./myPromise')
function p1(){
    return new myPromise(function(resolve,reject){
        setTimeout(function(){
            resolve('p1')
        },2000)
    })
}
function p2(){
    return new myPromise(function(resolve,reject){
        resolve('p2')
    })
}
myPromise.all(['a','b',p1(),p2(),'c'])
.then(function(result){
    //result->['a','b','p1','p2','c']
    console.log(result)
})
</pre>
10.Promise.resolve方法的实现
Promise.resolve方法的作用是将给定的值转换为promise对象
这个代码并不复杂，所以就不把整段myPromise代码都展示在这里了
<pre>
static resolve(value){
    if(value instanceof myPromise) return value;
    return new myPromise(resolve => resolve(value))
}
</pre>
11.finally方法的实现
promise最终的状态无论是成功还是失败，finally方法都会被执行一次；在finally对象的后面我们还可以链式调用then方法拿到最终返回的结果。并且在finally中如果返回一个异步函数，是会等待异步对象执行完成的。
<pre>
finally(callback){
        return this.then(value=>{
            // callback()
            // return value//注释掉的两行是不考虑finally中return一个异步函数的情况
            return myPromise.resolve(callback()).then(() => value)//考虑finally中return一个异步函数的情况
        },reason=>{
            // callback()
            // throw reason
            return myPromise.resolve(callback()).then(() => {throw reason})
        })
    }
</pre>
12.catch方法的实现
用来处理当前promise对象最终为失败的情况
<pre>
catch(failCallback){
    return this.then(undefined, failCallback)
}
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/18/拉勾-手写Promise源码/" data-id="ckeeij38p005ojoxqd72jonkh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-JavaScript异步编程" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/17/拉勾-JavaScript异步编程/" class="article-date">
  <time datetime="2020-06-17T02:46:47.000Z" itemprop="datePublished">2020-06-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/拉勾/">拉勾</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/拉勾-JavaScript异步编程/">拉勾-JavaScript异步编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.概述<br>1-1.采用单线程模式工作的原因<br>最早JavaScript是运行在浏览器中的脚本语言，为了实现页面上的动态交互，实现页面操作的核心是DOM操作，这也就决定了必须使用单线程，否则会出现很复杂的线程交互问题。比如JavaScript中多个线程一起工作，其中一个线程修改了元素，另外一个线程删除了该元素，浏览器就无法明确应该以哪个结果为准，为了避免这种问题，JavaScript被设计为单线程模式工作，也就成了这门语言最为核心的特性之一。<br>这里所说的单线程指的是在js执行环境中负责执行代码的线程只有一个。<br>所以每次只能执行一个任务，如果有多个任务就需要排队执行。优点是更安全更简单，缺点是如果遇到一个很耗时的任务，后面的任务都要等待导致整个程序会被拖延出现假死的情况。为了解决耗时任务阻塞的问题，JavaScript将任务的执行模式分为同步模式和异步模式。<br>1-2.我们这里主要关注异步模式:<br>·同步模式与异步模式<br>·事件循环与消息队列<br>·异步编程的几种方式<br>·Promise异步方案、宏任务/微任务队列<br>·Generator异步方案、async/await语法糖<br>2.同步模式<br>同步模式:代码中的任务依次执行，后面的任务必须等待前面的任务结束才能开始执行，程序的执行顺序与代码的编写顺序完全一致。在单线程情况下，大多数任务都会以同步模式执行(同步模式不是指同时执行，而是指排队执行)<br>同步模式代码例子:</p>
<p><pre><br>console.log(‘global begin’)<br>function bar () {<br>  console.log(‘bar task’)<br>}<br>function foo () {<br>  console.log(‘foo task’)<br>  bar()<br>}<br>foo()<br>console.log(‘global end’)<br></pre><br>下面几个图简单模拟了上面代码在函数调用栈中的执行(纯同步模式)<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_2.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_3.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_4.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_5.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_6.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_7.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_8.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_9.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_10.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_11.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/2_12.png"><br>我们之前也了解到，同步模式最大的问题就是如果某个操作十分耗时，而我们无法继续执行程序，就会造成程序的假死，用户体验变差，所以ajax/大文件读取等都采用异步操作<br>3.异步模式<br>异步模式不会等待这个任务的结束才开始执行下一个任务，对于耗时操作，都是开启过后就立即往后执行下一个任务，耗时任务的后续逻辑一般通过回调函数的方式定义，在内部耗时任务完成之后就会自动执行传入的回调函数。异步模式对JavaScript非常重要，如果没有异步模式单线程的JavaScript就无法同时处理大量耗时任务。对于开发者而言，单线程执行环境下的难点就是代码执行的顺序并不会像同步代码通俗易懂，需要理解和习惯。<br>下面我们通过一个例子开始了解</p>
<p><pre><br>console.log(‘global begin’)<br>setTimeout(function timer1 () {<br>  console.log(‘timer1 invoke’)<br>}, 1800)<br>setTimeout(function timer2 () {<br>  console.log(‘timer2 invoke’)<br>  setTimeout(function inner () {<br>    console.log(‘inner invoke’)<br>  }, 1000)<br>}, 1000)<br>console.log(‘global end’)<br></pre><br>执行过程大致如下<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_2.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_3.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_4.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_5.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_6.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_7.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_8.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_9.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_10.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_11.png"><br>到这里整体的匿名函数调用基本完成，调用栈清空，Event Loop上场，负责监听调用栈和消息队列，一旦调用栈所有任务都结束，事件循环就会从消息队列中取出第一个回调函数压入调用栈。此时当前代码的消息队列是空的，什么都没有，执行被暂停。现在我们看看倒计时器，自从被放入我们就没再关注过，而是直接往后执行<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_12.png"><br>由于timer2是1秒后执行比timer1的1.8秒早，那么timer2倒计时会先结束，会先被放入消息队列的第一位，然后timer1倒计时结束，被放入消息队列第二位<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_13.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_14.png"><br>一旦消息队列发生变化就会被事件循环监听到，就会把消息队列的第一个也就是timer2放到调用栈去执行timer2<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_15.png"><br>此时对调用栈来讲，相当于开启了新一轮的执行，执行过程与我们刚分析的是一样的<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_16.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_17.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_18.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_19.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_20.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_21.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_22.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_23.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_24.png"><br>我们可以这样理解:调用栈-正在执行的工作表，消息队列-待办工作表。js执行引擎先去执行调用栈中的任务，再通过事件循环从消息队列中取一个任务出来，以此类推。在这个过程中我们随时可以往消息队列中再放入任务，这些任务会在消息队列中排队等待放入事件循环。整个过程都是通过消息队列和事件循环去实现的。我们这里是分开分析的，但是不要因此认为这个步骤有先后顺序，各自有各自的timeline，例如倒计时器开始过后就会自动开始倒计时，跟本不会管调用栈/队列的情况。<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/3_25.png"><br>在这理要理解，虽然JavaScript是单线程执行的，但是浏览器并不是单线程的，浏览器会有 GUI 渲染线程、JavaScript引擎线程、定时触发器线程、事件触发线程、异步http请求线程。我们这里说的同步/异步是说运行环境提供的API是以同步/异步模式的方式工作。<br>4.回调函数<br>回调函数是所有异步编程方案的根基。<br>由调用者定义，交给执行者执行函数的函数就是回调函数。其实就是把函数作为参数传递，但是这种方式不利于阅读。除了传递回调参数以外，还有事件机制、发布订阅都是异步的实现方式。<br>5.Promise概述<br>用传统方式去完成复杂的异步流程就难免出现大量的回调函数的嵌套，也就是回调地狱问题。为了避免回调地狱，我们找到了promise这个解决方案(具体promise如何出现本处不细表)。<br>promise可以理解为一个对象，表示一个异步任务结束过后是成功还是失败。<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/5_1.png"><br>6.Promise基本用法</p>
<p><pre><br>// Promise 基本示例<br>const promise = new Promise(function (resolve, reject) {<br>  // 这里用于“兑现”承诺<br>  // resolve(100) // 承诺达成<br>  reject(new Error(‘promise rejected’)) // 承诺失败<br>})<br>promise.then(function (value) {<br>  // 即便没有异步操作，then 方法中传入的回调仍然会被放入队列，等待下一轮执行<br>  console.log(‘resolved’, value)<br>}, function (error) {<br>  console.log(‘rejected’, error)<br>})<br>console.log(‘end’)<br></pre><br>7.Promise使用案例</p>
<p><pre><br>// Promise 方式的 AJAX<br>function ajax (url) {<br>  return new Promise(function (resolve, reject) {<br>    var xhr = new XMLHttpRequest()<br>    xhr.open(‘GET’, url)<br>    xhr.responseType = ‘json’<br>    xhr.onload = function () {<br>      if (this.status === 200) {<br>        resolve(this.response)<br>      } else {<br>        reject(new Error(this.statusText))<br>      }<br>    }<br>    xhr.send()<br>  })<br>}<br>ajax(‘/api/foo.json’).then(function (res) {<br>  console.log(res)<br>}, function (error) {<br>  console.log(error)<br>})<br></pre><br>8.Promise常见误区<br>从表象上来看，promise的本质也是使用回调函数定义异步任务结束过后所需要执行的任务，只不过这里的回调函数是通过then方法传递的。按照这种思路，仍然会形成回调地狱，promise也就没有任何意义，还增加了额外的复杂度。<br>嵌套使用的方式是使用promise最常见的错误，实际上是借助于promise then方法链式调用的特点，尽量保证异步任务扁平化。<br>9.Promise链式调用</p>
<p><pre><br>// Promise 链式调用<br>function ajax (url) {<br>  return new Promise(function (resolve, reject) {<br>    var xhr = new XMLHttpRequest()<br>    xhr.open(‘GET’, url)<br>    xhr.responseType = ‘json’<br>    xhr.onload = function () {<br>      if (this.status === 200) {<br>        resolve(this.response)<br>      } else {<br>        reject(new Error(this.statusText))<br>      }<br>    }<br>    xhr.send()<br>  })<br>}<br>var promise = ajax(‘/api/users.json’)<br>var promise2 = promise.then(<br>  function onFulfilled (value) {<br>    console.log(‘onFulfilled’, value)<br>  },<br>  function onRejected (error) {<br>    console.log(‘onRejected’, error)<br>  }<br>)<br>console.log(promise2)//这里是说明promise内部返回的也是一个promise对象<br>console.log(promise2 === promise)//false<br></pre><br>promise!==promise2说明这里的链式调用返回的是一个全新的promise，不是传统的this来链式调用 </p>
<p><pre><br>ajax(‘/api/users.json’)<br>  .then(function (value) {<br>    console.log(1111)<br>    return ajax(‘/api/urls.json’)<br>  }) // =&gt; Promise<br>  .then(function (value) {<br>    console.log(2222)<br>    console.log(value)<br>    return ajax(‘/api/urls.json’)<br>  }) // =&gt; Promise<br>  .then(function (value) {<br>    console.log(3333)<br>    return ajax(‘/api/urls.json’)<br>  }) // =&gt; Promise<br>  .then(function (value) {<br>    console.log(4444)<br>    return ‘foo’<br>  }) // =&gt; Promise<br>  .then(function (value) {<br>    console.log(5555)<br>    console.log(value)<br>  })<br></pre><br>如果不断的链式调用then，这里每个then方法都是在为上一个then方法返回的promise添加状态明确过后的回调。promise会依次执行，那么回调函数也就回从前到后依次执行。也可以在then中手动执行返回一个promise对象。如果我们在回调当中返回的是一个普通的值，这个值会作为当前then方法返回的promise中的值，在下一个then方法中接收的回调参数就是这个值。<br>下图返回了上面代码的部分执行结果<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/9_1.png"><br>小结:<br>·Promise对象的then方法会返回一个全新的Promise对象(可以使用链式调用)<br>·后面的then方法就是在为上一个then返回的Promise注册回调<br>·前面then方法中回调函数的返回值会作为后面then方法回调的参数<br>·如果回调中返回的是Promise，那后面then方法的回调会等待它的结束<br>10.Promise异常处理<br>promise结果一旦失败就会调用我们传入的rejected函数，如果在promise执行过程中出现异常或者手动抛出异常rejected回调也会被执行。<br>一般我们会用catch去执行一场回调，这里catch相当于给前面的then方法执行异常回调。用catch和用resolve/reject不同之处在于，resolve/reject相当于给指定promise做回调，而catch相当于给catch之前的then做回调</p>
<p><pre><br>ajax(‘/api/users.json’)<br>  .then(function onFulfilled (value) {<br>    console.log(‘onFulfilled’, value)<br>    return ajax(‘/error-url’)<br>  }, function onRejected (error) {<br>    console.log(‘onRejected’, error)//这里不能捕获ajax(‘/error-url’)的异常，只能捕获ajax(‘/api/users.json’)的异常<br>  })<br></pre></p>
<p><pre><br>ajax(‘/api/users.json’)<br>  .then(function onFulfilled (value) {<br>    console.log(‘onFulfilled’, value)<br>    return ajax(‘/error-url’)<br>  })<br>  .catch(function onRejected (error) {<br>  //这里的catch相当于给ajax(‘/error-url’)做的回调，不能捕获ajax(‘/api/users.json’)的异常<br>    console.log(‘onRejected’, error)<br>  })<br></pre><br>所以链式调用的情况下我们尽量用catch方法，这样如果有异常就会被回调。或者我们可以注册一个全局异常事件处理代码中没有被捕获的异常<br>在window环境中</p>
<p><pre><br>window.addEventListener(‘unhandledrejection’,event =&gt; {<br>    const { reason,promise } = event<br>    console.log(reason,promise)<br>    //reason =&gt; Promise 失败原因，一般是一个错误对象<br>    // promise =&gt; 出现异常的 Promise 对象<br>    event.preventDefault()<br>},false)<br></pre><br>在node环境中</p>
<p><pre><br>process.on(‘unhandledRejection’, (reason, promise) =&gt; {<br>  console.log(reason, promise)<br>  // reason =&gt; Promise 失败原因，一般是一个错误对象<br>  // promise =&gt; 出现异常的 Promise 对象<br>})<br></pre><br>最好的方法是在代码中明确捕获每一个可能的异常，所以全局捕获的方法并不推荐使用<br>11.Promise静态方法<br>11-1.Promise.resolve()//快速把一个值转换为promise对象，返回一个状态为fullfilled的promise对象<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/11_1.png"></p>
<p><pre><br>Promise.resolve(‘foo’)<br>  .then(function (value) {<br>    console.log(value)<br>  })<br>//这里两种方法是等价的，返回foo这个字符串<br>new Promise(function (resolve, reject) {<br>  resolve(‘foo’)<br>})<br></pre><br>如果传入的是一个 Promise 对象，Promise.resolve 方法原样返回</p>
<p><pre><br>var promise = ajax(‘/api/users.json’)<br>var promise2 = Promise.resolve(promise)<br>console.log(promise === promise2)//true<br></pre><br>如果传入的是带有一个跟 Promise 一样的 then 方法的对象，Promise.resolve 会将这个对象作为 Promise 执行<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/11_2.png"><br>11-2.Promise.reject//快速创建一个失败状态的promise对象，传入的数据会作为失败的原因<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/11_3.png"><br>12.Promise并行执行<br>12-1.Promise.all()将多个promise合并为一个promise去管理，会在所有任务结束后才会结束</p>
<p><pre><br>var promise = Promise.all([<br>  ajax(‘/api/users.json’),<br>  ajax(‘/api/posts.json’)<br>])//返回一个全新的promise<br>//当内部所有的promise都完成了，所返回的全新promise才会完成<br>promise.then(function (values) {<br>  console.log(values)<br>}).catch(function (error) {<br>  console.log(error)<br>})<br></pre><br>这里promise对象拿到的结果是一个数组，在数组中包含每一个异步任务执行的结果<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/12_1.png"></p>
<p><pre><br>ajax(‘/api/urls.json’)//去请求包含所有url的对象<br>  .then(value =&gt; {<br>    const urls = Object.values(value)<br>    const tasks = urls.map(url =&gt; ajax(url))<br>    return Promise.all(tasks)<br>  })<br>  .then(values =&gt; {<br>    console.log(values)<br>  })<br></pre><br>12-2.Promise.race()把多个promise对象组合为一个全新的promise对象，只会等待所有任务中第一个结束的任务</p>
<p><pre><br>const request = ajax(‘/api/posts.json’)<br>const timeout = new Promise((resolve, reject) =&gt; {<br>  setTimeout(() =&gt; reject(new Error(‘timeout’)), 500)<br>})<br>Promise.race([<br>  request,<br>  timeout<br>])<br>.then(value =&gt; {<br>  console.log(value)<br>})<br>.catch(error =&gt; {<br>  console.log(error)<br>})<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/12_2.png"><br>13.Promise执行时序<br>即便promise中并没有任何异步操作，它的回调函数仍然会进入到回调队列当中排队，也就是说我们要等当前同步代码执行完毕才能promise中的回调。当然，这句话并不是十分严谨</p>
<p><pre><br>console.log(‘global start’)<br>Promise.resolve().then(()=&gt;{<br>    console.log(‘promise’)<br>})<br>console.log(‘global end’)<br></pre><br>上面代码执行结果<br>global start<br>global end<br>promise</p>
<p>那如果我们稍作修改</p>
<p><pre><br>console.log(‘global start’)<br>Promise.resolve()<br>  .then(() =&gt; {<br>    console.log(‘promise’)<br>  })<br>  .then(() =&gt; {<br>    console.log(‘promise 2’)<br>  })<br>  .then(() =&gt; {<br>    console.log(‘promise 3’)<br>  })<br>console.log(‘global end’)<br></pre><br>则执行结果为<br>global start<br>global end<br>promise<br>promise 2<br>promise 3</p>
<p>如果再加上setTimeout呢</p>
<p><pre><br>console.log(‘global start’)<br>// setTimeout 的回调是 宏任务，进入回调队列排队<br>setTimeout(() =&gt; {<br>  console.log(‘setTimeout’)<br>}, 0)<br>// Promise 的回调是 微任务，本轮调用末尾直接执行<br>Promise.resolve()<br>  .then(() =&gt; {<br>    console.log(‘promise’)<br>  })<br>  .then(() =&gt; {<br>    console.log(‘promise 2’)<br>  })<br>  .then(() =&gt; {<br>    console.log(‘promise 3’)<br>  })<br>console.log(‘global end’)<br></pre><br>我们发现执行结果为<br>global start<br>global end<br>promise<br>promise 2<br>promise 3<br>setTimeout</p>
<p>如何理解上面的执行结果呢<br>我们一般将回调队列中的任务称之为”宏任务”，宏任务执行过程当中可以临时加上一些额外需求，这些临时额外需求可以选择作为一个新的宏任务进到队列中排队，也可以作为当前任务的”微任务”，直接在当前任务结束过后立即执行。Promise的回调会作为微任务执行，会在本轮调用结束的末尾去执行，而setTimmeout会作为宏任务进入回调队列的末尾，所以先打印promise，再打印setTimeout。<br>微任务的概念是在后来才被引入js中的，目的是为了提高整体相应能力。目前绝大多数异步调用都是作为宏任务执行，但是promise和MutationObserver以及node当中的process.nextTick都会作为微任务直接在本轮调用的末尾执行。<br>14.Generator 异步方案(上)<br>Promise虽然解决异步回调的回调地狱问题已经很好了，但是如果我们想更清晰的像看同步代码一样的可读性，可以了解下ES2015提供的Generator</p>
<p><pre><br>function * foo () {<br>  console.log(‘start’)<br>  yield ‘foo’<br>}<br>const generator = foo()<br>const result = generator.next()<br>console.log(result)<br></pre><br>上面代码我们需要了解生成器函数只有在next()调用的时候才会执行，我们也可以在next()对象返回值中拿到yield的返回值<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/14_1.png"><br>另外我们还可以看到返回值里有个done属性，用来表示生成器是否已经全部执行完成，yield只是暂停函数的执行，并不是结束函数的执行，直到我们下次调用next方法，就会继续从yield位置往下执行。</p>
<p><pre><br>function * foo () {<br>  console.log(‘start’)<br>  yield ‘foo’<br>}<br>const generator = foo()<br>const result = generator.next()<br>console.log(result)<br></pre><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/14_2.png"><br>也就是说如果我们调用next方法的时候传递参数，会作为yield语句的返回值，也就是说我们可以定义变量，把yield的返回值赋给这个变量</p>
<p><pre><br>function * foo () {<br>  console.log(‘start’)<br>  try {<br>    const res = yield ‘foo’<br>    console.log(res)<br>  } catch (e) {<br>    console.log(e)<br>  }<br>}<br>const generator = foo()<br>const result = generator.next()<br>console.log(result)<br>// generator.next(‘bar’)<br>generator.throw(new Error(‘Generator error’))<br></pre><br>如果我们在外部调用生成器对象的throw方法，就可以对生成器函数内部抛出一个异常，内部往下执行的时候就会得到这个异常，我们可以通过try/catch去捕获这个异常<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/14_3.png"><br>15.Generator 异步方案(中)<br>借助yield可以暂停生成器函数执行的特点来使用生成器函数来实现更优的异步编程体验<br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/15_1.png"><br><img src="https://snakexu.github.io/images/lagou/part_1/asyncmode/15_2.png"><br>16.Generator 异步方案(下)<br>用递归的方式实现一个更通用的函数生成器</p>
<p><pre><br>// Async / Await 语法糖<br>function ajax (url) {<br>  return new Promise((resolve, reject) =&gt; {<br>    var xhr = new XMLHttpRequest()<br>    xhr.open(‘GET’, url)<br>    xhr.responseType = ‘json’<br>    xhr.onload = () =&gt; {<br>      if (xhr.status === 200) {<br>        resolve(xhr.response)<br>      } else {<br>        reject(new Error(xhr.statusText))<br>      }<br>    }<br>    xhr.send()<br>  })<br>}<br>function co (generator) {<br>  const g = generator()<br>  function handleResult (result) {<br>    if (result.done) return // 生成器函数结束<br>    result.value.then(data =&gt; {<br>      handleResult(g.next(data))<br>    }, error =&gt; {<br>      g.throw(error)<br>    })<br>  }<br>  handleResult(g.next())<br>}<br>async function main () {<br>  try {<br>    const users = await ajax(‘/api/users.json’)<br>    console.log(users)<br>    const posts = await ajax(‘/api/posts.json’)<br>    console.log(posts)<br>    const urls = await ajax(‘/api/urls.json’)<br>    console.log(urls)<br>  } catch (e) {<br>    console.log(e)<br>  }<br>}<br>// co(main)<br>const promise = main()<br>promise.then(() =&gt; {<br>  console.log(‘all completed’)<br>})<br></pre><br>17.Async函数<br>async/await语法糖是语言层面的异步标准编程，有了async/await我们不再用generator这样的函数，因为generator需要配合co等执行器。async函数返回一个promise对象，await目前只能在async函数内使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/17/拉勾-JavaScript异步编程/" data-id="ckeeij36l0058joxq7v9i4aew" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-移动端APP开发工程师-移动UI框架Flutter-2-1-1-Flutter概述及开发环境" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/15/网易微专业-移动端APP开发工程师-移动UI框架Flutter-2-1-1-Flutter概述及开发环境/" class="article-date">
  <time datetime="2020-06-15T08:18:19.000Z" itemprop="datePublished">2020-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/15/网易微专业-移动端APP开发工程师-移动UI框架Flutter-2-1-1-Flutter概述及开发环境/">网易微专业-移动端APP开发工程师-移动UI框架Flutter-2.1.1-Flutter概述及开发环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.初识Flutter<br>1-1.Flutter是什么<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_1.png"><br>1-2.跨平台开发方案<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_2.png"><br>下面图中三个部分依次对应三个不同的跨平台开发方案的时代<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_3.png"><br>上图左上角对应web时代开发方案:主要采用原生应用内嵌于浏览器空间webview。并且定义html5和原生代码交互协议，将部分原生系统能力暴露给html5，从而扩展html5的边界，这类交互协议就是我们通常说的jsBridge。一个完整html5页面的展示要经历浏览器的控件的加载、解析、渲染三大过程，浏览器消耗要比原生开发增加了N个数量级。html5页面的展示是比较复杂的，这和原生开发通过简单直接的创建控件、设置属性后即可完成页面渲染有很大的差异。web和原生在UI渲染和系统功能调用各司其职。<br>右上角是泛web容器时代解决方案的原理图:泛web容器时代优化了web容器时代的加载、解析和渲染这三大过程。它把影响他们独立运行的web标准进行了裁剪，以相对简单的方式支持构建移动端页面的web标准，也保证了便捷的开发体验。同时这个时代的开发方案基本完全放弃了浏览器控件的渲染，而是采用了原生自带的UI组件实现代替了核心的渲染引擎，仅保持必要的基本控件渲染能力，从而使得渲染过程更加简化，也保证了良好的渲染性能。也就是说在web容器时代我们仍然采用的是前端由JavaScript进行开发，整体加载渲染机制大大简化，并且由原生接管绘制。<br>最后中间的图是自绘引擎时代的开发原理:泛web时代采用的是使用原生控件承载界面渲染，固然解决了不少性能问题，但是也同时带来了一些新的问题。抛开框架本身需要大量平台相关的逻辑，随着系统版本的变化和API的变化，我们可能需要处理不同平台原生控件渲染能力的差异，修复各类奇奇怪怪的bug。而在自绘引擎时代，这一新时期的代表Flutter则开辟了一个全新的思路，从头到尾重写了一套跨平台UI框架，包括渲染逻辑甚至是开发语言。Flutter的渲染引擎依靠跨平台的Skia图形库来实现。Skia引擎会将使用大的构建的抽象视图数据加工成GPU数据，然后交由OpenGL，最终提供给GPU渲染，因此可以在最大程度上保证一款应用在不同平台不同设备上的体验一致性。而对于开发语言来讲，开发语言选用的是同时支持JIT和AOT模式的Dart语言。不仅保证了开发效率，更是提升了执行效率。<br>1-3.我该选择哪一类跨平台开发方案<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_4.png"><br>1-4.Flutter框架结构<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_5.png"><br>2.开发环境搭建<br>2-1.开发环境搭建<br><img src="https://snakexu.github.io/images/wangyi/app/2.1.1_6.png"><br>3.Flutter项目结构</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/15/网易微专业-移动端APP开发工程师-移动UI框架Flutter-2-1-1-Flutter概述及开发环境/" data-id="ckeeij323003sjoxqtsmdfh5o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-函数式编程范式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/拉勾-函数式编程范式/" class="article-date">
  <time datetime="2020-06-14T10:27:36.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/拉勾-函数式编程范式/">拉勾-函数式编程范式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>6.高阶函数-函数作为返回值</p>
<p><pre><br>function makeFn(){<br>    let msg = ‘Hello function’;<br>    return function(){<br>        console.log(msg);<br>    }<br>}<br>const fn = makeFn()<br>fn()//调用返回函数<br>makeFn()()//和fn()其实调用结果是一致的<br></pre><br>下面我们模拟once(只执行一次的函数)执行</p>
<p><pre><br>function once(fn){<br>    let done = false;<br>    return function(){<br>        if(!done){<br>            done = true;<br>            return fn.apply(this,arguments)<br>        }<br>    }<br>}<br>let pay = once(function(money){<br>    console.log(<code>支付:${money}RMB</code>)<br>})<br>pay(5)<br>pay(5)<br>pay(5)<br></pre><br>7.高阶函数的意义<br>使用高阶函数的意义:抽象可以帮我们屏蔽细节，只需要关注于我们的目标；高阶函数是用来抽象通用的问题<br>举例我们需要打印数组中的所有元素 </p>
<p><pre><br>//面向过程的方式<br>let array = [1,2,3,4]<br>for(let i =0; i &lt; array.length; i++){<br>    console.log(array[i])<br>}<br>//高阶函数<br>let array = [1,2,3,4]<br>forEach(array,(item)=&gt;{<br>    consle.log(item)<br>})<br>//这里是过滤<br>let r = filter(array,(item)=&gt;{<br>    return item % 2 === 0<br>})<br></pre><br>总之我们发现，使用高阶函数能让我们的函数变得很灵活，抽象可以帮助我们屏蔽实现的细节，以后再调用函数，只需要关注我们实现的目标就可以了<br>8.常用的高阶函数<br>模拟常用高阶函数map/every/some<br>8-1.map</p>
<p><pre><br>//这里用const定义是因为我们不希望在我们写好之后被别人修改<br>const map = (array,fn)=&gt;{<br>    let results = []<br>    for(let value of array){<br>        results.push(fn(value))<br>    }<br>    return results<br>}<br>//测试<br>let arr = [1,2,3,4]<br>arr = map(arr,(v)=&gt;v*v)<br>console.log(arr)<br></pre><br>8-2.every</p>
<p><pre><br>const every = (array,fn)=&gt;{<br>    let result = true;<br>    for(let value of array){<br>        result = fn(value)<br>        if(!result){<br>            break;<br>        }<br>    }<br>    return result<br>}<br>//测试<br>let arr = [11,12,14]<br>let r = every(arr,v=&gt; v &gt; 10)<br>console.log(r)<br></pre><br>8-3.some</p>
<p><pre><br>const some = (array,fn)=&gt;{<br>    let result = false;<br>    for(let value of array){<br>        result = fn(value)<br>        if(result){<br>            break;<br>        }<br>    }<br>    return result<br>}<br>//测试<br>let arr = [1,3,4,9]<br>let r = some(arr,v=&gt;v%2===0)<br>console.log(r)<br></pre><br>9.闭包-概念<br>闭包(Closure):函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包。可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。<br>闭包的本质:函数在执行的时候会放到一个执行栈上，当函数执行完毕后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。<br>之前课程中的例子</p>
<p><pre><br>function makeFn(){<br>    let msg = ‘Hello function’;<br>    return function(){<br>        console.log(msg);<br>    }<br>}<br></pre><br>就能体现关于闭包的概念。一般情况下，在makeFn中定义的变量msg会随着makeFn在执行栈中执行完毕被移除，但是因为return了一个函数，所以makeFn内部的成员不会被移除，依然能访问外部函数。<br>闭包延长了内部函数的作用范围。<br>10.闭包-案例<br>比如我们经常需要求一个数的平方/立方，那么就会用到Math.pow(4,2)，而我们需要经常传递第二个参数为2/3，我们想简化这个过程，不需要经常传递2/3</p>
<p><pre><br>function makePower(power){<br>    return function(number){<br>        return Math.pow(number,power)<br>    }<br>}<br>//求平方<br>let power2 = makePower(2)<br>//求立方<br>let power3 = makePower(3)<br>//测试<br>console.log(power2(4))<br>console.log(power2(5))<br>console.log(power3(4))<br></pre><br>初步了解了闭包的例子，我们现在满足这样一个需求：求工资，也就是工资是由基本工资和绩效工资组成，每个职级的基本工资是固定的，但是绩效工资不一样，我们来求不同级别的员工生成工资的函数 </p>
<p><pre><br>function getSalary(base){<br>    //参数base为基本工资<br>    return function(performance){<br>        //参数performance为绩效工资<br>        return base + performance<br>    }<br>}<br>//测试<br>let getSalaryLevel1 = getSalary(12000)<br>let getSalaryLevel2 = getSalary(15000)<br>console.log(getSalaryLevel1(2000))<br>console.log(getSalaryLevel2(3000))<br></pre><br>在这节课程中，我们可以打开浏览器调试工具，在程序中打断点观察程序的执行过程，了解执行栈和作用域<br>11.纯函数概念<br>纯函数:相同的输入永远会得到相同的输出，而且没有任何可观察的副作用(后面的课程会讲什么是副作用)。纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，y=f(x)<br>lodash是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法。<br>数组的slice和splice分别是纯函数和不纯的函数:<br>·slice返回数组中指定部分，不会改变原数组<br>·splice对数组进行操作返回该数组，会改变原数组</p>
<p><pre><br>let array = [1,2,3,4,5]<br>//纯函数<br>console.log(array.slice(0,3))<br>console.log(array.slice(0,3))<br>console.log(array.slice(0,3))<br>//非纯函数<br>console.log(array.splice(0,3))<br>console.log(array.splice(0,3))<br>console.log(array.splice(0,3))<br></pre><br>执行之后我们发现slice和splice之间的区别，也就是纯函数和非纯函数之间的区别</p>
<p><pre><br>//纯函数<br>function getSum(n1,n2){<br>    return n1 + n2<br>}<br>console.log(getSum(1,2))<br>console.log(getSum(1,2))<br>console.log(getSum(1,2))<br></pre><br>对于getSum函数，我们每次输入1，2之后的输出结果都是相同的，也就是纯函数。举了简单例子来说明纯函数，后面我们将学习更多纯函数的用法。<br>函数式编程不会保留中间计算的结果，所以变量是不可变的(无状态的)<br>我们可以把一个函数的执行结果交给另一个函数去处理<br>12.lodash<br>lodash纯函数的代表<br>这个小节，我们会展示一些常用lodash的使用方法，我们可以用npm init -y初始化一个项目，并且安装lodash</p>
<p><pre><br>//first/last/toUpper/reverse/each/includes/find/findIndex<br>const _ = require(‘lodash’);<br>const array = [‘jack’,’tom’,’lucy’,’kate’];<br>console.log(<em>.first(array))<br>console.log(</em>.last(array))<br>console.log(<em>.toUpper(</em>.first(array)))<br>console.log(_.reverse(array))<br>const r = _.each(array,(item,index)=&gt;{<br>    console.log(item,index)<br>})<br>console.log(r)<br></pre><br>剩下的几个我们可以自己练习<br>13.纯函数的好处<br>纯函数的好处:<br>(1)可缓存:因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来<br>(2)可测试:纯函数让测试更方便<br>(3)并行处理:在多线程的环境下并行操作共享的内存数据很可能会出现意外的情况；纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数(Web Worker)<br>这里我们还是通过lodash的函数来演示，功能是求圆的面积</p>
<p><pre><br>const _ = require(‘lodash’);<br>function getArea(r){<br>    console.log(r);//这里的console.log是为了展示，并非功能<br>    return Math.PI<em>r</em>r<br>}<br>let getAreaWithMemory = _.memoize(getArea)<br>console.log(getAreaWithMemory(4))<br>console.log(getAreaWithMemory(4))<br>console.log(getAreaWithMemory(4))<br></pre><br>当我们执行上面的代码发现，getArea的参数只打印了一次，因为我们用了lodash的记忆函数。接下来我们模拟memoize这个方法的实现</p>
<p><pre><br>function memoize(f){<br>    let cache = {}<br>    return function(){<br>        let key = JSON.stringify(arguments)<br>        cache[key] = cache[key] || f.apply(f,arguments)<br>        return cache[key]<br>    }<br>}<br></pre><br>14.副作用<br>纯函数:对于相同的输入永远会得到相同的输出，而且没有任何可观察到副作用</p>
<p><pre><br>//不纯的<br>//本例中如果mini的值改变就会导致调用checkAge对相同的数值输出不同的结果<br>let mini = 18<br>function checkAge (age) {<br>    return age &gt;= mini<br>}<br>//纯的(有硬编码，后续可以通过柯里化解决)<br>function checkAge (age) {<br>    let mini = 18<br>    return age &gt;= mini<br>}<br></pre><br>副作用让一个函数变的不纯(如上例)，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。<br>副作用来源：<br>·配置文件<br>·数据库<br>·获取用户的输入<br>·……<br>所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。<br>15.柯里化(Haskell Brooks Curry)<br>在上一小节中，checkAge这个函数有一个硬编码的问题，这里我们用柯里化解决</p>
<p><pre><br>//有硬编码问题<br>function checkAge (age) {<br>    let mini = 18<br>    return age &gt;= mini<br>}<br>//改造为普通的纯函数<br>function checkAge (min,age) {<br>    return age &gt;= min<br>}<br>//测试<br>console.log(checkAge(18,20))<br>console.log(checkAge(18,24))<br>console.log(checkAge(22,24))<br>//改造为我们之前学的闭包函数<br>function checkAge(min){<br>    return function(age){<br>        return age &gt;= min<br>    }<br>}<br>//测试<br>let checkAge18 = checkAge(18)<br>let checkAge20 = checkAge(20)<br>console.log(checkAge18(20))<br>console.log(checkAge18(24))<br>//用箭头函数实现<br>let checkAge = min =&gt; (age =&gt; age &gt;= min)<br></pre><br>通过上面的改造我们可以大致了解柯里化的含义就是:当函数有多个参数的时候，我们可以对函数进行改造，我们可以调用一个函数只传递部分的参数并且让这个函数返回一个新的函数，新的函数接收剩余的参数，并且返回相应的结果。课程讲义里给的对于柯里化的总结是:<br>柯里化 (Currying)：<br>·当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）<br>·然后返回一个新的函数接收剩余的参数，返回结果<br>16.lodash中的柯里化方法</p>
<p><pre>_.curry(func)</pre><br>·功能：创建一个函数，该函数接收一个或多个func的参数，如果func所需要的参数都被提供则执行func并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。<br>·参数：需要柯里化的函数<br>·返回值：柯里化后的函数</p>
<p><pre><br>//将多元(多个参数)函数转换为一元(一个参数)的函数<br>const _ = require(‘lodash’)<br>function getSum (a, b, c) {<br>    return a + b + c<br>}<br>let curried = _.lodash(getSum)<br>//测试<br>console.log(curried(1, 2, 3))<br>console.log(curried(1)(2)(3))<br>console.log(curried(1, 2)(3))<br></pre><br>17.柯里化案例<br>我们现在有这样的需求<br>‘’.match(/\s+/g)<br>‘’.match(/\d+/g)<br>很明显我们这样写不是优雅的写法<br>于是我们想到用函数方式</p>
<p><pre><br>function match(reg,str){<br>    return str.match(reg)<br>}<br></pre><br>如果我们需要经常获取字符串中所有空白，那这个函数需要很多重复，于是我们想到柯里化函数，这里用lodash中的curry</p>
<p><pre><br>const _ = require(‘lodash’)<br>const match = _.curry(function(reg,str){<br>    return str.match(reg)<br>})<br>const haveSpace = match(/\s+/g)<br>const haveNumber = match(/\d+/g)<br>console.log(haveSpace(‘hello world’))<br>console.log(haveNumber(‘25$’))<br></pre><br>现在我们将filter封装为一个柯里化函数</p>
<p><pre><br>const filter = _.curry(function (func, array) {<br>    return array.filter(func)<br>})<br>console.log(filter(haveSpace, [‘John Connor’, ‘John_Donne’]))<br>//进一步改造<br>const findSpace = filter(haveSpace)<br>console.log(findSpace([‘John Connor’, ‘John_Donne’]))<br></pre><br>18.柯里化原理模拟</p>
<p><pre><br>//const _ = require(‘lodash’)<br>function getSum (a, b, c) {<br>    return a + b + c<br>}<br>//const curried = <em>.curry(getSum)//换成我们自己写的curry测试<br>const curried = curry(getSum)<br>function curry(func){<br>    return function curriedFn (…args){<br>        // 判断实参和形参的个数<br>        if(args.length &lt; func.length){<br>            return function (){<br>                return curriedFn(…args.concat(Array.from(arguments)))<br>            }<br>        }<br>        // 实参和形参个数相同，调用 func，返回结果<br>        return func(…args)<br>    }<br>}<br>console.log(curried(1)(2)(3))<br>console.log(curried(1)(2,3))<br>console.log(curried(1,2)(3))<br></em></pre><br>19.柯里化总结<br>·柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数<br>·这是一种对函数参数的’缓存’<br>·让函数变的更灵活，让函数的粒度更小<br>·可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能<br>20.函数组合概念<br>·纯函数和柯里化很容易写出洋葱代码 h(g(f(x)))<br> ·获取数组的最后一个元素再转换成大写字母<br> <pre>.toUpper(<em>.first(</em>.reverse(array)))</pre><br>·函数组合可以让我们把细粒度的函数重新组合生成一个新的函数<br>管道<br>下面这张图表示程序中使用函数处理数据的过程，给 fn 函数输入参数 a，返回结果 b。可以想想 a 数据通过一个管道得到了 b 数据。<br><img src="https://snakexu.github.io/images/lagou/part_1/20_1.png"><br>当 fn 函数比较复杂的时候，我们可以把函数 fn 拆分成多个小函数，此时多了中间运算过程产生的 m 和 n。<br>下面这张图中可以想象成把 fn 这个管道拆分成了3个管道 f1, f2, f3，数据 a 通过管道 f3 得到结果 m，m 再通过管道 f2 得到结果 n，n 通过管道 f1 得到最终结果 b。对比上面直接通过管道fn生成所要结果，在f1、f2、f3中如果发生问题，我们更容易定位问题位置。<br><img src="https://snakexu.github.io/images/lagou/part_1/20_2.png"><br>使用伪代码描述下上图</p>
<p><pre><br>fn = compose(f1, f2, f3) //在处理过程中f1，f2，f3会产生一些中间结果，我们忽视这些<br>b = fn(a)<br></pre><br>函数组合<br>·函数组合 (compose)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数<br> ·函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果<br> ·函数组合默认是从右到左执行</p>
<p><pre><br>//先假设我们需要一个两个函数组合的函数<br>function compose(f,g){<br>    return function(value){<br>        return f(g(value))<br>    }<br>}<br></pre><br>现在假设我们需要获取数组中最后一个元素，用先反转再获取到数组中第一个元素方法</p>
<p><pre><br>//反转<br>function reverse(array){<br>    return array.reverse()<br>}<br>function first(array){<br>    return array[0]<br>}<br>const last = compose(first,reverse)<br>console.log(last([1,2,3,4]))<br></pre><br>21.lodash中的组合函数<br>·lodash 中组合函数 flow() 或者 flowRight()，他们都可以组合多个函数<br>·flow() 是从左到右运行<br>·flowRight() 是从右到左运行，使用的更多一些</p>
<p><pre><br>const _ = require(‘lodash’)<br>const toUpper = s =&gt; s.toUpperCase()<br>const reverse = arr =&gt; arr.reverse()<br>const first = arr =&gt; arr[0]<br>const f = _.flowRight(toUpper, first, reverse)<br>console.log(f([‘one’, ‘two’, ‘three’]))<br></pre><br>22.组合函数原理模拟</p>
<p><pre><br>// 多函数组合<br>function compose (…fns) {<br>    return function (value) {<br>        return fns.reverse().reduce(function (acc, fn) {<br>            return fn(acc)<br>        }, value)<br>    }<br>}<br>const toUpper = s =&gt; s.toUpperCase()<br>const reverse = arr =&gt; arr.reverse()<br>const first = arr =&gt; arr[0]<br>const f = compose(toUpper, first, reverse)<br>console.log(f([‘one’, ‘two’, ‘three’]))<br></pre><br>或者我们用箭头函数重写compose</p>
<p><pre><br>const compose = (…fns) =&gt; value =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), value)<br></pre><br>23.函数组合-结合律<br>函数的组合要满足结合律 (associativity)：<br>·我们既可以把 g 和 h 组合，还可以把 f 和 g 组合，结果都是一样的<br>用代码描述就是</p>
<p><pre><br>// 结合律（associativity）<br>let f = compose(f, g, h)<br>let associative = compose(compose(f, g), h) == compose(f, compose(g, h))<br>// true<br></pre><br>用lodash中的flowright来感受下</p>
<p><pre><br>const _ = require(‘lodash’)<br>//这里我们不再用自己写的函数了，而是用lodash<br>const f = <em>.flowRight(</em>.toUpper, _.first, _.reverse)<br>const g = <em>.flowRight(</em>.flowRight(_.toUpper, _.first), _.reverse)<br>const h = <em>.flowRight(</em>.toUpper, <em>.flowRight(</em>.first, _.reverse))<br>console.log(f([‘one’, ‘two’, ‘three’])) // =&gt; THREE<br>console.log(g([‘one’, ‘two’, ‘three’])) // =&gt; THREE<br>console.log(h([‘one’, ‘two’, ‘three’])) // =&gt; THREE<br></pre><br>24.函数组合-调试<br>如何调试组合函数</p>
<p><pre><br>const f = <em>.flowRight(</em>.toUpper, _.first, _.reverse)<br>console.log(f([‘one’, ‘two’, ‘three’]))<br></pre><br>需求:NEVER SAY DIE -&gt; never-say-die</p>
<p><pre><br>//<em>.split与</em>.join都是有多个参数，而我们在函数组合的时候不能使用多个参数，于是我们略作修改<br>const split = <em>.curry((sep,str)=&gt;</em>.split(str,sep))//sep-分隔符，str-字符串<br>const join = <em>.curry((sep,array)=&gt;</em>.join(array,sep))<br>//打印下某个函数的执行结果<br>const log = v =&gt; {<br>    console.log(v)<br>    return v<br>}<br>//结果为n-e-v-e-r-,-s-a-y-,-d-i-e-<br>//const f = _.flowRight(join(‘-‘), _.toLower, split(‘ ‘))//发现结果并不是我们预期的<br>//查看中间某个过程的打印结果，这里打印的结果显示split之后的操作是符合我们预期的[“NEVER”,”SAY”,”DIE”]<br>//const f = _.flowRight(join(‘-‘), _.toLower, log, split(‘ ‘))<br>//发现了问题的所在，toLower把split分割成的数组转换为了字符串never,say,die<br>//const f = _.flowRight(join(‘-‘),log,  _.toLower, split(‘ ‘)<br>console.log(f(‘NEVER SAY DIE’))<br></pre><br>在上面代码中我们发现了问题，toLower函数将split分割的数组转化为了字符串，我们应该用map函数，即对数组进行操作</p>
<p><pre><br>const split = <em>.curry((sep,str)=&gt;</em>.split(str,sep))<br>const join = <em>.curry((sep,array)=&gt;</em>.join(array,sep))<br>const map = <em>.curry((fn,array)=&gt;</em>.map(array,fn))<br>//为了解决log打印结果不清晰的问题，我们改造log<br>// const log = v =&gt; {<br>//      console.log(v)<br>//      return v<br>// }<br>const trace = _.curry((tag, v) =&gt; {<br>    console.log(tag, v)<br>    return v<br>})<br>//const f = <em>.flowRight(join(‘-‘), map(</em>.toLower), split(‘ ‘)//已经满足我们的需求<br>//如果我们两次打印log，不能区分是哪个log打印<br>//const f = <em>.flowRight(join(‘-‘), log, map(</em>.toLower), log, split(‘ ‘)<br>const f = <em>.flowRight(join(‘-‘), trace(‘map 之后’), map(</em>.toLower), trace(‘split 之后’), split(‘ ‘))<br>console.log(f(‘NEVER SAY DIE’))<br></pre><br>25.lodash-fp模块<br>·lodash 的 fp 模块提供了实用的对函数式编程友好的方法<br>·提供了不可变 auto-curried iteratee-first data-last 的方法</p>
<p><pre><br>// lodash 模块<br>const _ = require(‘lodash’)<br>_.map([‘a’, ‘b’, ‘c’], _.toUpper)<br>// =&gt; [‘A’, ‘B’, ‘C’]<br>_.map([‘a’, ‘b’, ‘c’])<br>// =&gt; [‘a’, ‘b’, ‘c’]<br>_.split(‘Hello World’, ‘ ‘)<br>// lodash/fp 模块<br>const fp = require(‘lodash/fp’)<br>fp.map(fp.toUpper, [‘a’, ‘b’, ‘c’])<br>fp.map(fp.toUpper)([‘a’, ‘b’, ‘c’])<br>fp.split(‘ ‘, ‘Hello World’)<br>fp.split(‘ ‘)(‘Hello World’)<br></pre><br>我们看上面代码lodash中map方法是数据优先，函数滞后；当我们调用map方法只传递一个参数，会原封不动的返回这个参数数组。lodash的split方法也是，数据优先，函数滞后。<br>而lodash的fp模块函数优先，数据滞后。而如果给fp模块的map/split函数传递一个参数，会返回一个新的函数等待剩余的参数，说明在lodash中map/split都是柯里化的函数<br>我们上一节的需求:NEVER SAY DIE -&gt; never-say-die，为了满足需求我们做了很多操作，有了fp模块我们发现上一节的代码能精简很多</p>
<p><pre><br>const fp = require(‘lodash/fp’)<br>const f = fp.flowRight(fp.join(‘-‘), fp.map(_.toLower), fp.split(‘ ‘))<br>console.log(f(‘NEVER SAY DIE’))<br></pre><br>26.lodash-map方法的小问题</p>
<p><pre><br>//lodash和lodash/fp模块中map方法的区别<br>const _ = require(‘lodash’)<br>//把一个字符串数组中的所有元素都转换为整数<br>console.log(_.map([‘23’,’8’,’10’],parseInt))//打印结果[23,NaN,2]<br></pre><br>上面代码为什么没有得到我们想要的结果，我们要分析下parseInt(要被解析的字符串,要解析的数字的基数。该值介于 2 ~ 36 之间)，在上面函数执行过程中分别执行了<br>parseInt(‘23’,0,array)//这里需要了解下lodash的map函数的参数<br>parseInt(‘8’,1,array)<br>parseInt(‘10’,2,array)<br>也就不难理解了，23转换为0进制，程序理解为十进制，于是是23；8转换为1进制是不包含在2～36中的，于是为NaN；10转换为2进制就是2。如果要解决这个问题，我们需要自己封装一个parseInt来替代lodash中的parseInt，而lodash/fp中的map就不会出现这个问题</p>
<p><pre><br>const fp = require(‘lodash/fp’);<br>console.log(fp.map(parseInt,[‘23’,’8’,’10’]))//是我们预期的[23,8,10]<br></pre><br>27.Pointfree<br>Point Free：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参<br>数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。<br>·不需要指明处理的数据<br>·只需要合成运算过程<br>·需要定义一些辅助的基本运算函数·</p>
<p><pre><br>//我们之前的课程中的案例<br>const f = fp.flowRight(fp.join(‘-‘), fp.map(_.toLower), fp.split(‘ ‘))<br></pre><br>案例演示</p>
<p><pre><br>// 非 Point Free 模式<br>// Hello World =&gt; hello_world<br>function f (word) {<br>    return word.toLowerCase().replace(/\s+/g, ‘<em>‘);<br>}<br>// Point Free<br>const fp = require(‘lodash/fp’)<br>const f = fp.flowRight(fp.replace(/\s+/g, ‘</em>‘), fp.toLower)<br>console.log(f(‘Hello World’))<br></pre><br>28.Pointfree-案例<br>案例需求:使用 Point Free 的模式，把单词中的首字母提取并转换成大写</p>
<p><pre><br>//world wild web =&gt; W.W.W<br>const fp = require(‘lodash/fp’)<br>//这里用了两次map，说起来是影响性能的<br>//const firstLetterToUpper = fp.flowRight(join(‘. ‘), fp.map(fp.first), fp.toUpper, fp.split(‘ ‘))<br>//于是我们对上面的代码进行修改，只用一次map<br>const firstLetterToUpper = fp.flowRight(join(‘. ‘), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(‘ ‘))<br>console.log(firstLetterToUpper(‘world wild web’))<br></pre><br>29.Functor(函子)<br>为什么要学函子<br>到目前为止已经已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。<br>什么是 Functor<br>·容器：包含值和值的变形关系(这个变形关系就是函数)<br>·函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理(变形关系)</p>
<p><pre><br>// 一个容器，包裹一个值<br>class Container {<br>    constructor(value){<br>        this._value = value//这个值是内部的，不对外公布<br>    }<br>    map(fn){//这个map方法对应函子的概念-该对象具有 map 方法<br>        return new Container(fn(this._value))<br>    }<br>}<br>let r = new Container(5).map(x =&gt; x+1 ).map(x =&gt; x*x )//每次调用map都返回一个新的函子对象<br>console.log(r) //Container {_value: 36 }<br></pre><br>上面代码，每次调用都需要new一下用起来不是很方便，我们进行调整修改</p>
<p><pre><br>// 一个容器，包裹一个值<br>class Container {<br>// of 静态方法，可以省略 new 关键字创建对象<br>    static of (value) {<br>        return new Container(value)<br>    }<br>    constructor (value) {<br>        this._value = value<br>    }<br>    // map 方法，传入变形关系，将容器里的每一个值映射到另一个容器<br>    map (fn) {<br>        return Container.of(fn(this._value))<br>    }<br>}<br>// 测试<br>let r = Container.of(3).map(x =&gt; x + 2).map(x =&gt; x * x)<br>console.log(r)<br></pre><br>30.Functor总结<br>·函数式编程的运算不直接操作值，而是由函子完成<br>·函子就是一个实现了 map 契约的对象<br>·我们可以把函子想象成一个盒子，这个盒子里封装了一个值<br>·想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理<br>·最终 map 方法返回一个包含新值的盒子（函子）</p>
<p><pre><br>// 值如果不小心传入了空值(副作用)<br>Container.of(null) .map(x =&gt; x.toUpperCase())<br>// TypeError: Cannot read property ‘toUpperCase’ of null<br></pre><br>对于纯函数，对于相同输入的值必须有相同的输出，这里用null报错，是函数的副作用，我们下一小节会想办法解决这个问题<br>31.MayBe函子<br>·我们在编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理<br>·MayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）</p>
<p><pre><br>class MayBe{<br>    static of (value) {<br>        return new MayBe(value)<br>    }<br>    constructor (value) {<br>        this._value = value<br>    }<br>    // 如果对空值变形的话直接返回 值为 null 的函子<br>    map (fn) {<br>        return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value))<br>    }<br>    isNothing () {<br>        return this._value === null || this._value === undefined<br>    }<br>}<br>// 传入具体值<br>MayBe.of(‘Hello World’) .map(x =&gt; x.toUpperCase())<br>// 传入 null 的情况<br>MayBe.of(null) .map(x =&gt; x.toUpperCase()) // =&gt; MayBe { _value: null }<br>MayBe.of(‘hello world’).map(x =&gt; x.toUpperCase()).map(x =&gt; null) .map(x =&gt; x.split(‘ ‘)) // =&gt; MayBe { _value: null }//这里体现的问题是，虽然我们解决了null报错的问题，但是我们依然不知道是哪里输入了有问题的值<br></pre><br>32.Either函子<br>·Either 两者中的任何一个，类似于 if…else…的处理<br>·异常会让函数变的不纯，Either 函子可以用来做异常处理</p>
<p><pre><br>class Left{<br>    static of (value) {<br>        return new Left(value)<br>    }<br>    constructor (value) {<br>        this._value = value<br>    }<br>    map (fn) {<br>        return this<br>    }<br>}<br>class Right{<br>    static of (value) {<br>        return new Right(value)<br>    }<br>    constructor (value) {<br>        this._value = value<br>    }<br>    map (fn) {<br>        return Right.of(fn(this._value))<br>    }<br>}<br>let r1 = Right.of(12).map(x =&gt; x+2)//Right{ _value: 14 }<br>let r1 = Left.of(12).map(x =&gt; x+2)//Left{ _value: 12 }<br>//直到上面代码，我们都还没有对错误信息作任何处理，接下来要开始处理错误信息<br>function parseJSON(json) {<br>    try {<br>        return Right.of(JSON.parse(json));<br>    } catch (e) {<br>        return Left.of({ error: e.message});<br>    }<br>}<br>let r3 = parseJSON(‘{ name: zs }’) // 报错<br>let r4 = parseJSON(‘{ “name”: “zs” }’).map(x =&gt; x.name.toUpperCase())<br>console.log(r4)<br></pre><br>33.IO函子<br>·IO 函子中的 _value 是一个函数，这里是把函数作为值来处理<br>·IO 函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作(惰性执行)，包装当前的操作纯<br>·把不纯的操作交给调用者来处理</p>
<p><pre><br>const fp = require(‘lodash/fp’)<br>class IO {<br>    static of (x) {<br>        return new IO(function () { return x })<br>    }<br>    constructor (fn) {<br>        this._value = fn<br>    }<br>    map (fn) {<br>        // 把当前的 value 和 传入的 fn 组合成一个新的函数，把副作用延迟到调用的时候<br>        return new IO(fp.flowRight(fn, this._value))<br>    }<br>}<br>// 调用<br>let io = IO.of(process).map(p =&gt; p.execPath)//process.execPath当前进程的执行路径<br>console.log(io) //IO { _value:[Function] }<br>onsole.log(io._value())//打印了当前进程的执行路径<br></pre><br>34.Falktale<br>·异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示<br>·folktale 一个标准的函数式编程库<br> ·和 lodash、ramda 不同的是，他没有提供很多功能函数<br> ·只提供了一些函数式处理的操作，例如：compose、curry 等，一些函子 Task、Either、MayBe 等</p>
<p><pre><br>const { compose, curry } = require(‘folktale/core/lambda’)<br>const { toUpper, first } = require(‘lodash/fp’)<br>// 第一个参数是传入函数的参数个数<br>let f = curry(2, function (x, y) {<br>    console.log(x + y)<br>})<br>f(3, 4) //7<br>f(3)(4) //7<br>// 函数组合<br>let f = compose(toUpper, first)<br>console.log(f([‘one’, ‘two’]))//ONE<br></pre><br>35.Task函子<br>Task 异步执行<br>·folktale(2.3.2) 2.x 中的 Task 和 1.0 中的 Task 区别很大，1.0 中的用法更接近我们现在演示的函子<br>·这里以 2.3.2 来演示</p>
<p><pre><br>const fs = require(‘fs’)<br>const { task } = require(‘folktale/concurrency/task’)<br>function readFile(filename) {<br>    return task(resolver =&gt; {<br>        fs.readFile(filename, ‘utf-8’, (err, data) =&gt; {<br>            if (err) resolver.reject(err)<br>            resolver.resolve(data)<br>        })<br>    })<br>}<br>// 调用 run 执行<br>readFile(‘package.json’)<br>.map(split(‘\n’))//获取package.json文件中的信息后按行分割成数组<br>.map(find(x =&gt; x.includes(‘version’)))//获取version信息<br>.run().listen({<br>    onRejected: err =&gt; {<br>        console.log(err)<br>    },<br>    onResolved: value =&gt; {<br>        console.log(value)<br>    }<br>})<br></pre><br>36.Pointed函子<br>·Pointed 函子是实现了 of 静态方法的函子<br>·of 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文Context（把值放到容器中，使用 map 来处理值）<br><img src="https://snakexu.github.io/images/lagou/part_1/36_1.png"></p>
<p><pre><br>//这里主要是介绍Pointed函子的概念，之前我们已经用过了<br>class Container {<br>    static of (value) {<br>        return new Container(value)<br>    }<br>    ……<br>}<br>Contanier.of(2) .map(x =&gt; x + 5)<br></pre><br>37.IO函子问题</p>
<p><pre><br>//这是我们之前内容的函子，我们用这个函子解决一个问题<br>//linux下cat命令是读取一个文件并打印出文件的内容<br>const fp = require(‘lodash/fp’)<br>const fs = require(‘fs’)<br>class IO {<br>    static of (x) {<br>        return new IO(function () { return x })<br>    }<br>    constructor (fn) {<br>        this._value = fn<br>    }<br>    map (fn) {<br>        return new IO(fp.flowRight(fn, this._value))<br>    }<br>}<br>let readFile = function(filename){<br>    //因为读取文件的时候会引起副作用让我们的函数变得不纯，所以延迟到执行的时候再调用<br>    return new IO(function(){<br>        return fs.readFileSync(filename,’utf-8’)<br>    })<br>}<br>let print = function(x){<br>    return new IO(function(){<br>        console.log(x)<br>        return x<br>    })<br>}<br>let cat = fp.flowRight(print, readFile)<br>let r1 = cat(‘package.json’)<br>console.log(r1)//IO { _value: [Function] }<br>let r2 = cat(‘package.json’)._value()._value()//这里嵌套函子的风格略显麻烦，下一节我们学习怎么修改<br>//r2才能拿到文件内容，第一个value把readFile的IO函子打印出来，<br></pre><br>38.Monad函子<br>·Monad 函子是可以变扁的 Pointed 函子，IO(IO(x))<br>·一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad</p>
<p><pre><br>const fp = require(‘lodash/fp’)<br>const fs = require(‘fs’)<br>class IO {<br>    static of (x) {<br>        return new IO(function () { return x })<br>    }<br>    constructor (fn) {<br>        this._value = fn<br>    }<br>    map (fn) {<br>        return new IO(fp.flowRight(fn, this._value))<br>    }<br>    //整个例子是上节课中的内容，这里我们略作修改，加入了join和flatMap<br>    join () {<br>        return this._value()<br>    }<br>    flatMap (fn) {<br>        return this.map(fn).join()<br>    }<br>}<br>let readFile = function(filename){<br>    return new IO(function(){<br>        return fs.readFileSync(filename,’utf-8’)<br>    })<br>}<br>let print = function(x){<br>    return new IO(function(){<br>        console.log(x)<br>        return x<br>    })<br>}<br>let r = readFile(‘package.json’).flatMap(print).join()//拿到了package.json中的内容<br></pre><br>假设在上面代码中，我们读完文件要继续处理文件，比如把拿出来字符串全部转换成大写，我们该如何做</p>
<p><pre><br>let r = readFile(‘package.json’).map(fp.toUpper).flatMap(print).join()<br></pre><br>39.总结</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/拉勾-函数式编程范式/" data-id="ckeeij38o005mjoxqlu8ef8wt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-拉勾-函数式编程范式-5-高阶函数-函数作为参数" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/拉勾-函数式编程范式-5-高阶函数-函数作为参数/" class="article-date">
  <time datetime="2020-06-14T09:53:08.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/拉勾-函数式编程范式-5-高阶函数-函数作为参数/">拉勾-函数式编程范式-5-高阶函数-函数作为参数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>高阶函数<br>什么是高阶函数(Higher-order function):可以把函数作为参数传递给另一个函数；可以把函数作为另一个函数的返回结果</p>
<pre>
//高阶函数，函数作为参数
function forEach(array,fn){
    for(let i = 0; i < array.length; i++){
        fn(array[i])
    }
}
//测试
let arr = [1,3,4,7,8]
forEach(arr,function(item){
    console.log(item)
})
</pre>
在node环境执行上面代码，依次打印出arr的每一项，这里我们也就了解了forEach的原理，接着我们来模拟filter
<pre>
//这里第二个参数为什么是fn(函数)，因为我们通常需要去过滤满足一定条件的数据
//而这个一定条件是不确定的，我们要让这个函数变得通用，那么函数就是很好的选择，我们在变化的位置传递一个函数
function filter(array,fn){
    let results = [];
    for(let i = 0; i < array.length; i++){
        if(fn(array[i])){
            results.push(array[i])
        }
    }
    return results
}
//测试
let arr = [1,3,4,7,8]
let r = filter(arr,function(item){
    return item % 2 === 0
})
console.log(r)
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/拉勾-函数式编程范式-5-高阶函数-函数作为参数/" data-id="ckeeij2zv000vjoxq4d4dg4wj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拉勾/">拉勾</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/拉勾/">拉勾</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾/">拉勾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业/">网易微专业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECMAScript新特性/" style="font-size: 10px;">ECMAScript新特性</a> <a href="/tags/JavaScript异步编程/" style="font-size: 10px;">JavaScript异步编程</a> <a href="/tags/TypeScript语言/" style="font-size: 10px;">TypeScript语言</a> <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/函数式编程范式/" style="font-size: 10px;">函数式编程范式</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/手写Promise源码/" style="font-size: 10px;">手写Promise源码</a> <a href="/tags/拉勾/" style="font-size: 20px;">拉勾</a> <a href="/tags/拉勾，自动化构建/" style="font-size: 10px;">拉勾，自动化构建</a> <a href="/tags/数据结构/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 17.5px;">算法</a> <a href="/tags/网易微专业/" style="font-size: 10px;">网易微专业</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/10/拉勾-Virtual-DOM-的实现原理/">拉勾-Virtual DOM 的实现原理</a>
          </li>
        
          <li>
            <a href="/2020/08/05/拉勾-模拟Vue-js响应式原理/">拉勾-模拟Vue.js响应式原理</a>
          </li>
        
          <li>
            <a href="/2020/08/03/拉勾-Vue-Router实现原理/">拉勾-Vue-Router实现原理</a>
          </li>
        
          <li>
            <a href="/2020/08/02/拉勾-Vue-js基础回顾/">拉勾-Vue.js基础回顾</a>
          </li>
        
          <li>
            <a href="/2020/07/29/拉勾-规范化标准/">拉勾-规范化标准</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>