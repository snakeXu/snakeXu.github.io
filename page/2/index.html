<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="喵小喵的窝">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="喵小喵的窝">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-网易微专业-jq源码解析-1107直播课源码" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/17/网易微专业-jq源码解析-1107直播课源码/" class="article-date">
  <time datetime="2019-11-17T09:54:35.000Z" itemprop="datePublished">2019-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/17/网易微专业-jq源码解析-1107直播课源码/">网易微专业-jq源码解析-1107直播课源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>html部分源码，请自行在html中调用，其中注释的汉字内容解释了链式回调的思路，即对</p>
<pre>
deferred[tuple[1]](function() {
    var returndefer = fn && fn.apply(this, arguments);
    if (returndefer && jQuery.isFunction(returndefer.promise)) {
         returndefer.done(newdefer.resolve)
                    .fail(newdefer.reject)
                    .progress(newdefer.notify);
    }
});
</pre>
这段内容中if判断执行的解释
<pre>
/*
    var obj = {};
    var callList = $.callbacks();  // 队列
    callList.add(function(name){
        console.log(this)
    });
    callList.add(function(name){
        console.log(2+"name")
    });

    callList.fireWith(obj);
    */


    var wait = function(src) {
        var der = jQuery.Deferred();
        var img = document.getElementsByTagName("img")[0];

        img.onload = function() {
            der.resolve("加载成功1122333");    //权限 绑定状态   done  fail ...
        }
        img.src = src;
        return der.promise(); //状态凝固   promise
    }

    /*
    $.when(wait("index.jpg")).done(function(message){
        console.log(message)     //this  === der
    });
    */

   //新的 Deferred 对象, 链式调用     
   wait("index.jpg").then(function(message){
       var der = jQuery.Deferred();
       der.resolve("又是一个Deferred对象");
       return der.promise();  //权限
   }).then(function(message){
       console.log(message)
   });


  /*
  then方法返回的是一个新的Deferred实例

  wait("index.jpg")   
  有了一个Deferred对象  =>der  
  状态   resolve
  队列中的callback呢？
  then(function(message){
                 console.log(message)
  })



  返回的是一个新的Deferred实例
  */ 


  /*
  then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。

  第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。
  如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。
  */

  //异步操作  开始  -  结束 -> 状态 成功  | 失败   做什么?   队列里面的callback
</pre><br>
js部分源码
<pre>
/*
 * @Author: Administrator
 * @Date:   2018-10-30 20:40:51
 * @Last Modified by:   Administrator
 * @Last Modified time: 2018-11-01 22:10:22
 */
(function(root) {
    var testExp = /^\s*(<[\w\w]+>)[^>]*$/;
    var rejectExp = /^<(\w+)\s*\ ?="">(?:<\ \1="">|)$/;
    var version = "1.0.1";
    var optionsCache = {};
    var jQuery = function(selector, context) {
        return new jQuery.prototype.init(selector, context);
    }

    jQuery.fn = jQuery.prototype = { //原型对象
        length: 0,
        jquery: version,
        selector: "",
        init: function(selector, context) {
            context = context || document;
            var match, elem, index = 0;
            //$()  $(undefined)  $(null) $(false)  
            if (!selector) {
                return this;
            }

            if (typeof selector === "string") {
                if (selector.charAt(0) === "<" &&="" selector.charat(selector.length="" -="" 1)="==" "="">" && selector.length >= 3) {
                    match = [selector]
                }
                //创建DOM
                if (match) {
                    //this  
                    jQuery.merge(this, jQuery.parseHTML(selector, context));
                    //查询DOM节点
                } else {
                    elem = document.querySelectorAll(selector);
                    var elems = Array.prototype.slice.call(elem);
                    this.length = elems.length;
                    for (; index < elems.length; index++) {
                        this[index] = elems[index];
                    }
                    this.context = context;
                    this.selector = selector;
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }

        },
        css: function() {
            console.log("di~~didi~~")
        },
        //....
    }

    jQuery.fn.init.prototype = jQuery.fn;


    //克隆    架构    jQuery.extend({}, obj1, obj2);   以默认配置为优先 以用户配置为覆盖
    jQuery.extend = jQuery.prototype.extend = function() {
        var target = arguments[0] || {};
        var length = arguments.length;
        var i = 1;
        var deep = false; //默认为浅拷贝 
        var option;
        var name;
        var copy;
        var src;
        var copyIsArray;
        var clone;

        if (typeof target === "boolean") {
            deep = target;
            target = arguments[1];
            i = 2;
        }

        if (typeof target !== "object") {
            target = {};
        }

        if (length == i) {
            target = this;
            i--; //0   
        }

        for (; i < length; i++) {
            if ((option = arguments[i]) !== null) {
                for (name in option) {
                    src = target[name];
                    copy = option[name];
                    if (deep && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    }


    jQuery.extend({
        //类型检测     
        isPlainObject: function(obj) {
            return typeof obj === "object";
        },

        isArray: function(obj) {
            return toString.call(obj) === "[object Array]";
        },

        isFunction: function(fn) {
            return toString.call(fn) === "[object Function]";
        },
        //类数组转化成正真的数组  
        markArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
            }
            return ret;
        },

        //合并数组
        merge: function(first, second) {
            var l = second.length,
                i = first.length,
                j = 0;

            if (typeof l === "number") {
                for (; j < l; j++) {
                    first[i++] = second[j];
                }
            } else {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }

            first.length = i;

            return first;
        },

        parseHTML: function(data, context) {
            if (!data || typeof data !== "string") {
                return null;
            }
            //过滤掉<a>   <a>   => a 
            var parse = rejectExp.exec(data);
            console.log(parse)
            return [context.createElement(parse[1])];
        },

        //$.Callbacks用于管理函数队列
        callbacks: function(options) {
            options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : {};
            var list = [];
            var index, length, testting, memory, start, starts;
            var fire = function(data) {
                memory = options.memory && data;
                index = starts || 0;
                starts = 0;
                testting = true;
                length = list.length;
                for (; index < length; index++) {
                    if (list[index].apply(data[0], data[1]) === false && options.stopOnfalse) {
                        break;
                    }
                }
            }
            var self = {
                add: function() {
                    var args = Array.prototype.slice.call(arguments);
                    start = list.length;
                    args.forEach(function(fn) {
                        if (toString.call(fn) === "[object Function]") {
                            list.push(fn);
                        }
                    });
                    if (memory) {
                        starts = start;
                        fire(memory);
                    }
                    return this;
                },
                //指定上下文对象     resolve(object,"操作成功")  fireWith()
                fireWith: function(context, arguments) {
                    var args = [context, arguments];
                    if (!options.once || !testting) {
                        fire(args);
                    }

                },
                //参数传递
                fire: function() {
                    self.fireWith(this, arguments);
                }
            }
            return self;
        },

        // 异步回调解决方案
        Deferred: function(func) {
            var tuples = [
                    ["resolve", "done", jQuery.callbacks("once memory"), "resolved"],
                    ["reject", "fail", jQuery.callbacks("once memory"), "rejected"],
                    ["notify", "progress", jQuery.callbacks("memory")]
                ],
                state = "pending",
                //promise   权限分配  add   添加callback
                promise = {
                    state: function() {
                        return state;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {
                        var fns = [].slice.call(arguments); //真正数组对象
                        //创建一个Deferred 延迟对象  返回一个promise对象
                        return jQuery.Deferred(function(newdefer) {
                            tuples.forEach(function(tuple, i) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                /*
                                deferred   通过闭包去访问  此处链接式调用时指向的deferred对象
                                newdefer   通过参数传递    指向新创建的deferred对象
                                */
                                //resolve  队列中的 callback
                                deferred[tuple[1]](function() {
                                    var returndefer = fn && fn.apply(this, arguments);
                                    if (returndefer && jQuery.isFunction(returndefer.promise)) {
                                         //console.log(newdefer)
                                         returndefer.done(newdefer.resolve)
                                                    .fail(newdefer.reject)
                                                    .progress(newdefer.notify);
                                    }
                                });

                            })
                        }).promise();
                    },
                    promise: function(obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};

            tuples.forEach(function(tuple, i) {
                var list = tuple[2],
                    stateString = tuple[3];

                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;
                    });
                }

                // deferred[ resolve | reject | notify ]  der.resolve("加载成功");    
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            //新创建的deferred 对象
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        //执行一个或多个对象的延迟对象的回调函数
        when: function(subordinate) {
            return subordinate.promise();
        },

    });

    function createOptions(options) {
        var object = optionsCache[options] = {};
        options.split(/\s+/).forEach(function(value) {
            object[value] = true;
        });
        return object;
    }

    root.$ = root.jQuery = jQuery;
})(this);
</a></a></"></\></(\w+)\s*\></[\w\w]+></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/17/网易微专业-jq源码解析-1107直播课源码/" data-id="ck3e9zcon000jntxqa2skwro6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-jq源码解析-事件绑定-自定义事件-模拟事件-完整源码" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/16/网易微专业-jq源码解析-事件绑定-自定义事件-模拟事件-完整源码/" class="article-date">
  <time datetime="2019-11-16T11:04:15.000Z" itemprop="datePublished">2019-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/16/网易微专业-jq源码解析-事件绑定-自定义事件-模拟事件-完整源码/">网易微专业-jq源码解析-事件绑定-自定义事件&amp;模拟事件-完整源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre>
/*
 * @Author: Administrator
 * @Date:   2018-10-30 20:40:51
 * @Last Modified by:   Administrator
 * @Last Modified time: 2018-11-01 22:10:22
 */
(function(root) {
    var testExp = /^\s*(<[\w\w]+>)[^>]*$/;
    var rejectExp = /^<(\w+)\s*\ ?="">(?:<\ \1="">|)$/;
    var core_version = "1.0.1";
    var optionsCache = {};

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    //activeElement 属性返回文档中当前获得焦点的元素。
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }

    var jQuery = function(selector, context) {
        return new jQuery.prototype.init(selector, context);
    }

    jQuery.fn = jQuery.prototype = { //原型对象
        length: 0,
        jquery: core_version,
        selector: "",
        init: function(selector, context) {
            context = context || document;
            var match, elem, index = 0;
            //$()  $(undefined)  $(null) $(false)  
            if (!selector) {
                return this;
            }

            if (typeof selector === "string") {
                if (selector.charAt(0) === "<" &&="" selector.charat(selector.length="" -="" 1)="==" "="">" && selector.length >= 3) {
                    match = [selector]
                }
                //创建DOM
                if (match) {
                    //this  
                    jQuery.merge(this, jQuery.parseHTML(selector, context));
                    //查询DOM节点
                } else {
                    elem = document.querySelectorAll(selector);
                    var elems = Array.prototype.slice.call(elem);
                    this.length = elems.length;
                    for (; index < elems.length; index++) {
                        this[index] = elems[index];
                    }
                    this.context = context;
                    this.selector = selector;
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }

        },
        css: function() {
            console.log("di~~didi~~")
        },
        //....
    }

    jQuery.fn.init.prototype = jQuery.fn;


    jQuery.extend = jQuery.prototype.extend = function() {
        var target = arguments[0] || {};
        var length = arguments.length;
        var i = 1;
        var deep = false; //默认为浅拷贝 
        var option;
        var name;
        var copy;
        var src;
        var copyIsArray;
        var clone;

        if (typeof target === "boolean") {
            deep = target;
            target = arguments[1];
            i = 2;
        }

        if (typeof target !== "object") {
            target = {};
        }

        if (length == i) {
            target = this;
            i--; //0   
        }

        for (; i < length; i++) {
            if ((option = arguments[i]) !== null) {
                for (name in option) {
                    src = target[name];
                    copy = option[name];
                    if (deep && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    }


    jQuery.extend({
        expando: "jQuery" + (core_version + Math.random()).replace(/\D/g, ""),
        guid: 1, //计数器
        now: Date.now, //返回当前时间距离时间零点(1970年1月1日 00:00:00 UTC)的毫秒数
        //类型检测     
        isPlainObject: function(obj) {
            return typeof obj === "object";
        },

        isArray: function(obj) {
            return toString.call(obj) === "[object Array]";
        },

        isFunction: function(fn) {
            return toString.call(fn) === "[object Function]";
        },
        //类数组转化成正真的数组  
        markArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
            }
            return ret;
        },

        //合并数组
        merge: function(first, second) {
            var l = second.length,
                i = first.length,
                j = 0;

            if (typeof l === "number") {
                for (; j < l; j++) {
                    first[i++] = second[j];
                }
            } else {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }

            first.length = i;

            return first;
        },

        parseHTML: function(data, context) {
            if (!data || typeof data !== "string") {
                return null;
            }
            //过滤掉< a >   < a >   => a 
            var parse = rejectExp.exec(data);
            console.log(parse)
            return [context.createElement(parse[1])];
        },

        //$.Callbacks用于管理函数队列
        callbacks: function(options) {
            options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : {};
            var list = [];
            var index, length, testting, memory, start, starts;
            var fire = function(data) {
                memory = options.memory && data;
                index = starts || 0;
                start = 0;
                testting = true;
                length = list.length;
                for (; index < length; index++) {
                    if (list[index].apply(data[0], data[1]) === false && options.stopOnfalse) {
                        break;
                    }
                }
            }
            var self = {
                add: function() {
                    var args = Array.prototype.slice.call(arguments);
                    start = list.length;
                    args.forEach(function(fn) {
                        if (toString.call(fn) === "[object Function]") {
                            list.push(fn);
                        }
                    });
                    if (memory) {
                        starts = start;
                        fire(memory);
                    }
                    return this;
                },
                //指定上下文对象
                fireWith: function(context, arguments) {
                    var args = [context, arguments];
                    if (!options.once || !testting) {
                        fire(args);
                    }

                },
                //参数传递
                fire: function() {
                    self.fireWith(this, arguments);
                }
            }
            return self;
        },

        // 异步回调解决方案
        Deferred: function(func) {
            var tuples = [
                    ["resolve", "done", jQuery.callbacks("once memory"), "resolved"],
                    ["reject", "fail", jQuery.callbacks("once memory"), "rejected"],
                    ["notify", "progress", jQuery.callbacks("memory")]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {},
                    promise: function(obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};

            tuples.forEach(function(tuple, i) {
                var list = tuple[2],
                    stateString = tuple[3];

                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;
                    });
                }

                // deferred[ resolve | reject | notify ]
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            return deferred;
        },
        //执行一个或多个对象的延迟对象的回调函数
        when: function(subordinate) {
            return subordinate.promise();
        },

        /*
         object   目标源
         callback  回调函数
         args     自定义回调函数参数
         */
        each: function(object, callback, args) {
            //object  数组对象 || object对象 
            var length = object.length;
            var name, i = 0;

            // 自定义callback 参数
            if (args) {
                if (length === undefined) {
                    for (name in object) {
                        callback.apply(object, args);
                    }
                } else {
                    for (; i < length;) {
                        callback.apply(object[i++], args);
                    }
                }
            } else {
                if (length === undefined) {
                    for (name in object) {
                        callback.call(object, name, object[name]);
                    }
                } else {
                    for (; i < length;) {
                        callback.call(object[i], i, object[i++]);
                    }
                }
            }
        },

    });

    function Data() {
        //jQuery.expando是jQuery的静态属性,对于jQuery的每次加载运行期间时唯一的随机数
        this.expando = jQuery.expando + Math.random();
        this.cache = {};
    }

    Data.uid = 1;

    Data.prototype = {
        key: function(elem) {
            var descriptor = {},
                unlock = elem[this.expando];

            if (!unlock) {
                unlock = Data.uid++;
                descriptor[this.expando] = { //钥匙
                    value: unlock
                };
                //方法直接在一个对象上定义一个或多个新的属性或修改现有属性,并返回该对象。
                //DOM   =>  jQuery101089554822917892030.7449198463843298 = 1;
                Object.defineProperties(elem, descriptor);
            }
            //确保缓存对象记录信息
            if (!this.cache[unlock]) {
                this.cache[unlock] = {}; //  数据
            }

            return unlock;
        },

        get: function(elem, key) {
            //找到或者创建缓存
            var cache = this.cache[this.key(elem)]; //1  {events:{},handle:function(){}} 
            //key 有值直接在缓存中取读
            return key === undefined ? cache : cache[key];
        },
    }

    var data_priv = new Data();




    //jQuery 事件模块
    jQuery.event = {
        //1:利用 data_priv 数据缓存,分离事件与数据 2:元素与缓存中建立 guid 的映射关系用于查找 
        add: function(elem, type, handler) {
            var eventHandle, events, handlers;
            //事件缓存 数据对象
            var elemData = data_priv.get(elem);


            //检测handler是否存在ID(guid)如果没有那么传给他一个ID
            //添加ID的目的是 用来寻找或者删除相应的事件
            if (!handler.guid) {
                handler.guid = jQuery.guid++; //guid == 1
            }
            /*
            给缓存增加事件处理句柄
            elemData = {
              events:
              handle:    
            }
            */
            //同一个元素,不同事件,不重复绑定    {events:{}}
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                //Event 对象代表事件的状态 通过apply传递
                eventHandle = elemData.handle = function(e) {
                    return jQuery.event.dispatch.apply(eventHandle.elem, arguments);
                }
            }
            eventHandle.elem = elem;
            //通过events存储同一个元素上的多个事件   {events:{click:[]}}   
            if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0; //有多少事件代理默认0
            }
            handlers.push({
                type: type,
                handler: handler,
                guid: handler.guid,
            });
            //添加事件
            if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle, false);
            }
        },

        //修复事件对象event 从缓存体中的events对象取得对应队列。
        dispatch: function(event) {
            //IE兼容性处理如：event.target or event.srcElement
            //event = jQuery.event.fix(event);

            //提取当前元素在cache中的events属性值。 click
            var handlers = (data_priv.get(this, "events") || {})[event.type] || [];
            event.delegateTarget = this;
            var args = [].slice.call(arguments);

            //执行事件处理函数
            jQuery.event.handlers.call(this,handlers, args);
        },

        //执行事件处理函数
        handlers: function(handlers, args) {   //[event , 自定义参数]
            handlers[0].handler.apply(this, args);
        },

        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy,
                type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[type];

            if (!fixHook) {
                this.fixHooks[type] = fixHook =
                    rmouseEvent.test(type) ? this.mouseHooks :
                    rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

            event = new jQuery.Event(originalEvent);

            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }

            // Support: Cordova 2.5 (WebKit) (#13255)
            // All events should have a target; Cordova deviceready doesn't
            if (!event.target) {
                event.target = document;
            }

            // Support: Safari 6.0+, Chrome < 28
            // Target should not be a text node (#504, #13143)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {
                // 执行默认focus方法
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        //console.log( this.focus)
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },

                // For cross-browser consistency, don't fire native .click() on links
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },

            beforeunload: {
                postDispatch: function(event) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },

        //event:  规定指定元素上要触发的事件,可以是自定义事件,或者任何标准事件。
        //data:  传递到事件处理程序的额外参数。
        //elem:  Element对象
        trigger: function(event, data, elem) {
            var i, cur, tmp, bubbleType, ontype, handle,
                i = 0,
                eventPath = [elem || document], //规划冒泡路线
                type = event.type || event,
                cur = tmp = elem = elem || document,
                //证明是ontype绑定事件
                ontype = /^\w+$/.test(type) && "on" + type;

            //模拟事件对象    如果有jQuery.expando说明event已经是模拟的事件对象
            event = event[jQuery.expando] ?
                event :
                new jQuery.Event(type, typeof event === "object" && event);
            //console.log(event);

            //定义event.target 属性
            if (!event.target) {
                event.target = elem;
            }
            //如果没有传入了参数,就把event存储在数组中 有传递合并数组
            //如之前所看到：data可选,传递到事件处理程序的额外参数。注意:事件处理程序第一个参数默认是event(此为出处)
            data = data == null ? [event] :
                jQuery.markArray(data, [event]);

            //事件类型是否需要进行特殊化处理   focus
            special = jQuery.event.special[type] || {};
            //如果事件类型已经有trigger方法，就调用它
            if (special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            //自己已经在冒泡路线中 不重复添加
            cur = cur.parentNode;
            //查找当前元素的父元素 添加到eventPath (规划冒泡路线)数组中
            for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
            }

            if (tmp === (elem.ownerDocument || document)) { //当tmp为document时,cur为空,就退出循环
                eventPath.push(tmp.defaultView || tmp.parentWindow || window); //模拟冒泡到window对象
            }
            //console.log(eventPath);

            //沿着上面规划好的冒泡路线，把经过的元素节点的指定类型事件的回调逐一触发执行
            while ((cur = eventPath[i++])) {
                //先判断在缓存系统中是否有此元素绑定的此事件类型的回调方法，如果有，就取出来    
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                if (handle) {
                    console.log(handle)
                    handle.apply(cur, data);
                }
            }
        },
    }

    //模拟Event对象
    jQuery.Event = function(src, props) {
        //创建一个jQuery.Event实例对象
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        //事件类型
        this.type = src;
        // 如果传入事件没有时间戳，则创建时间戳
        this.timeStamp = src && src.timeStamp || jQuery.now();
        // jQuery.Event实例对象标记
        this[jQuery.expando] = true;
    }

    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        //取消事件的默认动作
        preventDefault: function() {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if (e && e.preventDefault) {
                e.preventDefault();
            }
        },
        // 方法阻止事件冒泡到父元素,阻止任何父事件处理程序被执行。
        stopPropagation: function() {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if (e && e.stopPropagation) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        }
    };

    jQuery.fn.extend({
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },

        on: function(types, fn) {
            var type;
            if (typeof types === "object") {
                for (type in types) {
                    this.on(types[type], fn);
                }
            }
            return this.each(function() {
                //this  element对象
                jQuery.event.add(this, types, fn);
            });
        },
        //语法: data可选,传递到事件处理程序的额外参数。  注意:事件处理程序第一个参数默认是event
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
    })

    function createOptions(options) {
        var object = optionsCache[options] = {};
        options.split(/\s+/).forEach(function(value) {
            object[value] = true;
        });
        return object;
    }

    root.$ = root.jQuery = jQuery;
})(this);
</"></\></(\w+)\s*\></[\w\w]+></pre>
html部分测试代码：
<pre>
< input id="input" />
< div id="box">
< script src="jQuery.1.0.2.js">
< script>
    //event  模拟事件对象  name 自定义参数
    $("#box").on("createEvent", function(event, name) {
        console.log(name)
        console.log("loading...");
    })
    $("body").on("createEvent", function(event, name) {
        console.log("loading...");
    })

    //event
    $("#box").trigger("createEvent", "max");


    //执行浏览器默认事件  相当于执行了原生onfocus事件(怎么做到的)？
//             $('input').on('focus',function(){
//                 console.log("loading...");
//             });
// 
//               $('input').trigger('focus');
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/16/网易微专业-jq源码解析-事件绑定-自定义事件-模拟事件-完整源码/" data-id="ck3e9zcoz000ontxq0ud31g9d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-jq源码解析-2-5-3-事件绑定-自定义事件-模拟事件" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/15/网易微专业-jq源码解析-2-5-3-事件绑定-自定义事件-模拟事件/" class="article-date">
  <time datetime="2019-11-15T08:36:58.000Z" itemprop="datePublished">2019-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/15/网易微专业-jq源码解析-2-5-3-事件绑定-自定义事件-模拟事件/">网易微专业-jq源码解析-2-5-3-事件绑定-自定义事件&amp;模拟事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、自定义事件设计&amp;模拟事件<br>1、自定义事件<br>说明:在实际开发中，或许原生的javascript事件或者jQuery事件不能满足开发的需求，这时候就需要我们自己编写相应的事件。<br>添加自定义事件：通过jQuery的bind()或者是on()方法，添加自定义事件如下代码，自定义了一个createEvent()事件<br>$(‘#id’).on(‘createEvent’,function(){<br>    console.log(“createEvent”)<br>});<br>触发自定义事件：通过jQuery的trigger()方法触发自定义事件createEvent。<br>$(‘#id’).trigger(“createEvent”)<br>2、模拟事件<br>trigger()方法触发事件后，会执行浏览器默认行为<br>比如：<br>$(‘input’).trigger(‘focus’)<br>以上代码不仅会触发input元素绑定的focus事件，还会使得input元素本身的到焦点(这是浏览器的默认行为)<br>如果只想触发绑定的focus事件，而不想执行浏览器的默认行为，可以使用另一种类似的方法triggerHandler()方法<br><br><br><br><br>源码分析</p>
<p><pre><br>jQuery.fn.extend({<br>    each: function(callback, args) {<br>        return jQuery.each(this, callback, args);<br>    },<br>    //增加trigger<br>    //语法: data可选,传递到事件处理程序的额外参数。  注意:事件处理程序第一个参数默认是event<br>    trigger: function(type, data) {<br>        return this.each(function() {<br>            jQuery.event.trigger(type, data, this);<br>        });<br>    },<br>})<br></pre><br>上面的调用和之前讲的jQuery.fn.on()是差不多的，下面是jQuery.event.trigger的源码</p>
<p><pre><br>//event:  规定指定元素上要触发的事件,可以是自定义事件,或者任何标准事件。<br>//data:  传递到事件处理程序的额外参数。<br>//elem:  Element对象<br>trigger: function(event, data, elem) {<br>    var i, cur, tmp, bubbleType, ontype, handle,<br>        i = 0,<br>        eventPath = [elem || document], //规划冒泡路线<br>        type = event.type || event,<br>        cur = tmp = elem = elem || document,<br>        //证明是ontype绑定事件<br>        ontype = /^\w+$/.test(type) &amp;&amp; “on” + type;<br>    //模拟事件对象    如果有jQuery.expando说明event已经是模拟的事件对象<br>    event = event[jQuery.expando] ?<br>        event :<br>        new jQuery.Event(type, typeof event === “object” &amp;&amp; event);<br>    //定义event.target 属性<br>    if (!event.target) {<br>        event.target = elem;<br>    }<br>    //如果没有传入了参数,就把event存储在数组中 有传递合并数组<br>    //如之前所看到：data可选,传递到事件处理程序的额外参数。注意:事件处理程序第一个参数默认是event(此为出处)<br>    data = data == null ? [event] :<br>        jQuery.markArray(data, [event]);<br>    //事件类型是否需要进行特殊化处理   focus<br>    special = jQuery.event.special[type] || {};<br>    //如果事件类型已经有trigger方法，就调用它<br>    if (special.trigger &amp;&amp; special.trigger.apply(elem, data) === false) {<br>        return;<br>    }<br>    //自己已经在冒泡路线中 不重复添加<br>    cur = cur.parentNode;<br>    //查找当前元素的父元素 添加到eventPath (规划冒泡路线)数组中<br>    for (; cur; cur = cur.parentNode) {<br>        eventPath.push(cur);<br>        tmp = cur;<br>    }<br>    if (tmp === (elem.ownerDocument || document)) { //当tmp为document时,cur为空,就退出循环<br>        eventPath.push(tmp.defaultView || tmp.parentWindow || window); //模拟冒泡到window对象<br>    }<br>    //沿着上面规划好的冒泡路线，把经过的元素节点的指定类型事件的回调逐一触发执行<br>    while ((cur = eventPath[i++])) {<br>        //先判断在缓存系统中是否有此元素绑定的此事件类型的回调方法，如果有，就取出来<br>        handle = (data_priv.get(cur, “events”) || {})[event.type] &amp;&amp; data_priv.get(cur, “handle”);<br>        if (handle) {<br>            console.log(handle)<br>            handle.apply(cur, data);<br>        }<br>    }<br>},<br></pre><br>我们注意到，上面代码调用了new jQuery.Event这个构造函数，那么，我们看一下这个构造函数</p>
<p><pre><br>//模拟Event对象<br>jQuery.Event = function(src, props) {<br>    //创建一个jQuery.Event实例对象<br>    if (!(this instanceof jQuery.Event)) {<br>        return new jQuery.Event(src, props);<br>    }<br>    //事件类型<br>    this.type = src;<br>    // 如果传入事件没有时间戳，则创建时间戳<br>    this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();<br>    // jQuery.Event实例对象标记<br>    this[jQuery.expando] = true;<br>}<br></pre><br>jQuery.event.special的代码,代码里有一个函数是safeActiveElement，代码实际内容<br></p>
<p>//activeElement 属性返回文档中当前获得焦点的元素。<br>function safeActiveElement() {<br>    try {<br>        return document.activeElement;<br>    } catch (err) {}<br>}</p>
<p><pre><br>special: {<br>    load: {<br>        // Prevent triggered image.load events from bubbling to window.load<br>        noBubble: true<br>    },<br>    focus: {<br>        // 执行默认focus方法<br>        trigger: function() {<br>            if (this !== safeActiveElement() &amp;&amp; this.focus) {<br>                //console.log( this.focus)<br>                this.focus();<br>                return false;<br>            }<br>        },<br>        delegateType: “focusin”<br>    },<br>    blur: {<br>        trigger: function() {<br>            if (this === safeActiveElement() &amp;&amp; this.blur) {<br>                this.blur();<br>                return false;<br>            }<br>        },<br>        delegateType: “focusout”<br>    },<br>    click: {<br>        // For checkbox, fire native event so checked state will be right<br>        trigger: function() {<br>            if (this.type === “checkbox” &amp;&amp; this.click &amp;&amp; jQuery.nodeName(this, “input”)) {<br>                this.click();<br>                return false;<br>            }<br>        },<br>        // For cross-browser consistency, don’t fire native .click() on links<br>        _default: function(event) {<br>            return jQuery.nodeName(event.target, “a”);<br>        }<br>    },<br>    beforeunload: {<br>        postDispatch: function(event) {<br>            // Support: Firefox 20+<br>            // Firefox doesn’t alert if the returnValue field is not set.<br>            if (event.result !== undefined) {<br>                event.originalEvent.returnValue = event.result;<br>            }<br>        }<br>    }<br>},<br></pre><br>这段源代码，个人有两个值得注意的地方，一是设置了常用事件，例如’click’,’focus’,’blur’等事件设置了默认trigger，每次执行代码的时候检测是不是默认事件，这种把常用事件trigger事件列好，对于代码的执行非常有益；第二点，记录了事件节点的父节点，使每次事件执行都能遵循事件冒泡的思想，而且每次执行的时候没，都会注意到window和document。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/15/网易微专业-jq源码解析-2-5-3-事件绑定-自定义事件-模拟事件/" data-id="ck3e9zcoc000gntxqpuy1397b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-轮询" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/15/轮询/" class="article-date">
  <time datetime="2019-11-15T07:49:30.000Z" itemprop="datePublished">2019-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/15/轮询/">轮询</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>轮询<br>概念<br>ajax 轮询的原理很简单，让浏览器间隔几秒就发送一次请求，询问服务器是否有新信息</p>
<p>代码</p>
<pre>
function showUnreadNews()  
{  
    $(document).ready(function() {  
        $.ajax({  
            type: "POST",  
            url: "unread_list.php",  
            dataType: "json",  
            success: function(data) {  
                alert(data);  
            }  
        });  
    });  
}  
setInterval('showUnreadNews()',5000);  //轮询执行，5000ms一次  
</pre>
长轮训
概念
原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型<br>

也就是说，客户端发起连接后<br>

如果没消息，就一直不返回Response给客户端，直到有消息才返回或超时<br>

返回完之后，客户端再次建立连接，周而复始，基于事件的触发，一个事件接一个事件<br>

代码
<pre>
function showUnreadNews()  
{  
    $.ajax({  
        type: "POST",  
        url: "unread_list.php",  
        dataType: "json",  
        success: function(data) {         
            //处理返回数据
            alert(data);
            //再次请求
            showUnreadNews();
        },
        complete:function(XMLHttpRequest,textStatus)
        {  
            if(textStatus=='timeout'){//判断是否超时
                showUnreadNews();//超时，重新请求
            }  
        }
    });   
}
</pre>
websocket<br>
概念<br>
WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。<br>

浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道, 两者之间就直接可以数据互相传送。 <br>

代码<br>
<pre>
var ws;

function WebSocketTest()
{
   if ("WebSocket" in window)
   {
      alert("您的浏览器支持 WebSocket!");

      // 打开一个 web socket
      ws = new WebSocket("ws://localhost:9998/echo");

      ws.onopen = function()
      {
         // Web Socket 已连接上，使用 send() 方法发送数据
         ws.send("发送数据");
         alert("数据发送中...");
      };

      ws.onmessage = function (evt) 
      { 
         var received_msg = evt.data;
         alert("数据已接收..." + received_msg);
      };
      ws.onerror = function (evt) {
          //出错
          alert(JSON.stringify(evt));
       }
      ws.onclose = function()
      { 
         // 关闭 websocket
         alert("连接已关闭..."); 
      };
   }
   else
   {
      // 浏览器不支持 WebSocket
      alert("您的浏览器不支持 WebSocket!");
   }
}

ws.close();//关闭连接
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/15/轮询/" data-id="ck3e9zcod000hntxq70x3e3xo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-jq源码解析-事件绑定-体系结构-完整源码" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/15/网易微专业-jq源码解析-事件绑定-体系结构-完整源码/" class="article-date">
  <time datetime="2019-11-15T06:24:11.000Z" itemprop="datePublished">2019-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/15/网易微专业-jq源码解析-事件绑定-体系结构-完整源码/">网易微专业-jq源码解析-事件绑定-体系结构-完整源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>完整代码：</p>
<pre>
(function(root) {
    var testExp = /^\s*(<[\w\w]+>)[^>]*$/;
    var rejectExp = /^<(\w+)\s*\ ?="">(?:<\ \1="">|)$/;
    var core_version = "1.0.1";
    var optionsCache = {};
    var jQuery = function(selector, context) {
        return new jQuery.prototype.init(selector, context);
    }

    jQuery.fn = jQuery.prototype = { //原型对象
        length: 0,
        jquery: core_version,
        selector: "",
        init: function(selector, context) {
            context = context || document;
            var match, elem, index = 0;
            //$()  $(undefined)  $(null) $(false)  
            if (!selector) {
                return this;
            }

            if (typeof selector === "string") {
                if (selector.charAt(0) === "<" &&="" selector.charat(selector.length="" -="" 1)="==" "="">" && selector.length >= 3) {
                    match = [selector]
                }
                //创建DOM
                if (match) {
                    //this  
                    jQuery.merge(this, jQuery.parseHTML(selector, context));
                    //查询DOM节点
                } else {
                    elem = document.querySelectorAll(selector);
                    var elems = Array.prototype.slice.call(elem);
                    this.length = elems.length;
                    for (; index < elems.length; index++) {
                        this[index] = elems[index];
                    }
                    this.context = context;
                    this.selector = selector;
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }

        },
        css: function() {
            console.log("di~~didi~~")
        },
        //....
    }

    jQuery.fn.init.prototype = jQuery.fn;


    jQuery.extend = jQuery.prototype.extend = function() {
        var target = arguments[0] || {};
        var length = arguments.length;
        var i = 1;
        var deep = false; //默认为浅拷贝 
        var option;
        var name;
        var copy;
        var src;
        var copyIsArray;
        var clone;

        if (typeof target === "boolean") {
            deep = target;
            target = arguments[1];
            i = 2;
        }

        if (typeof target !== "object") {
            target = {};
        }

        if (length == i) {
            target = this;
            i--; //0   
        }

        for (; i < length; i++) {
            if ((option = arguments[i]) !== null) {
                for (name in option) {
                    src = target[name];
                    copy = option[name];
                    if (deep && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    }


    jQuery.extend({
        expando: "jQuery" + (core_version + Math.random()).replace(/\D/g, ""),
        guid: 1, //计数器
        //类型检测     
        isPlainObject: function(obj) {
            return typeof obj === "object";
        },

        isArray: function(obj) {
            return toString.call(obj) === "[object Array]";
        },

        isFunction: function(fn) {
            return toString.call(fn) === "[object Function]";
        },
        //类数组转化成正真的数组  
        markArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
            }
            return ret;
        },

        //合并数组
        merge: function(first, second) {
            var l = second.length,
                i = first.length,
                j = 0;

            if (typeof l === "number") {
                for (; j < l; j++) {
                    first[i++] = second[j];
                }
            } else {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }

            first.length = i;

            return first;
        },

        parseHTML: function(data, context) {
            if (!data || typeof data !== "string") {
                return null;
            }
            //过滤掉< a>   < a>   => a 
            var parse = rejectExp.exec(data);
            console.log(parse)
            return [context.createElement(parse[1])];
        },

        //$.Callbacks用于管理函数队列
        callbacks: function(options) {
            options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : {};
            var list = [];
            var index, length, testting, memory, start, starts;
            var fire = function(data) {
                memory = options.memory && data;
                index = starts || 0;
                start = 0;
                testting = true;
                length = list.length;
                for (; index < length; index++) {
                    if (list[index].apply(data[0], data[1]) === false && options.stopOnfalse) {
                        break;
                    }
                }
            }
            var self = {
                add: function() {
                    var args = Array.prototype.slice.call(arguments);
                    start = list.length;
                    args.forEach(function(fn) {
                        if (toString.call(fn) === "[object Function]") {
                            list.push(fn);
                        }
                    });
                    if (memory) {
                        starts = start;
                        fire(memory);
                    }
                    return this;
                },
                //指定上下文对象
                fireWith: function(context, arguments) {
                    var args = [context, arguments];
                    if (!options.once || !testting) {
                        fire(args);
                    }

                },
                //参数传递
                fire: function() {
                    self.fireWith(this, arguments);
                }
            }
            return self;
        },

        // 异步回调解决方案
        Deferred: function(func) {
            var tuples = [
                    ["resolve", "done", jQuery.callbacks("once memory"), "resolved"],
                    ["reject", "fail", jQuery.callbacks("once memory"), "rejected"],
                    ["notify", "progress", jQuery.callbacks("memory")]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {},
                    promise: function(obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};

            tuples.forEach(function(tuple, i) {
                var list = tuple[2],
                    stateString = tuple[3];

                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;
                    });
                }

                // deferred[ resolve | reject | notify ]
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            return deferred;
        },
        //执行一个或多个对象的延迟对象的回调函数
        when: function(subordinate) {
            return subordinate.promise();
        },

        /*
         object   目标源
         callback  回调函数
         args     自定义回调函数参数
         */
        each: function(object, callback, args) {
            //object  数组对象 || object对象 
            var length = object.length;
            var name, i = 0;

            // 自定义callback 参数
            if (args) {
                if (length === undefined) {
                    for (name in object) {
                        callback.apply(object, args);
                    }
                } else {
                    for (; i < length;) {
                        callback.apply(object[i++], args);
                    }
                }
            } else {
                if (length === undefined) {
                    for (name in object) {
                        callback.call(object, name, object[name]);
                    }
                } else {
                    for (; i < length;) {
                        callback.call(object[i], i, object[i++]);
                    }
                }
            }
        },

    });
    /**
     * Data 构造函数
     * 是为jQuery缓存所创建的数据仓库
     * 存储当前元素的事件名称、处理函数、子元素、子元素的事件名称、子元素的处理函数
     */
    function Data() {
        //jQuery.expando是jQuery的静态属性,对于jQuery的每次加载运行期间时唯一的随机数
        this.expando = jQuery.expando + Math.random();
        this.cache = {};
        console.log(this.expando);
    }

    Data.uid = 1;

    Data.prototype = {
        key: function(elem) {
            var descriptor = {},
                unlock = elem[this.expando];

            if (!unlock) {
                unlock = Data.uid++;
                descriptor[this.expando] = {   //钥匙
                    value: unlock
                };
                //方法直接在一个对象上定义一个或多个新的属性或修改现有属性,并返回该对象。
                //DOM   =>  jQuery101089554822917892030.7449198463843298 = 1;
                Object.defineProperties(elem, descriptor);
            }
            //确保缓存对象记录信息
            if (!this.cache[unlock]) {
                this.cache[unlock] = {};   //  数据
            }

            return unlock;
        },

        get: function(elem, key) {
            //找到或者创建缓存
            var cache = this.cache[this.key(elem)];    //1  {events:{},handle:function(){}} 
            //key 有值直接在缓存中取读
            return key === undefined ? cache : cache[key];
        },
    }

    var data_priv = new Data();




    //jQuery 事件模块
    jQuery.event = {
        //1:利用 data_priv 数据缓存,分离事件与数据 2:元素与缓存中建立 guid 的映射关系用于查找 
        add: function(elem, type, handler) {
            var eventHandle, events,handlers;
            //事件缓存 数据对象
            var elemData = data_priv.get(elem);


            //检测handler是否存在ID(guid)如果没有那么传给他一个ID
            //添加ID的目的是 用来寻找或者删除相应的事件
            if (!handler.guid) {
                handler.guid = jQuery.guid++;   //guid == 1
            }
            /*
            给缓存增加事件处理句柄
            elemData = {
              events:
              handle:    
            }
            */
            //同一个元素,不同事件,不重复绑定    {events:{}}
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                //Event 对象代表事件的状态 通过apply传递
                eventHandle = elemData.handle = function(e) {
                    return jQuery.event.dispatch.apply(eventHandle.elem, arguments);
                }
            }
            eventHandle.elem = elem;
            //通过events存储同一个元素上的多个事件   {events:{click:[]}}   
            if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;  //有多少事件代理默认0
            }
            handlers.push({
                type: type,
                handler: handler,
                guid: handler.guid,
            });
            //添加事件
            if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle, false);
            }
        },

        //修复事件对象event 从缓存体中的events对象取得对应队列。
        dispatch: function(event) {
            //IE兼容性处理如：event.target or event.srcElement
            //event = jQuery.event.fix(event);

            //提取当前元素在cache中的events属性值。 click
            var handlers = (data_priv.get(this, "events") || {})[event.type] || [];
            console.log(handlers)
            event.delegateTarget = this;
            //执行事件处理函数
           jQuery.event.handlers.call( this, event, handlers );
        },

        //执行事件处理函数
        handlers: function( event, handlers ) {
            handlers[0].handler.call(this, event);
        },

        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy,
                type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[type];

            if (!fixHook) {
                this.fixHooks[type] = fixHook =
                    rmouseEvent.test(type) ? this.mouseHooks :
                    rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

            event = new jQuery.Event(originalEvent);

            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }

            // Support: Cordova 2.5 (WebKit) (#13255)
            // All events should have a target; Cordova deviceready doesn't
            if (!event.target) {
                event.target = document;
            }

            // Support: Safari 6.0+, Chrome < 28
            // Target should not be a text node (#504, #13143)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
    }

    jQuery.fn.extend({
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },

        on: function(types, fn) {
            var type;
            if (typeof types === "object") {
                for (type in types) {
                    this.on(types[type], fn);
                }
            }
            return this.each(function() {
                //this  element对象
                jQuery.event.add(this, types, fn);
            });
        }
    })

    function createOptions(options) {
        var object = optionsCache[options] = {};
        options.split(/\s+/).forEach(function(value) {
            object[value] = true;
        });
        return object;
    }

    root.$ = root.jQuery = jQuery;
})(this);
</"></\></(\w+)\s*\></[\w\w]+></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/15/网易微专业-jq源码解析-事件绑定-体系结构-完整源码/" data-id="ck3e9zcop000lntxqqsn4li8q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-jq源码解析-2-5-1-事件绑定-bind-delegate-on" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/10/网易微专业-jq源码解析-2-5-1-事件绑定-bind-delegate-on/" class="article-date">
  <time datetime="2019-11-10T09:45:59.000Z" itemprop="datePublished">2019-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/10/网易微专业-jq源码解析-2-5-1-事件绑定-bind-delegate-on/">网易微专业-jq源码解析-2.5.1 事件绑定-bind/delegate/on</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>说明：bind/delegate/on，在最近的jQuery版本中bind/delegate已经被on取代了，所以本节也是重点讲述on<br>一、事件模型<br>1、DOM0 DOM2事件模型<br><img src="https://snakexu.github.io/images/wangyi/jq/on_1.png"><br>2、事件流<br><img src="https://snakexu.github.io/images/wangyi/jq/on_2.png"><br>3、事件委托<br><img src="https://snakexu.github.io/images/wangyi/jq/on_3.png"><br>实例代码：</p>
<p><pre><br>HTML代码：<br>&lt; ul id=”proxy”&gt;<br>    &lt; li&gt;主页&lt; /li&gt;<br>    &lt; li&gt;文章&lt; /li&gt;<br>    &lt; li&gt;官宣&lt; /li&gt;<br>    &lt; li&gt;简介&lt; /li&gt;<br>&lt; /ul&gt;<br>js代码1：<br>var ElemUl = document.getElementById(“proxy”);<br>var ElemLi = ElemUl.getElementsByTagName(‘li’);<br>for (var i = 0; i &lt; ElemLi.length; i++) {<br>    ElemLi[i].onclick = function() {<br>        alert(“loading…”);<br>    }<br>}<br>js代码2：<br>var proxy = document.getElementById(“proxy”);<br>proxy.onclick = function(event) {<br>    var target = event.target;<br>    if (target.nodeName.toLowerCase() == ‘li’) {<br>        alert(“loading…”);<br>    }<br>}<br></pre><br>上面js代码1是大家马上能想出来的，代码2是利用了事件委托/事件代理，通过代理的方式，将事件绑定在ul上，这样性能表现会优于代码1<br>二、bind/delegate/on事件绑定解析<br>1、API<br><img src="https://snakexu.github.io/images/wangyi/jq/on_4.png"><br>on相当于bind和delegate的集合<br><img src="https://snakexu.github.io/images/wangyi/jq/on_5.png"><br>2、源码分析<br>(1)jQuery事件机制解决了哪些问题：<br><br>·不同浏览器下的事件兼容<br><br>·一个事件类型添加多个事件函数，一次添加多个事件类型的处理函数<br><br>·简洁的定义方式<br><br>·允许自定义事件<br><br>实例：</p>
<p><pre><br>//多个事件绑定同一个函数<br>$(“#id”).on(“mouseover mouseout”, function() {<br>    console.log(“loading…”)<br>});</pre></p>
<p>//多个事件绑定不同函数<br>$(“#id”).on({<br>    mouseover: function() {<br>        $(“body”).css(“background-color”, “lightgray”);<br>    },<br>    mouseout: function() {<br>        $(“body”).css(“background-color”, “lightblue”);<br>    },<br>    click: function() {<br>        $(“body”).css(“background-color”, “yellow”);<br>    }<br>});</p>
<p>//绑定自定义事件<br>$(“#id”).on(“myOwnEvent”, function(event, showName) {<br>    console.log(“loading…”)<br>});<br>$(“#id”).trigger(“myOwnEvent”, [“max”]);<br><br>3、jQuery事件设计原型<br>(1)原型图<br><img src="https://snakexu.github.io/images/wangyi/jq/on_6.png"><br>在本课程中，老师对内容做了一些重构，并且没有做代理子元素事件，仅为自己绑定事件，也主要是为了方便大家的理解<br><br>(2)源码<br>因为是基于之前代码的功能，所以这里代码显得比较多，其实很多都是之前的内容<br><br>下面，我们把这次课程的代码单独拿出来，这样方便理解分析<br></p>
<p><pre><br>jQuery.fn.extend({<br>    //这段代码中this是$(‘#id’)里创建的实例对象<br>    //调用jQuery.each依次执行this对象里的内容<br>    each: function(callback, args) {<br>        return jQuery.each(this, callback, args);<br>    },<br>    //$(“#id”).on(事件，事件函数)<br>    //types:事件,fn:事件函数<br>    //绑定事件首先从这里on开始<br>    on: function(types, fn) {<br>        var type;<br>        //如果传递进来的types事件是对象/数组等<br>        if (typeof types === “object”) {<br>            for (type in types) {<br>                this.on(types[type], fn);<br>            }<br>        }<br>        //如果传递进来的types参数不是对象<br>        //this.each就是jQuery.fn.each<br>        return this.each(function() {<br>            //this  element对象<br>            //jQuery.event是jQuery内置的一个事件系统<br>            jQuery.event.add(this, types, fn);<br>        });<br>    }<br>})<br></pre><br>jQuery.each代码</p>
<p><pre><br>/<em><br> object   目标源<br> callback  回调函数<br> args     自定义回调函数参数
 </em>/<br>each: function(object, callback, args) {<br>    //object  数组对象 || object对象<br>    //此处传递过来的object实例对象是jQuery的实例对象，有length的属性<br>    var length = object.length;<br>    var name, i = 0;</pre></p>
<pre><code>// 自定义callback 参数
if (args) {
    if (length === undefined) {
        for (name in object) {
            callback.apply(object, args);
        }
    } else {
        for (; i &lt; length;) {
            callback.apply(object[i++], args);
        }
    }
} else {
    if (length === undefined) {
        for (name in object) {
            callback.call(object, name, object[name]);
        }
    } else {
        //初始传进来的参数没有args，而jq本身有length属性，所以执行下面的循环
        for (; i &lt; length;) {
            //callback是jQuery.event.add,依次对传进来的每一个实例化对象执行jQuery.event.add
            callback.call(object[i], i, object[i++]);
        }
    }
}
</code></pre><p>},<br><br>jQuery.event.add代码：</p>
<p><pre><br>//1:利用 data_priv 数据缓存,分离事件与数据 2:元素与缓存中建立 guid 的映射关系用于查找<br>add: function(elem, type, handler) {<br>    //elem jQuery引擎所找到的DOM元素<br>    var eventHandle, events,handlers;<br>    //事件缓存 数据对象，data_priv来源在下面一段代码里<br>    var elemData = data_priv.get(elem);//一开始，elemData={}</pre></p>
<pre><code>//检测handler是否存在ID(guid)如果没有那么传给他一个ID
//添加ID的目的是 用来寻找或者删除相应的事件
//补充：guid是按事件添加的，比如我们有三个div，每个div的class=&quot;box&quot;,
//那么，$(&apos;.box&apos;).on(&apos;click&apos;,function(){console.log(&apos;loading...&apos;)})
//$(&apos;box&apos;)在each里是执行三次的，因为我们有三个class=&quot;box&quot;的元素，
//但是，这三个元素在事件触发时执行相同的函数function(){console.log(&apos;loading...&apos;)}
//这个被执行的函数只有这一个，也就是说第一个class=&quot;box&quot;的元素执行到这里的时候，handler添加了属性guid
//那么剩下的两个class=&quot;box&quot;的元素执行到这里的时候，不再执行handler.guid = jQuery.guid++;
if (!handler.guid) {
    handler.guid = jQuery.guid++;   //guid == 1
}
/*
给缓存增加事件处理句柄
elemData = {
  events:
  handle:    
}
*/
//同一个元素,不同事件,不重复绑定    {events:{}}
//变量=undefined 的结果为undefined,!undefined = true,
//如果elemData.events已经存在，则判断条件为false
if (!(events = elemData.events)) { 
    events = elemData.events = {};
}
if (!(eventHandle = elemData.handle)) {
    //Event 对象代表事件的状态 通过apply传递
    eventHandle = elemData.handle = function(e) {
        return jQuery.event.dispatch.apply(eventHandle.elem, arguments);
    }
}
eventHandle.elem = elem;
//通过events存储同一个元素上的多个事件   {events:{click:[]}}   
if (!(handlers = events[type])) {
    handlers = events[type] = [];
    handlers.delegateCount = 0;  //有多少事件代理默认0
}
handlers.push({
    type: type,
    handler: handler,
    guid: handler.guid,
});
//添加事件
if (elem.addEventListener) {
    elem.addEventListener(type, eventHandle, false);
}
</code></pre><p>},<br><br>上面的代码中data_priv来源如下</p>
<p><pre><br>/**</pre></p>
<ul>
<li>Data 构造函数</li>
<li>是为jQuery缓存所创建的数据仓库</li>
<li>存储当前元素的事件名称、处理函数、子元素、子元素的事件名称、子元素的处理函数<br>*/<br>function Data() {<br> //jQuery.expando是jQuery的静态属性,对于jQuery的每次加载运行期间时唯一的随机数<br> this.expando = jQuery.expando + Math.random();//本质上就是生成了一个随机数<br> this.cache = {};<br>}</li>
</ul>
<p>Data.uid = 1;</p>
<p>Data.prototype = {<br>    key: function(elem) {<br>        var descriptor = {},<br>            unlock = elem[this.expando];</p>
<pre><code>    if (!unlock) {
        unlock = Data.uid++;
        descriptor[this.expando] = {   //钥匙
            value: unlock
        };
        //方法直接在一个对象上定义一个或多个新的属性或修改现有属性,并返回该对象。
        //DOM   =&gt;  jQuery101089554822917892030.7449198463843298 = 1;
        Object.defineProperties(elem, descriptor);
    }
    //确保缓存对象记录信息
    if (!this.cache[unlock]) {
        this.cache[unlock] = {};   //  数据
    }

    return unlock;
},

get: function(elem, key) {
    //找到或者创建缓存,第一次执行的时候this.key[elem]=1,this.cache[1]={}
    var cache = this.cache[this.key(elem)];    //1  {events:{},handle:function(){}} 
    //key 有值直接在缓存中取读
    return key === undefined ? cache : cache[key];
},
</code></pre><p>}</p>
<p>var data_priv = new Data();<br><br>jQuery.event.dispatch代码</p>
<p><pre><br>//修复事件对象event(进行兼容性的处理) 从缓存体中的events对象取得对应队列。<br>dispatch: function(event) {<br>    //IE兼容性处理如：event.target or event.srcElement<br>    //event = jQuery.event.fix(event);</pre></p>
<pre><code>//提取当前元素在cache中的events属性值。 click
var handlers = (data_priv.get(this, &quot;events&quot;) || {})[event.type] || [];
event.delegateTarget = this;
//执行事件处理函数
</code></pre><p>   jQuery.event.handlers.call( this, event, handlers );<br>},<br><br>这里最主要的思想之一是分离事件与数据，为自定义事件打下基础。<br><br>2019/11/19补充<br>关于上面的一段代码<br><br>if (!handler.guid) {<br><br>    handler.guid = jQuery.guid++;   <br><br>}<br><br>我做了一些解释，是我在控制台打印了一些东西后的结论:<br><img src="https://snakexu.github.io/images/wangyi/jq/on_7.png"><br><img src="https://snakexu.github.io/images/wangyi/jq/on_8.png"><br><img src="https://snakexu.github.io/images/wangyi/jq/on_9.png"><br>上面的控制台打印，可以看到，若有若干个class相同的元素$(‘.类明’).on(‘事件名’,事件函数)会取到若干个元素，执行jQuery.fn.on-&gt;jQuery.each-&gt;jQuery.event.add，是对每个元素都执行了jQuery.event.add，但是对于实例化的同类名绑定的相同事件始终只是指向了一个事件执行函数，就是$(‘.类明’).on(‘事件名’,事件函数)中的事件函数。至于说参数是传值引用的，<a href="https://snakexu.github.io/2018/11/12/js%E5%8F%82%E6%95%B0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/" target="_blank" rel="noopener">https://snakexu.github.io/2018/11/12/js%E5%8F%82%E6%95%B0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/</a> 我这里对参数是按值传递有一些解释</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/10/网易微专业-jq源码解析-2-5-1-事件绑定-bind-delegate-on/" data-id="ck3e9zcoo000kntxqzl8tkh5c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-jq源码解析-1107直播课deferred相关" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/09/网易微专业-jq源码解析-1107直播课deferred相关/" class="article-date">
  <time datetime="2019-11-09T07:53:26.000Z" itemprop="datePublished">2019-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/09/网易微专业-jq源码解析-1107直播课deferred相关/">网易微专业-jq源码解析-1107直播课deferred相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、Callbacks设计<br><img src="https://snakexu.github.io/images/wangyi/jq/1107_1.png"><br>2、Deferred对象设计<br><img src="https://snakexu.github.io/images/wangyi/jq/1107_2.png"><br><img src="https://snakexu.github.io/images/wangyi/jq/1107_3.png"><br>究其本质，就是在不同执行状态，调用$.Callbacks.add()添加不同函数，在事件状态改变的时候调用不同的函数<br><br>3、我在之前笔记里有个问题<br><br><img src="https://snakexu.github.io/images/wangyi/jq/1107_4.png"><br>这里为什么要在promise的上下文中执行<br><br>这个问题老师讲解了，这个涉及到对象状态的改变与凝固：一个对象在状态改变之后，我们首先会返回一个deferred.promise()去凝固状态(究其本质就是为了在事件状态改变之后，不再有改变其状态的可能)，而这里promise的没有修改状态的权限(deferred有修改状态的权限)<br>4、关于jQuery.extend({},obj1,obj2)<br><br>对这个要有一个认知：这个是为jQuery架构服务的，并非是单独的功能；还有一个特点：以默认配置为优先，以用户配置为覆盖<br>5、关于deferred的章节里，有个when调用的方法，这里进行升级修改<br><br>首先，我们回顾下，deferred.promise()有done()/fail()/proress()/promise()/state()/then()方法<br><br>然后，相信大多数人对es6的promise已经有一个了解，Promise.prototype.then()方法的第一个参数是resolved状态的回调函数，第二个参数(可选)是rejected状态的回调函数,另外就是promise的链式回调的思路</p>
<p><pre><br>// 异步回调解决方案<br>Deferred: function(func) {<br>    var tuples = [<br>            [“resolve”, “done”, jQuery.callbacks(“once memory”), “resolved”],<br>            [“reject”, “fail”, jQuery.callbacks(“once memory”), “rejected”],<br>            [“notify”, “progress”, jQuery.callbacks(“memory”)]<br>        ],<br>        state = “pending”,<br>        //promise   权限分配  add   添加callback<br>        promise = {<br>            state: function() {<br>                return state;<br>            },<br>            then: function( /<em> fnDone, fnFail, fnProgress </em>/ ) {<br>                var fns = [].slice.call(arguments); //真正数组对象<br>                //创建一个Deferred 延迟对象  返回一个promise对象<br>                return jQuery.Deferred(function(newdefer) {<br>                    tuples.forEach(function(tuple, i) {<br>                        var fn = jQuery.isFunction(fns[i]) &amp;&amp; fns[i];<br>                        /<em><br>                        deferred   通过闭包去访问  此处链接式调用时指向的deferred对象<br>                        newdefer   通过参数传递    指向新创建的deferred对象
                        </em>/<br>                        //resolve  队列中的 callback<br>                        deferred<a href="function(">tuple[1]</a> {<br>                            var returndefer = fn &amp;&amp; fn.apply(this, arguments);<br>                            //这个判断里面的内容就是链式回调的重点了<br>                            if (returndefer &amp;&amp; jQuery.isFunction(returndefer.promise)) {<br>                                 //console.log(newdefer)<br>                                 returndefer.done(newdefer.resolve)<br>                                            .fail(newdefer.reject)<br>                                            .progress(newdefer.notify);<br>                            }<br>                        });</pre></p>
<pre><code>                })
            }).promise();
        },
        promise: function(obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
        }
    },
    deferred = {};

tuples.forEach(function(tuple, i) {
    var list = tuple[2],
        stateString = tuple[3];

    // promise[ done | fail | progress ] = list.add
    promise[tuple[1]] = list.add;

    // Handle state
    if (stateString) {
        list.add(function() {
            // state = [ resolved | rejected ]
            state = stateString;
        });
    }

    // deferred[ resolve | reject | notify ]  der.resolve(&quot;加载成功&quot;);    
    deferred[tuple[0]] = function() {
        deferred[tuple[0] + &quot;With&quot;](this === deferred ? promise : this, arguments);
        return this;
    };
    deferred[tuple[0] + &quot;With&quot;] = list.fireWith;
});

// Make the deferred a promise
promise.promise(deferred);

//新创建的deferred 对象
if (func) {
    func.call(deferred, deferred);
}
return deferred;
</code></pre><p>},<br><br>这节内容，我也将源码单独作为一篇文章写出了，其中有部分内容是老师在上课的是对链式回调思路的解释，而链式回调这部分内容的思路个人认为可以说是非常经典了。我们要理解，链式回调，每一个then都是对之前调用这个then而返回的deferred的的反馈，代码中非常巧妙的通过闭包和传参的方式保留了每次deferred和then的callbacks队列</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/09/网易微专业-jq源码解析-1107直播课deferred相关/" data-id="ck3e9zco10009ntxqezcnfgra" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-jq源码解析-2-4-1-延时对象-Deferred概念-源码剖析" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/08/网易微专业-jq源码解析-2-4-1-延时对象-Deferred概念-源码剖析/" class="article-date">
  <time datetime="2019-11-08T14:06:59.000Z" itemprop="datePublished">2019-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/08/网易微专业-jq源码解析-2-4-1-延时对象-Deferred概念-源码剖析/">网易微专业-jq源码解析-2.4.1-延时对象-Deferred概念 &amp; 源码剖析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、promise/A+规范<br>1、Promise作为一个模型，提供了一个在软件工程中描述延时（或将来）概念的解决方案:<br>(1)、表示一个异步操作的最终结果;<br>(2)、与Promise最主要的交互方法是，通过将函数传入它的then方法，从而获得Promise最终的值或者Promise最终拒绝(reject)的原因<br>(3)、一个Promise必须处于以下三种状态之一：pending，resolved或rejected；<br>(4)、一个Promise必须提供一个then方法来获取其成功（resolve）的值或者错误（reject）原因。<br>而Deferred是这种规范的具体实现<br><img src="https://snakexu.github.io/images/wangyi/jq/deferred_1.png"><br>2、Deferred API<br>jQuery.Deferred():一个构造函数，返回一个链式实用对象方法来注册多个回调，回调队列，调用回调队列，并转达任何同步或异步函数的成功或失败状态<br>deferred.done():当Deferred(延迟)对象解决时，调用添加处理程序<br>deferred.fail():当Deferred(延迟)对象拒绝时，调用添加处理程序<br>deferred.proress():当Deferred(延迟)对象生成进度通知时，调用(已)添加的处理程序<br>jQuery.when():提供一种方法来执行一个或多个对象的回调函数，Deferred(延迟)对象通常表示异步事件<br>.promise():返回一个Promise对象用来观察当某种类型的所有行动绑定到集合，排队与否还是已经完成<br>二、源码<br>1、DEMO</p>
<pre>
var wait = function() {
    var der = $.Deferred();     //延迟对象    deferred 
    var test = function() {
        console.log("老司机开车了");
        der.resolve("max");     //成功     队列中的处理函数  调用成功这个队列中的处理函数
    }
    setTimeout(test, 2000);   
    return der;    //延迟对象 
}       
//延迟对象的状态 决定调用那个队列中的处理函数
$.when(wait())     //promise对象promise.done()   self.add
    .done(function(name) {
        console.log(name)
        console.log("执行成功");
    })
    .fail(function() {
        console.log("执行失败");
    });
</pre>
表急，我怎么会只给demo不给源码呢<br>
2、源码
<pre>
(function(root) {
    var testExp = /^\s*(<[\w\w]+>)[^>]*$/;
    var rejectExp = /^<(\w+)\s*\ ?="">(?:<\ \1="">|)$/;
    var version = "1.0.1";
    var optionsCache = {};
    var jQuery = function(selector, context) {
        return new jQuery.prototype.init(selector, context);
    }

    jQuery.fn = jQuery.prototype = { //原型对象
        length: 0,
        jquery: version,
        selector: "",
        init: function(selector, context) {
            context = context || document;
            var match, elem, index = 0;
            //$()  $(undefined)  $(null) $(false)  
            if (!selector) {
                return this;
            }

            if (typeof selector === "string") {
                if (selector.charAt(0) === "<" &&="" selector.charat(selector.length="" -="" 1)="==" "="">" && selector.length >= 3) {
                    match = [selector]
                }
                //创建DOM
                if (match) {
                    //this  
                    jQuery.merge(this, jQuery.parseHTML(selector, context));
                    //查询DOM节点
                } else {
                    elem = document.querySelectorAll(selector);
                    var elems = Array.prototype.slice.call(elem);
                    this.length = elems.length;
                    for (; index < elems.length; index++) {
                        this[index] = elems[index];
                    }
                    this.context = context;
                    this.selector = selector;
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }

        },
        css: function() {
            console.log("di~~didi~~")
        },
        //....
    }

    jQuery.fn.init.prototype = jQuery.fn;


    jQuery.extend = jQuery.prototype.extend = function() {
        var target = arguments[0] || {};
        var length = arguments.length;
        var i = 1;
        var deep = false; //默认为浅拷贝 
        var option;
        var name;
        var copy;
        var src;
        var copyIsArray;
        var clone;

        if (typeof target === "boolean") {
            deep = target;
            target = arguments[1];
            i = 2;
        }

        if (typeof target !== "object") {
            target = {};
        }

        if (length == i) {
            target = this;
            i--; //0   
        }

        for (; i < length; i++) {
            if ((option = arguments[i]) !== null) {
                for (name in option) {
                    src = target[name];
                    copy = option[name];
                    if (deep && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    }


    jQuery.extend({
        //类型检测     
        isPlainObject: function(obj) {
            return typeof obj === "object";
        },

        isArray: function(obj) {
            return toString.call(obj) === "[object Array]";
        },

        isFunction: function(fn) {
            return toString.call(fn) === "[object Function]";
        },
        //类数组转化成正真的数组  
        markArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
            }
            return ret;
        },

        //合并数组
        merge: function(first, second) {
            var l = second.length,
                i = first.length,
                j = 0;

            if (typeof l === "number") {
                for (; j < l; j++) {
                    first[i++] = second[j];
                }
            } else {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }

            first.length = i;

            return first;
        },

        parseHTML: function(data, context) {
            if (!data || typeof data !== "string") {
                return null;
            }
            //过滤掉< a >   < a >   => a 
            var parse = rejectExp.exec(data);
            console.log(parse)
            return [context.createElement(parse[1])];
        },

        //$.Callbacks用于管理函数队列
        callbacks: function(options) {
            options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : {};
            var list = [];
            var index, length, testting, memory, start, starts;
            var fire = function(data) {
                memory = options.memory && data;
                index = starts || 0;
                start = 0;
                testting = true;
                length = list.length;
                for (; index < length; index++) {
                    if (list[index].apply(data[0], data[1]) === false && options.stopOnfalse) {
                        break;
                    }
                }
            }
            var self = {
                add: function() {
                    var args = Array.prototype.slice.call(arguments);
                    start = list.length;
                    args.forEach(function(fn) {
                        if (toString.call(fn) === "[object Function]") {
                            list.push(fn);
                        }
                    });
                    if (memory) {
                        starts = start;
                        fire(memory);
                    }
                    return this;
                },
                //指定上下文对象
                fireWith: function(context, arguments) {
                    var args = [context, arguments];
                    if (!options.once || !testting) {
                        fire(args);
                    }

                },
                //参数传递
                fire: function() {
                    self.fireWith(this, arguments);
                }
            }
            return self;
        },

        // 异步回调解决方案
        Deferred: function(func) {
            //延迟对象三种不同状态信息的描述
            //状态，往队列里添加处理函数 tuples[i][2]创建队列（创建对象副本的引用）
            //tuples[i][3] 最终状态信息描述
            var tuples = [
                    ["resolve", "done", jQuery.callbacks("once memory"), "resolved"],
                    ["reject", "fail", jQuery.callbacks("once memory"), "rejected"],
                    ["notify", "progress", jQuery.callbacks("memory")]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {
                    },
                    promise: function(obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                //延迟对象 属性 方法 
                deferred = {}; //resolve | reject | notify | state | then | promise

            tuples.forEach(function(tuple, i) {
                //即tuple[i][2]jQuery.callbacks("")
                //创建一个队列 callbacks里self对象的引用
                var list = tuple[2],
                    stateString = tuple[3];//最终状态信息的描述

                // promise[ done | fail | progress ] = list.add 添加处理函数
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) { //只有在成功或者失败的情况下，添加第一个处理程序
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;
                    });
                }

                // deferred[ resolve | reject | notify ] 延迟对象的状态
                deferred[tuple[0]] = function() {
                    //promise[tuple[1]] = list.add; 
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                //list.fireWith 执行队列，调用队列中的处理函数并且传参，绑定执行时上下文对象
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            return deferred;
        },
        //执行一个或多个对象的延迟对象的回调函数
        when: function(subordinate) {
            return subordinate.promise();
        },

    });

    function createOptions(options) {
        var object = optionsCache[options] = {};
        options.split(/\s+/).forEach(function(value) {
            object[value] = true;
        });
        return object;
    }

    root.$ = root.jQuery = jQuery;
})(this);
</"></\></(\w+)\s*\></[\w\w]+></pre>
其中有些部分，是之前课程的内容，这里主要从Deferred开始介绍。另外需要注意的是，本章内容基于上节课程$.Callbacks。Deferred实际上就是基于$.Callbacks,对于不同状态(resolve/reject/done)调用$.Callbacks.add()添加不同函数,可以如图理解：
<img src="https://snakexu.github.io/images/wangyi/jq/1107_2.png">
<img src="https://snakexu.github.io/images/wangyi/jq/1107_3.png">
在源码里，个人认为非常值得关注的点：<br>
1、定义了tuples数组，数组里包含了Deferred相关的状态，添加状态相关的函数的操作，整个编程过程其实是巧妙的运用了这个数组<br>
2、创建的promise对象<br>
    (1)扩展done、fail、progress三个方法，分别对应成功、失败、进行中的三个队列，并指向队列中的add方法，用于向队列中添加执行函数；<br>
    (2)扩展了state、then和promise三个方法<br>
    (2-1)其中state是用于记录状态<br>
    (2-2)then是用于往成功或失败的队列添加执行函数，并在成功或失败时调用。<br>
    (2-3)promise是用于扩展deferred对象或者返回其本身。<br>
3、创建一个deferred对象：<br>
    (1)扩展了resolve方法，对应成功队列，当被执行时，会往deferred对象上扩展并resolveWith函数，该resolveWith指向的是队列的fireWith函数，也即是执行函数。同时，还可以在执行过程中传参，将参数传递到最终的执行函数内部。<br>
    (2)还扩展了reject和notify，其逻辑和resolve一致，只是分别指向了失败和进行中两个队列。<br>
4、创建一个状态state。在成功或者失败的队列中，我们首先会添加第一条处理函数，改变state的状态为成功或者失败。<br>
5、创建一个与Deferred函数平级的when函数，接收一个延迟对象，然后去调用该延迟对象的promise方法，也就是第二点。<br>

其实关于这节课程，我还是有疑问的，不是特别理解promise和deferred对象为啥这么定义和应用过程中这两个对象的内在逻辑，还有比如<br>
deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);<br>
这个地方，为什么要在promise的上下文中执行。其实还是缺乏对这段内容的深刻理解。后续还会继续学习这段内容的
<br>
最后，我在jQuery3.4.1的源码种找到了相关的一段内容，还没有好好研究，先放在这里，待日后细细琢磨
<pre>
jQuery.extend( {

    Deferred: function( func ) {
        var tuples = [

                // action, add listener, callbacks,
                // ... .then handlers, argument index, [final state]
                [ "notify", "progress", jQuery.Callbacks( "memory" ),
                    jQuery.Callbacks( "memory" ), 2 ],
                [ "resolve", "done", jQuery.Callbacks( "once memory" ),
                    jQuery.Callbacks( "once memory" ), 0, "resolved" ],
                [ "reject", "fail", jQuery.Callbacks( "once memory" ),
                    jQuery.Callbacks( "once memory" ), 1, "rejected" ]
            ],
            state = "pending",
            promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done( arguments ).fail( arguments );
                    return this;
                },
                "catch": function( fn ) {
                    return promise.then( null, fn );
                },

                // Keep pipe for back-compat
                pipe: function( /* fnDone, fnFail, fnProgress */ ) {
                    var fns = arguments;

                    return jQuery.Deferred( function( newDefer ) {
                        jQuery.each( tuples, function( i, tuple ) {

                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                            var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

                            // deferred.progress(function() { bind to newDefer or newDefer.notify })
                            // deferred.done(function() { bind to newDefer or newDefer.resolve })
                            // deferred.fail(function() { bind to newDefer or newDefer.reject })
                            deferred[ tuple[ 1 ] ]( function() {
                                var returned = fn && fn.apply( this, arguments );
                                if ( returned && isFunction( returned.promise ) ) {
                                    returned.promise()
                                        .progress( newDefer.notify )
                                        .done( newDefer.resolve )
                                        .fail( newDefer.reject );
                                } else {
                                    newDefer[ tuple[ 0 ] + "With" ](
                                        this,
                                        fn ? [ returned ] : arguments
                                    );
                                }
                            } );
                        } );
                        fns = null;
                    } ).promise();
                },
                then: function( onFulfilled, onRejected, onProgress ) {
                    var maxDepth = 0;
                    function resolve( depth, deferred, handler, special ) {
                        return function() {
                            var that = this,
                                args = arguments,
                                mightThrow = function() {
                                    var returned, then;

                                    // Support: Promises/A+ section 2.3.3.3.3
                                    // https://promisesaplus.com/#point-59
                                    // Ignore double-resolution attempts
                                    if ( depth < maxDepth ) {
                                        return;
                                    }

                                    returned = handler.apply( that, args );

                                    // Support: Promises/A+ section 2.3.1
                                    // https://promisesaplus.com/#point-48
                                    if ( returned === deferred.promise() ) {
                                        throw new TypeError( "Thenable self-resolution" );
                                    }

                                    // Support: Promises/A+ sections 2.3.3.1, 3.5
                                    // https://promisesaplus.com/#point-54
                                    // https://promisesaplus.com/#point-75
                                    // Retrieve `then` only once
                                    then = returned &&

                                        // Support: Promises/A+ section 2.3.4
                                        // https://promisesaplus.com/#point-64
                                        // Only check objects and functions for thenability
                                        ( typeof returned === "object" ||
                                            typeof returned === "function" ) &&
                                        returned.then;

                                    // Handle a returned thenable
                                    if ( isFunction( then ) ) {

                                        // Special processors (notify) just wait for resolution
                                        if ( special ) {
                                            then.call(
                                                returned,
                                                resolve( maxDepth, deferred, Identity, special ),
                                                resolve( maxDepth, deferred, Thrower, special )
                                            );

                                        // Normal processors (resolve) also hook into progress
                                        } else {

                                            // ...and disregard older resolution values
                                            maxDepth++;

                                            then.call(
                                                returned,
                                                resolve( maxDepth, deferred, Identity, special ),
                                                resolve( maxDepth, deferred, Thrower, special ),
                                                resolve( maxDepth, deferred, Identity,
                                                    deferred.notifyWith )
                                            );
                                        }

                                    // Handle all other returned values
                                    } else {

                                        // Only substitute handlers pass on context
                                        // and multiple values (non-spec behavior)
                                        if ( handler !== Identity ) {
                                            that = undefined;
                                            args = [ returned ];
                                        }

                                        // Process the value(s)
                                        // Default process is resolve
                                        ( special || deferred.resolveWith )( that, args );
                                    }
                                },

                                // Only normal processors (resolve) catch and reject exceptions
                                process = special ?
                                    mightThrow :
                                    function() {
                                        try {
                                            mightThrow();
                                        } catch ( e ) {

                                            if ( jQuery.Deferred.exceptionHook ) {
                                                jQuery.Deferred.exceptionHook( e,
                                                    process.stackTrace );
                                            }

                                            // Support: Promises/A+ section 2.3.3.3.4.1
                                            // https://promisesaplus.com/#point-61
                                            // Ignore post-resolution exceptions
                                            if ( depth + 1 >= maxDepth ) {

                                                // Only substitute handlers pass on context
                                                // and multiple values (non-spec behavior)
                                                if ( handler !== Thrower ) {
                                                    that = undefined;
                                                    args = [ e ];
                                                }

                                                deferred.rejectWith( that, args );
                                            }
                                        }
                                    };

                            // Support: Promises/A+ section 2.3.3.3.1
                            // https://promisesaplus.com/#point-57
                            // Re-resolve promises immediately to dodge false rejection from
                            // subsequent errors
                            if ( depth ) {
                                process();
                            } else {

                                // Call an optional hook to record the stack, in case of exception
                                // since it's otherwise lost when execution goes async
                                if ( jQuery.Deferred.getStackHook ) {
                                    process.stackTrace = jQuery.Deferred.getStackHook();
                                }
                                window.setTimeout( process );
                            }
                        };
                    }

                    return jQuery.Deferred( function( newDefer ) {

                        // progress_handlers.add( ... )
                        tuples[ 0 ][ 3 ].add(
                            resolve(
                                0,
                                newDefer,
                                isFunction( onProgress ) ?
                                    onProgress :
                                    Identity,
                                newDefer.notifyWith
                            )
                        );

                        // fulfilled_handlers.add( ... )
                        tuples[ 1 ][ 3 ].add(
                            resolve(
                                0,
                                newDefer,
                                isFunction( onFulfilled ) ?
                                    onFulfilled :
                                    Identity
                            )
                        );

                        // rejected_handlers.add( ... )
                        tuples[ 2 ][ 3 ].add(
                            resolve(
                                0,
                                newDefer,
                                isFunction( onRejected ) ?
                                    onRejected :
                                    Thrower
                            )
                        );
                    } ).promise();
                },

                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function( obj ) {
                    return obj != null ? jQuery.extend( obj, promise ) : promise;
                }
            },
            deferred = {};

        // Add list-specific methods
        jQuery.each( tuples, function( i, tuple ) {
            var list = tuple[ 2 ],
                stateString = tuple[ 5 ];

            // promise.progress = list.add
            // promise.done = list.add
            // promise.fail = list.add
            promise[ tuple[ 1 ] ] = list.add;

            // Handle state
            if ( stateString ) {
                list.add(
                    function() {

                        // state = "resolved" (i.e., fulfilled)
                        // state = "rejected"
                        state = stateString;
                    },

                    // rejected_callbacks.disable
                    // fulfilled_callbacks.disable
                    tuples[ 3 - i ][ 2 ].disable,

                    // rejected_handlers.disable
                    // fulfilled_handlers.disable
                    tuples[ 3 - i ][ 3 ].disable,

                    // progress_callbacks.lock
                    tuples[ 0 ][ 2 ].lock,

                    // progress_handlers.lock
                    tuples[ 0 ][ 3 ].lock
                );
            }

            // progress_handlers.fire
            // fulfilled_handlers.fire
            // rejected_handlers.fire
            list.add( tuple[ 3 ].fire );

            // deferred.notify = function() { deferred.notifyWith(...) }
            // deferred.resolve = function() { deferred.resolveWith(...) }
            // deferred.reject = function() { deferred.rejectWith(...) }
            deferred[ tuple[ 0 ] ] = function() {
                deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
                return this;
            };

            // deferred.notifyWith = list.fireWith
            // deferred.resolveWith = list.fireWith
            // deferred.rejectWith = list.fireWith
            deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
        } );

        // Make the deferred a promise
        promise.promise( deferred );

        // Call given func if any
        if ( func ) {
            func.call( deferred, deferred );
        }

        // All done!
        return deferred;
    },

    // Deferred helper
    when: function( singleValue ) {
        var

            // count of uncompleted subordinates
            remaining = arguments.length,

            // count of unprocessed arguments
            i = remaining,

            // subordinate fulfillment data
            resolveContexts = Array( i ),
            resolveValues = slice.call( arguments ),

            // the master Deferred
            master = jQuery.Deferred(),

            // subordinate callback factory
            updateFunc = function( i ) {
                return function( value ) {
                    resolveContexts[ i ] = this;
                    resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                    if ( !( --remaining ) ) {
                        master.resolveWith( resolveContexts, resolveValues );
                    }
                };
            };

        // Single- and empty arguments are adopted like Promise.resolve
        if ( remaining <= 1="" )="" {="" adoptvalue(="" singlevalue,="" master.done(="" updatefunc(="" i="" ).resolve,="" master.reject,="" !remaining="" );="" use="" .then()="" to="" unwrap="" secondary="" thenables="" (cf.="" gh-3000)="" if="" (="" master.state()="==" "pending"="" ||="" isfunction(="" resolvevalues[="" ]="" &&="" ].then="" return="" master.then();="" }="" multiple arguments="" are="" aggregated="" like="" promise.all="" array="" elements="" while="" i--="" ],="" ),="" master.reject="" master.promise();="" <="" pre=""></=></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/08/网易微专业-jq源码解析-2-4-1-延时对象-Deferred概念-源码剖析/" data-id="ck3e9zcoy000nntxqtj2tqbpd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js正则表达式基础总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/07/js正则表达式基础总结/" class="article-date">
  <time datetime="2019-11-07T11:04:59.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/07/js正则表达式基础总结/">js正则表达式基础总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一部分 基础知识<br>一、正则申明方式<br>1、构造函数方式<br>var reg = new RegExp(‘\d’, ‘gi’);<br>● 通过 new 构造一个正则表达式对象，其中第一个参数 ‘\d’ 是正则内容，第二个参数 ‘gi’ 是修饰符。两个参数皆为字符串类型</p>
<p>● 修饰符的作用是对匹配过程进行限定</p>
<p>● 修饰符有三种：i, g, m，可以同时出现，没有顺序（即 gi 与 ig 一样），请参考下方说明</p>
<p>修饰符    说明<br>i    忽略大小写匹配<br>g    全局匹配，即是匹配一个后继续匹配，直到结束<br>m    多行匹配，即是遇到换行后不停止匹配，直到结束<br>说明：<br>● [a-z] 表示从小写字母a到小写字母z之间的任意字符(含a和z)，下文会有详细说明<br>● + 表示至少出现一次<br>● \n 在js中表示换行<br>● ^[a-z] 表示以任意小写字母开头的行</p>
<p>‘aBcd efg’.match(/[a-z]+/);<br>// [“a”]</p>
<p>‘aBcd efg’.match(/[a-z]+/i);<br>// [“aBcd”]</p>
<p>‘aBcd efg’.match(/[a-z]+/g);<br>// [“a”, “cd”, “efg”]</p>
<p>‘aBcd efg’.match(/[a-z]+/gi);<br>// [“aBcd”, “efg”]</p>
<p>‘aB\ncd\n efg’.match(/^[a-z]+/m);<br>// [“a”]</p>
<p>‘aB\ncd\n efg’.match(/^[a-z]+/g);<br>// [“a”]</p>
<p>‘aB\ncd\n efg’.match(/^[a-z]+/gm);<br>// [“a”, “cd”]<br>// 注意不是 [“a”, “cd”, “efg”]<br>2、字面量方式<br>相比较上一种方式，这一种更为常见，上面示例也都使用了这种方式</p>
<p>var reg = /\d/gi;<br>两个斜线内为正则的内容，后面可以跟修饰符，与第一种构造函数方式相比更简洁，缺点是正则内容不能拼接，对于大多数场景俩说足够了</p>
<p>二、正则相关符号<br>1、方括号 [] 用法<br>用于查找方括号内的任意字符：</p>
<p>在这里插入图片描述</p>
<p>注意：<br>1）^ 在 [] 内开始位置及正则双斜线开始位置有特殊含义，其他位置表示 ^ 字符本身<br>● // 正则开头位置表示以某某开头的字符串，如下表示以大写或小写字母开头的且连续为字母的字符串：</p>
<p>‘adobe 2016’.match(/^[a-zA-Z]+/);<br>// [“adobe”]<br>● 在正则 或 匹配中(即 | 匹配)，表示 或者以某某字符开始的字符串，如下表示匹配 连续数字 或 以小写字母开头且连续为小写字母的字符串，所以返回结果包含2016 和 adobe，注意返回结果不是 [“2016”, “adobe”]</p>
<p>‘adobe2016ps’.match(/\d+|^[a-z]+/g);<br>// [“adobe”, “2016”]<br>● 在 [] 内开始位置时，表示不匹配 [] 内除 ^ 以外的所有字符：</p>
<p>‘adobe’.match(/[^abc]/g);<br>// [“d”, “o”, “e”]<br>注： $ 与 ^ 的前两个用法相似，只不过匹配的是以某某字符结尾的字符串，举例：</p>
<p>‘adobe 2016’.match(/\d+|[a-z]+$/g);<br>// [“2016”]<br>‘adobe’.match(/\d+|[a-z]+$/g);<br>// [“adobe”]<br>2）- (连字符)表示左边字符的 ASCII 值到右边字符 ASCII 编码值之间及左右字符自身的所有字符</p>
<p>‘adobe PS 2016’.match(/[a-g]/g);<br>// [“a”, “d”, “b”, “e”]<br>3）- 连字符左侧的字符对应的 ASCII 值一定要小于或等于右侧的字符，否则会报语法错误</p>
<p>‘adobe’.match(/[z-a]/);<br>// Uncaught SyntaxError: Invalid regular expression: /[z-a]/: Range out of order in character class…<br>4）如果希望对连字符 - 本身进行匹配，需要用反斜线转义</p>
<p>‘adobe-2016’.match(/[a-g-]/g);<br>// [“a”, “d”, “b”, “e”, “-“]<br>5）查看 ASCII 表就会发现，大写字母的 ASCII 值是小于小写字母的，因此下面用法会报语法错误</p>
<p>‘adobe-2016’.match(/[a-Z]/g);<br>// Uncaught SyntaxError: Invalid regular expression: /[a-Z]/: Range out of order in character …<br>那么问题来了，如果要表示所有字母，不区分大小写怎么办呢？其实有两种方式：<br>A、第一种是使用修饰符 i，前面提到过。举例：</p>
<p>‘adobe-PS’.match(/[a-z]/gi);<br>// [“a”, “d”, “o”, “b”, “e”, “P”, “S”]<br>B、第二种是在正则中明确指明大小写字母，举例：</p>
<p>‘adobe-PS’.match(/[a-zA-Z]/g);<br>// [“a”, “d”, “o”, “b”, “e”, “P”, “S”]<br>返回结果跟第一种一样。当然这个例子有些特殊：匹配了所有大小写字母。当只匹配部分大小写字母的时候只能使用第二种方式，在此就不做示例了，读者可以自己测试</p>
<p>6）匹配大小字母不能写成 [A-z]，虽然不会报语法错误，但隐式的放大了匹配范围，查看 ASCII 会发现，在大写字母 Z 到小写字母 a 之间还有 [、 \、 ]、 ^、 _、 ` 这6个字符，因此不能这么写。</p>
<p>7）想必有同学会问， \w 不也可以匹配字母么？是的，\w 确实可以匹配字母，但跟上面说的一样,也隐式的放大了匹配范围，\w 除了匹配大小字母外还匹配了数字和下划线，即 \w 与 [A-Za-z0-9_] 等价，当然 A-Z、a-z、0-9(等价于\d)、_这四组没顺序之分</p>
<p>2、特殊含义字符<br>● . 匹配任意单个字符，除换行和结束符</p>
<p>‘1+0.2<em>2=1.4’.match(/.{2}/g);<br>// [“1+”, “0.”, “2</em>“, “2=”, “1.”]<br>● \w 匹配任意单词字符（数字、字母、下划线），等价于[A-Za-z0-9_]</p>
<p>‘ad34~!@$ps’.match(/\w/g);<br>// [“a”, “d”, “3”, “4”, “p”, “s”]<br>● \W 匹配任意单词字符，与\w相反，等价于[^A-Za-z0-9_]</p>
<p>‘ad34~!@$ps’.match(/\W/g);<br>// [“~”, “!”, “@”, “$”]<br>● \d 匹配数字，等价于 [0-9]</p>
<p>‘ps6’.match(/\d/g);<br>// [“6”]<br>● \D 匹配非数字，等价于 [0-9]</p>
<p>‘ps6’.match(/\D/g);<br>// [“p”, “s”]<br>● \s 匹配空白字符，主要有(\n、\f、\r、\t、\v)，注意’a\sb’中的\s依然是字符s，所以’a\sb’.match(/\s/g)返回 null</p>
<p>‘adobe ps’.match(/\s/g);<br>// [“ “]<br>● \S 匹配非空白字符，与\s相反</p>
<p>‘adobe ps’.match(/\S/g);<br>// [“a”, “d”, “o”, “b”, “e”, “p”, “s”]<br>● \b 匹配单词边界，注意连续的数字、字母或下划线组成的字符串会认为一个单词</p>
<p>‘adobe(2016) ps6.4’.match(/\b(\w+)/g);<br>// [“adobe”, “2016”, “ps6”, “4”]<br>● \B 匹配非单词边界，仔细体会下面的示例与\b的结果</p>
<p>‘adobe(2016) ps6.4’.match(/\B(\w+)/g);<br>// [“dobe”, “016”, “s6”]<br>● \0 匹配NUL字符</p>
<p>‘\0’.match(/\0/);<br>// [“NUL”]<br>● \n 匹配换行符（编码：10，newline）</p>
<p>‘adobe\nps’.match(/\n/).index;<br>// 5<br>● \f 匹配换页符</p>
<p>‘adobe\fps’.match(/\f/).index;<br>// 5<br>● \r 匹配回车符（编码：13，return）</p>
<p>‘adobe\rps’.match(/\r/).index;<br>// 5<br>● \t 匹配制表符，键盘tab对应的字符</p>
<p>‘adobe\tps’.match(/\t/).index;<br>// 5<br>● \v 匹配垂直制表符</p>
<p>‘adobe\vps’.match(/\v/).index;<br>// 5<br>● \xxx 匹配以八进制数xxx规定的字符</p>
<p>‘a’.charCodeAt(0).toString(8);<br>// “141”<br>‘adobe ps’.match(/\141/g);<br>// [“a”]<br>● \xdd 匹配以十六进制数dd规定的字符</p>
<p>‘a’.charCodeAt(0).toString(16);<br>// “61”<br>‘adobe ps’.match(/\x61/g);<br>// [“a”]<br>● \uxxxx 匹配以十六进制数xxxx规定的 Unicode字符，注意位数不够需要补0</p>
<p>‘a’.charCodeAt(0).toString(16);<br>// “61”<br>‘adobe ps’.match(/\u0061/g);<br>// [“a”]<br>注意：<br>window系统回车换行符为\r\n，linux系统下没有\r，linux系统通过vi编辑器打开window系统的文本文件时候，经常在行尾出现^M符号，也就是\r的原因，解析文本的时候需要注意相关判断。</p>
<p>3、量词说明<br>● n+ 匹配包含至少一个n的字符串</p>
<p>‘adobe paas’.match(/a+\w+/g);<br>// [“adobe”, “aas”]<br>● n* 匹配包含零个或多个n的字符串</p>
<p>‘ab3 aa12bb’.match(/a*\d+/g);<br>// [“3”, “aa12”]<br>● n? 匹配包含零个或一个n的字符串</p>
<p>‘ab3 aa12bb’.match(/a?\d+/g);<br>// [“3”, “a12”]<br>● n{x} 匹配包含连续x个n的字符串</p>
<p>‘ab3 aa12bb aaa34’.match(/a{2}\d+/g);<br>// [“aa12”, “aa34”]<br>● n{x,y} 匹配包含至少连续x个且最多连续y个n的字符串</p>
<p>‘a3 aaa12bb aaaaaaa34’.match(/a{2,4}\d+/g);<br>// [“aaa12”, “aaaa34”]<br>● n{x,} 匹配包含至少连续x个n的字符串</p>
<p>‘a3 aaa12bbaa4’.match(/a{2,}\d+/g);<br>// [“aaa12”, “aa4”]<br>由上可知，以下 表达式1 与 表达式2 等价</p>
<p>表达式1    表达式2<br>n+    n{1,}<br>n<em>    n{0,}<br>n？    n{0,1}<br>4、符号说明<br>符号 {}、、$、</em>、+、?、[]、[]、- 已经在前面介绍过，接下来看下其他特殊字符<br>● a|b 匹配包含a或b的字符串</p>
<p>‘adobe ps13’.match(/([a-g]+l\d+)/g);<br>// [“ad”, “be”, “13”]<br>● / 字面量方式申明正则时的界定符</p>
<p>‘adobe’.match(/\w+/);<br>// [“adobe”]<br>● \ 普通反斜线字符</p>
<p>‘a\dobe’.match(/\/);<br>// [“\”]<br>5、小括号 () 用法<br>正则在非全局(g)模式下，通过match方式，返回的数组第一个值整体匹配的字符串，其他值为通过括号分组匹配到的<br>1）捕获用法<br>● 表示对匹配的字符串进行分组</p>
<p>‘adobe cs9cs10, adobe cs11’.match(/([a-z]+\d+)+/);<br>// [“cs9cs10”, “cs10”]<br>// 注意{2,}是对 括弧内的匹配 的描述<br>● 与|一起使用表示选择性</p>
<p>“he is 12. she is 13. it’s box”.match(/(it|she|he)\s+is/g);<br>// [“he is”, “she is”]<br>● 表示对匹配的字符串捕获</p>
<p>‘adobe cs9’.match(/[a-z]+\d+/);<br>// [“cs9”]<br>‘adobe cs9’.match(/[a-z]+(\d+)/);<br>// [“cs9”, “9”]<br>● 表示对匹配的字符串反向引用，引用从 \1 开始，从正则左侧第一个左括号（当然要是闭合的括号才行）开始计算，每多一对括号，引用数加一，在非捕获情况下不会加一。但正则比较复杂时，减少引用可以提升匹配性能，关于 非捕获 下方会详细介绍<br>引用的结果可以通过 构造函数 RegExp 获取，即 RegExp.9</p>
<p>‘Can you can a can as a canner can can a can?’.match(/([cC]an+)\s+\1/g);<br>// [“can can”]<br>// 注意 <code>\1</code> 等价于正则里的 <code>([a-z]+)</code>，即与下面示例相同<br>‘Can you can a can as a canner can can a can?’.match(/[cC]an+\s+[cC]an+/g);<br>// [“can can”]</p>
<p>// 如果把括弧去掉可以看下结果<br>‘Can you can a can as a canner can can a can?’.match(/[cC]an+\s+\1/g);<br>// null<br>2）非捕获用法，以(?)形式出现<br>● (?:n ) 表示非捕获组</p>
<p>// 不使用括号时<br>‘adobe12ps15test’.match(/[a-z]+\d+[a-z]+/);<br>// [“adobe12ps”]<br>// 使用括号分组</p>
<p>‘adobe12ps15test’.match(/[a-z]+(\d+)([a-z]+)/);<br>// [“adobe12ps”, “12”, “ps”]</p>
<p>‘adobe12ps15test’.match(/[a-z]+(?:\d+)([a-z]+)/);<br>// [“adobe12ps”, “ps”]<br>// 看起来上面语句不用(?:)也可以得到相同结果，即：</p>
<p>‘adobe12ps15test’.match(/[a-z]+\d+([a-z]+)/);<br>// [“adobe12ps”, “ps”]<br>// 注意，但需求希望匹配字母之间的规则复杂时，如希望匹配字母，且字母之间可以为1或3时，但不需要1和3</p>
<p>‘adobe11ps15test’.match(/[a-z]+(1|3)+([a-z]+)/);<br>// [“adobe11ps”, “1”, “ps”]<br>// 返回中不希望包含数字怎么办，可以使用非捕获</p>
<p>‘adobe11ps15test’.match(/[a-z]+(?:1|3)+([a-z]+)/);<br>// [“adobe11ps”, “ps”]<br>● (?=n ) 匹配任何其后紧跟字符n的字符串，但返回中不包含n</p>
<p>‘adobe12ps15test’.match(/[a-z]+(?=\d)/g);<br>// [“adobe”, “ps”]<br>● (?!n ) 匹配任何其后没有紧跟字符n的字符串，返回中不包含n</p>
<p>‘adobe12ps15test’.match(/[a-z]+(?!\d)/g);<br>// [“adob”, “p”, “test”]<br>● (?&lt;=n ) 匹配任何其前紧跟字符n的字符串，返回中不包含n</p>
<p>‘adobe12ps15test’.match(/(?&lt;=\d)[a-z]+/g);<br>// [“ps”, “test”]<br>● (?&lt;!n ) 匹配任何其前紧跟字符n的字符串，返回中不包含n</p>
<p>‘adobe12ps15test’.match(/(?&lt;!\d)[a-z]+/g);<br>// [“adobe”, “s”, “est”]<br>3）注意<br>● A、如果希望对上面特殊字符本身进行匹配，需要在其前面添加\进行转移</p>
<p>‘11+2=13’.match(/\d++/g);<br>// [“11+”]<br>‘(11+2)*2=26’.match(/(\d++\d+)/g);<br>// [“(11+2)”]<br>● B、\举例</p>
<p>// 注意下面两个表达式返回的结果<br>‘path C:\Windows\System32’.match(/([a-zA-Z]:\\w+)/g);<br>// null<br>‘path C:\Windows\System32’.match(/([a-zA-Z]:\\w+)/g);<br>// [“C:\Windows”]<br>说明: 在申明字符串 ‘path C:\Windows\System32’ 时，其中的 ‘’ 就已经被当做转移符，既是 ‘\W’ ===<br>‘W’,所以如果希望申明的字符串中包含反斜线，需要在加一个反斜线转义，即 \</p>
<p>6、正则相关方法<br>1） RegExp对象相关方法</p>
<p>在这里插入图片描述<br>2）String对象相关方法</p>
<p>在这里插入图片描述<br>3）replace 具体用法<br>顾名思义，是字符串替换方法，但用法比较广泛，相信读者已经非常熟悉了。在此就当复习了<br>A、 基本用法<br>直接传入字符串进行替换，找到子串后只替换一次，举例：</p>
<p>‘adobe abc’.replace(‘b’, ‘_’)<br>// “ado_e abc”<br>// 注意 第二个 b 没有被替换<br>如果希望全部替换，可以使用正则表达式并用全局修饰符 g 方式，举例：</p>
<p>‘adobe abc’.replace(/b/g, ‘_’)<br>// “ado_e a_c”<br>B、 高级用法<br>第二个参数可以使用 function，其中有三个参数，分别为 匹配的字符串、当前匹配的字符串index值、匹配的源字符串，最终结果根据每次匹配结果进行相应的替换<br>举例：</p>
<p>‘adobe aacc bbaa’.replace(/a+/g, function(str, index, source){<br>    if(index &gt; 0){<br>        return str.toUpperCase();<br>    } else {<br>        return str;<br>    }<br>});<br>// “adobe AAcc bbAA”<br>第二部分 案例分析<br>一、常见匹配<br>在写正则之前，需要注意以下几点：</p>
<p>一定要清楚期望的规则是什么，不然无从匹配<br>有些正则不只一种写法，要注意简短干练，复杂的正则表达式不仅难懂，而且容易出BUG，性能也不是很好<br>正则虽好，可要适度奥。有些字符串处理不一定适合用正则<br>1、手机号<br>规则：以1开头第二位为3、5、7、8且长度为11位的数字组合</p>
<p>/^1[3578]\d{9}$/.test(13600001111);<br>// true<br>2、 字符串提取<br>举例：提取字符串中的数字<br>分析：<br>根据对数字的理解，可能为负数，即-?，如果是负数，其后需要是数字且至少一位，即 -?\d+，小数部分可能有也可能没有，所以需要对小数部分括弧起来用 ? 或 {0, 1}限定，因为.是特殊字符需要转义，于是表达式为：-?\d+(.\d+)?</p>
<p>‘(12.3 - 32.3)*2 = -40’.match(/-?\d+(.\d+)?/g);<br>// [“12.3”, “32.3”, “2”, “-40”]<br>二、jQuery中的正则片段<br>1、表达式<br>在jQuery 3.1.2-pre中找到一个解析单标签的正则，如下：</p>
<p>/^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]<em>)[\x20\t\r\n\f]</em>\/?&gt;(?:&lt;\/\1&gt;|)$/i<br>2、分解<br>乍一看有点懵，其实拆解之后就容易理解了，注意拆解的步骤，通常来说：<br>1） 第一步可以先看括号 () ，可以将各个小括号及非括号的分成不同部分，如</p>
<p>/^&lt;  ([a-z][^\/\0&gt;:\x20\t\r\n\f]<em>)  [\x20\t\r\n\f]</em>\/?&gt;  (?:&lt;\/\1&gt;|)  $/i<br>2） 第二步可以将中括号分开</p>
<p>/^&lt;  (  [a-z]  [^\/\0&gt;:\x20\t\r\n\f]<em>  )  [\x20\t\r\n\f]</em>  \/?&gt;  (?:&lt;\/\1&gt;|)  $/i<br>现在是不是已经很清楚了，接下来分解下，就很容易理解了<br>3、详解<br>● 1）^&lt; 很明显在匹配标签左尖括号括号，且以其开始</p>
<p>● 2）( [a-z] [^\/\0&gt;:\x20\t\r\n\f]<em> ) 这个括号有两部分，第一个 [a-z] 没什么好解释，即标签&lt;紧跟的必须为字母，因为全局加了 i(忽略大小写) 修饰符，所以大小写字母都可以；[^\/\0&gt;:\x20\t\r\n\f]</em>，及限制标签名必须以字母开始，且第二个字母不能为/ \0 &gt; : \20 t \r \n \f的任意多个字符（思考为什么），() 表示对标签的分组，方便取到标签名</p>
<p>● 3）[\x20\t\r\n\f]<em> 表示可能含有 [\x20\t\r\n\f] 这些特殊字符，与前面的 [^\/\0&gt;:\x20\t\r\n\f]</em> 相似却不一样，通过这里可以看出&lt;br之后进行回车也能匹配到<br>● 4）/?&gt; 能匹配<br>或</p>
<p>● 5）(?:&lt;\/\1&gt;|) 这里不捕获，并用\1去反向引用第一个括号的表达式 ([a-z][^\/\0&gt;:\x20\t\r\n\f]*)。这里的|表示 &lt;/\1&gt; 可有可无，即：(?:&lt;\/\1&gt;|) 与 (?:&lt;\/\1&gt;)?匹配结果一样</p>
<p>作者：_双眸<br>链接：<a href="https://www.jianshu.com/p/488d60349325" target="_blank" rel="noopener">https://www.jianshu.com/p/488d60349325</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>另外，下面有两个关于正则的链接：<br>1.<a href="https://zhuanlan.zhihu.com/p/92573380" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/92573380</a> (老师总结的关于正则)<br>2.<a href="https://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="noopener">https://www.runoob.com/regexp/regexp-syntax.html</a> (老师文章里的正则基础)</p>
<p>刚又看到一个总结的比较全的链接：<a href="https://blog.csdn.net/h610443955/article/details/81079439" target="_blank" rel="noopener">https://blog.csdn.net/h610443955/article/details/81079439</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/07/js正则表达式基础总结/" data-id="ck3e9zcom000intxqz03zh5l9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-jq源码解析-2-3-1-jq的Callbacks入门-原理分析" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/02/网易微专业-jq源码解析-2-3-1-jq的Callbacks入门-原理分析/" class="article-date">
  <time datetime="2019-11-02T08:54:09.000Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/02/网易微专业-jq源码解析-2-3-1-jq的Callbacks入门-原理分析/">网易微专业-jq源码解析-2.3.1-jq的Callbacks入门&amp;原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、关于$.Callbacks<br>1、callbacks介绍<br>·$.Callbacks用于管理函数队列<br>·通过add添加处理函数到队列当中，通过fire去执行这些处理函数<br>另:$.Callbacks是在jQuery内部使用的，如为 .ajax，$.Deferred等组件提供基础功能的函数。它也可以用在类似功能的一些组件中，如自己开发的插件。<br>API例子：<br>var cb = $.Callbacks();<br>cb.add(function(){console.log(‘add one’)});//add() 添加处理函数<br>cb.fire();//add one //fire()按照添加函数的顺序依次执行处理函数<br>2、参数<br>$.Callbacks通过字符串参数的形式，支持4种特定功能：<br>once:函数队列只执行一次<br><img src="https://snakexu.github.io/images/wangyi/jq/callback_2.png"><br>unique:往内部队列添加的函数保持唯一，不能重复添加<br><img src="https://snakexu.github.io/images/wangyi/jq/callback_3.png"><br>stopOnFalse:内部队列里的函数是依次执行的，当某个函数的返回值是false时，停止继续执行剩下的函数<br><img src="https://snakexu.github.io/images/wangyi/jq/callback_4.png"><br>memory:当函数队列fire一次过后，内部函数会记录当前fire的参数。当下次调用add的时候，会把记录的参数传递给新添加的函数并立即执行这个新添加的函数<br><img src="https://snakexu.github.io/images/wangyi/jq/callback_5.png"><br>3、从事件函数了解callbacks<br>事件通常与函数配合使用，这样就可以通过发生的事件来驱动函数的执行。<br>原则：<br>(1)一个事件对应一个事件函数<br>(2)在一个事件对应多个事件函数的情况下，后者会覆盖前者<br>例：<br>Element.onclick = function() {<br>  console.log(code);<br>}<br>Element.onclick = function() {<br>  console.log(code1);<br>}<br>我们往DOM元素上绑定两次onclick事件，当我们触发该点击事件时，只触发打印code1。<br>如果我们想要改变这种一对一的原则，那可以按照下列栗子对事件驱动方案进行改造。<br>var callbacks = [function(){}, function(){}, function(){}];<br>Element.onclick = function() {<br>  var _this = this;<br>  callbacks.forEach(function(fn) {<br>    fn.call(_this);<br>  })<br>}<br>首先，可以先将函数存储在callbacks数组中，在元素绑定的onclick函数上去遍历并依次执行处理函数。这样就建立起一对多的事件模型。<br>这时候的callbacks是一个数组。但我们其实更想callbacks它不仅是一个数组，更是一个容器，能比数组赋予更多的功能。<br>callbacks作为数组时，虽然可以通过push添加元素，通过循环执行函数。但我们如果想通过参数去在添加元素时控制数组的形成，在执行的之后通过参数去控制哪些执行哪些不执行，这时候callbacks就应运而生。jQuery的callbacks中对外提供add和fire两个方法，该两个方法的功能与数组的push和遍历执行功能类似，但可以根据传入的参数去控制执行函数的执行。<br>二、源码实现</p>
<p><pre><br>(function(root){<br>    var optionsCache = {};<br>    var _ = {<br>        //options参数,接收once、unique、stopOnFalse、memory这四个参数之一<br>        callbacks:function(options){<br>            options = typeof options === ‘string’ ? (optionsCache[options] || createOptions(options)) : {};<br>            var list = [];//执行队列<br>            //这里定义的变量基本都是用于记录队列执行进度，根据各种不同的参数记录不同的数值<br>            var index, length, testting, memory, starts, start;<br>            //执行方法，执行队列<br>            var fire = function(data){<br>                memory = options.memory &amp;&amp; data;<br>                //如果有参数memory，则需要从上次队列执行到的地方开始执行，否则从list队列里下标为0的地方开始执行<br>                index = starts || 0;<br>                start = 0;<br>                testting = true;<br>                length = list.length;<br>                for(; index &lt; length ; index++){<br>                    //data[0]绑定上下文执行环境对象,options.stopOnFalse调用$.Callbacks是否传递参数stopOnFalse<br>                    if(list[index].apply(data[0], data[1]) === false &amp;&amp; options.stopOnFalse){<br>                        break;<br>                    }<br>                }<br>            }<br>            //这里函数颗粒度的划分的思路add/fire/fireWith然后再去fire()执行<br>            var self = {<br>                //添加<br>                add:function(){<br>                    var args = Array.prototype.slice.call(arguments);<br>                    start = list.length;<br>                    args.forEach(function(fn){<br>                        if(toString.call(fn) === ‘[object Function]’){<br>                            list.push(fn);<br>                        }<br>                    });<br>                    if(memory){<br>                        starts = start;<br>                        fire(memory)<br>                    }<br>                },<br>                //函数执行过程中上下文的绑定<br>                fireWith:function(context, arguments){<br>                    var args = [context, arguments];<br>                    if(!options.once || !testting){<br>                        fire(args)<br>                    }<br>                },<br>                //与callbacks的执行方法fire不同<br>                fire:function(){<br>                    //this-&gt;self,传递上下文执行环境<br>                    self.fireWith(this, arguments);<br>                }<br>            }<br>            //个人认为第一个需要注意的思路<br>            return self;//每次调用callbacks都返回一个队列，队列里对应有add和fire的操作<br>        }<br>    }<br>    function createOptions(options){<br>        var object = optionsCache[options] = {};<br>        //如果参数为一个以上，如$.Callbacks(“once memory”)<br>        options.split(/\s+/).forEach(function(value){<br>            object[value] = true;<br>        })<br>        retrun object;<br>    }<br>    root._ = _;<br>})(this);<br></pre><br><!--线性队列处理提供了很好的思路--><br>add方法的核心，其实就是把参数这种类数组转换为数组，并循环push到定义的list数组中，这个list数组也称之为队列。<br>fire方法的调用比较复杂，之所以要拆开为self.fire、self.fireWith、fire三个函数，是为了后续的参数控制做准备。self.fire是用于调用时进行传参，fire是通过call方法去执行队列list中的执行函数，其上下文是self.fireWith进行绑定的。当然，self.fireWith的作用远不止如此，后续我们会继续说到。<br>注意：最后一行代码，callbacks最后会返回self，这是一个很核心的设计。那我们就要思考，这里为什么不将add、fire方法直接返回呢？原因是，我们想要每次调用self，最终返回出去的是一个队列，这样每次调用所得到的队列都是不同的，彼此之之间不会相互影响。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/02/网易微专业-jq源码解析-2-3-1-jq的Callbacks入门-原理分析/" data-id="ck3e9zcob000fntxqp6yivv31" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/25/网易微专业-Underscore-3-1-3-undefined的处理iteratee设计-源代码/">网易微专业-Underscore-3.1.3-undefined的处理iteratee设计-源代码</a>
          </li>
        
          <li>
            <a href="/2019/11/25/网易微专业-Underscore-3-1-3-undefined的处理iteratee设计/">网易微专业-Underscore-3.1.3-undefined的处理iteratee设计</a>
          </li>
        
          <li>
            <a href="/2019/11/24/网易微专业-Underscore-3-1-2-Underscore整体结构-面向对象风格支持/">网易微专业-Underscore-3.1.2-Underscore整体结构&amp;面向对象风格支持</a>
          </li>
        
          <li>
            <a href="/2019/11/24/网易微专业-Underscore-3-1-1-函数式编程思想概述/">网易微专业-Underscore-3.1.1-函数式编程思想概述</a>
          </li>
        
          <li>
            <a href="/2019/11/24/网易微专业-jq源码解析-1118直播课-拆箱装箱/">网易微专业-jq源码解析-1118直播课-拆箱装箱</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>