<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="喵小喵的窝">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="喵小喵的窝">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue-cli了解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/08/vue-cli了解/" class="article-date">
  <time datetime="2020-05-08T02:32:20.000Z" itemprop="datePublished">2020-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/08/vue-cli了解/">vue-cli了解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一直觉得自己对cli的了解太少了，于是有了这篇文章，看一点源码写一点东西吧，至于能写多少，希望我坚持到底<br>首先git clone <a href="https://github.com/vuejs/vue-cli.git" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli.git</a> 下载源码，想着用vue-cli创建项目的命令是vue create，我找到了packages/@vue/cli/bin/vue.js文件，就从这里开始吧。</p>
<pre>
//chalk用于高亮终端打印出来的信息，semver版本号处理工具
const { chalk, semver } = require('@vue/cli-shared-utils')
//获取node版本
//"engines": {
//    "node": ">=8.9"
//}
const requiredVersion = require('../package.json').engines.node
//比较两个字符之间的差异
const leven = require('leven')
//先检测下node版本号是不是符合要求，不符合提示更新node并退出进程
function checkNodeVersion (wanted, id) {
  if (!semver.satisfies(process.version, wanted)) {
    console.log(chalk.red(
      'You are using Node ' + process.version + ', but this version of ' + id +
      ' requires Node ' + wanted + '.\nPlease upgrade your Node version.'
    ))
    process.exit(1)
  }
}
checkNodeVersion(requiredVersion, '@vue/cli')
//虽然希望你的node版本高于8.9，但是这里还是贴心的提示，9.X版本可能不再继续支持，赶紧更新版本为长期支持的版本
if (semver.satisfies(process.version, '9.x')) {
  console.log(chalk.red(
    `You are using Node ${process.version}.\n` +
    `Node.js 9.x has already reached end-of-life and will not be supported in future major releases.\n` +
    `It's strongly recommended to use an active LTS version instead.`
  ))
}
const fs = require('fs')
const path = require('path')
//用于转换 Windows 反斜杠路径转换为正斜杠路径 \ => /
const slash = require('slash')
//轻量级的命令行参数解析引擎
const minimist = require('minimist')
// enter debug mode when creating test repo
if (
  slash(process.cwd()).indexOf('/packages/test') > 0 && (
    fs.existsSync(path.resolve(process.cwd(), '../@vue')) ||
    fs.existsSync(path.resolve(process.cwd(), '../../@vue'))
  )
) {
  process.env.VUE_CLI_DEBUG = true
}
//https://www.cnblogs.com/mirandachen/p/9826886.html commander的API
const program = require('commander')//node.js命令行界面的完整解决方案
const loadCommand = require('../lib/util/loadCommand')//安装检测代码
program
  .version(`@vue/cli ${require('../package').version}`)
  .usage('< command > [options]')
//获取命令行参数，传递到create
program
  .command('create < app-name>')
  .description('create a new project powered by vue-cli-service')
  .option('-p, --preset < presetName>', 'Skip prompts and use saved or remote preset')
  .option('-d, --default', 'Skip prompts and use default preset')
  .option('-i, --inlinePreset < json>', 'Skip prompts and use inline JSON string as preset')
  .option('-m, --packageManager < command>', 'Use specified npm client when installing dependencies')
  .option('-r, --registry < url>', 'Use specified npm registry when installing dependencies (only for npm)')
  .option('-g, --git [message]', 'Force git initialization with initial commit message')
  .option('-n, --no-git', 'Skip git initialization')
  .option('-f, --force', 'Overwrite target directory if it exists')
  .option('--merge', 'Merge target directory if it exists')
  .option('-c, --clone', 'Use git clone when fetching remote preset')
  .option('-x, --proxy', 'Use specified proxy when creating project')
  .option('-b, --bare', 'Scaffold project without beginner instructions')
  .option('--skipGetStarted', 'Skip displaying "Get started" instructions')
  .action((name, cmd) => {
    const options = cleanArgs(cmd)
    if (minimist(process.argv.slice(3))._.length > 1) {
      console.log(chalk.yellow('\n Info: You provided more than one argument. The first one will be used as the app\'s name, the rest are ignored.'))
    }
    // --git makes commander to default git to true
    if (process.argv.includes('-g') || process.argv.includes('--git')) {
      options.forceGit = true
    }
    //把经过处理的命令行参数传递到create中
    require('../lib/create')(name, options)
  })
//这后面还有一些命令行的处理，我们不贪多，先从主要脉络看起
</pre>
loadCommand.js代码
<pre>
module.exports = function loadCommand (commandName, moduleName) {
  const isNotFoundError = err => {
    return err.message.match(/Cannot find module/)
  }
  try {
    return require(moduleName)
  } catch (err) {
    if (isNotFoundError(err)) {
      try {
        return require('import-global')(moduleName)
      } catch (err2) {
        if (isNotFoundError(err2)) {
          const { chalk, hasYarn, hasPnpm3OrLater } = require('@vue/cli-shared-utils')
          let installCommand = `npm install -g`
          if (hasYarn()) {
            installCommand = `yarn global add`
          } else if (hasPnpm3OrLater()) {
            installCommand = `pnpm install -g`
          }
          console.log()
          console.log(
            `  Command ${chalk.cyan(`vue ${commandName}`)} requires a global addon to be installed.\n` +
            `  Please run ${chalk.cyan(`${installCommand} ${moduleName}`)} and try again.`
          )
          console.log()
          process.exit(1)
        } else {
          throw err2
        }
      }
    } else {
      throw err
    }
  }
}
</pre>
create.js
<pre>
const fs = require('fs-extra')//fs-extra模块是系统fs模块的扩展，提供了更多便利的 API，并继承了fs模块的 API
const path = require('path')
const inquirer = require('inquirer')//用户与命令行交互的工具
const Creator = require('./Creator')
const { clearConsole } = require('./util/clearConsole')
const { getPromptModules } = require('./util/createTools')
const { chalk, error, stopSpinner, exit } = require('@vue/cli-shared-utils')
const validateProjectName = require('validate-npm-package-name')
async function create (projectName, options) {
  //projectName,options都是从命令行获取的
  //projectName项目名称
  //options创建项目的参数
  if (options.proxy) {
    process.env.HTTP_PROXY = options.proxy
  }
  const cwd = options.cwd || process.cwd()
  const inCurrent = projectName === '.'
  const name = inCurrent ? path.relative('../', cwd) : projectName
  const targetDir = path.resolve(cwd, projectName || '.')
  //判断项目名称是否可用
  const result = validateProjectName(name)
  if (!result.validForNewPackages) {
    console.error(chalk.red(`Invalid project name: "${name}"`))
    result.errors && result.errors.forEach(err => {
      console.error(chalk.red.dim('Error: ' + err))
    })
    result.warnings && result.warnings.forEach(warn => {
      console.error(chalk.red.dim('Warning: ' + warn))
    })
    exit(1)
  }
  //判断项目是否在当前目录生成，当前目录下是否已经存在项目
  if (fs.existsSync(targetDir) && !options.merge) {
    if (options.force) {
      await fs.remove(targetDir)
    } else {
      await clearConsole()
      if (inCurrent) {
        const { ok } = await inquirer.prompt([
          {
            name: 'ok',
            type: 'confirm',
            message: `Generate project in current directory?`
          }
        ])
        if (!ok) {
          return
        }
      } else {
        const { action } = await inquirer.prompt([
          {
            name: 'action',
            type: 'list',
            message: `Target directory ${chalk.cyan(targetDir)} already exists. Pick an action:`,
            choices: [
              { name: 'Overwrite', value: 'overwrite' },
              { name: 'Merge', value: 'merge' },
              { name: 'Cancel', value: false }
            ]
          }
        ])
        if (!action) {
          return
        } else if (action === 'overwrite') {
          console.log(`\nRemoving ${chalk.cyan(targetDir)}...`)
          await fs.remove(targetDir)
        }
      }
    }
  }
  const creator = new Creator(name, targetDir, getPromptModules())
  await creator.create(options)
}
module.exports = (...args) => {
  return create(...args).catch(err => {
    stopSpinner(false) // do not persist
    error(err)
    if (!process.env.VUE_CLI_TEST) {
      process.exit(1)
    }
  })
}
</pre>
在packages/@vue/cli/lib/create中，首先通过vlidate-npm-package-name处理包名是否合规。接着在目标文件存在的情况下来提供用户处理目标文件的交互。这一段代码比较好理解，最后生成creator类并调用了creator.create方法。
<b>creator.js</b>
<pre>
const path = require('path')
const debug = require('debug')
const inquirer = require('inquirer')
const EventEmitter = require('events')
const Generator = require('./Generator')
const cloneDeep = require('lodash.clonedeep')
//sortObject有三个参数(对象，排序关键字，不根据Unicode排序)
const sortObject = require('./util/sortObject')
const getVersions = require('./util/getVersions')
const PackageManager = require('./util/ProjectPackageManager')
const { clearConsole } = require('./util/clearConsole')
const PromptModuleAPI = require('./PromptModuleAPI')
const writeFileTree = require('./util/writeFileTree')
const { formatFeatures } = require('./util/features')
const loadLocalPreset = require('./util/loadLocalPreset')
const loadRemotePreset = require('./util/loadRemotePreset')
const generateReadme = require('./util/generateReadme')
const { resolvePkg } = require('@vue/cli-shared-utils')

const {
  defaults,
  saveOptions,
  loadOptions,
  savePreset,
  validatePreset,
  rcPath
} = require('./options')

const {
  chalk,
  execa,

  log,
  warn,
  error,
  logWithSpinner,
  stopSpinner,

  hasGit,
  hasProjectGit,
  hasYarn,
  hasPnpm3OrLater,
  hasPnpmVersionOrLater,

  exit,
  loadModule
} = require('@vue/cli-shared-utils')

const isManualMode = answers => answers.preset === '__manual__'

module.exports = class Creator extends EventEmitter {
  constructor (name, context, promptModules) {
    super()

    this.name = name
    this.context = process.env.VUE_CLI_CONTEXT = context
    const { presetPrompt, featurePrompt } = this.resolveIntroPrompts()
    this.presetPrompt = presetPrompt
    this.featurePrompt = featurePrompt
    this.outroPrompts = this.resolveOutroPrompts()
    this.injectedPrompts = []
    this.promptCompleteCbs = []
    this.afterInvokeCbs = []
    this.afterAnyInvokeCbs = []

    this.run = this.run.bind(this)

    const promptAPI = new PromptModuleAPI(this)
    promptModules.forEach(m => m(promptAPI))
  }

  async create (cliOptions = {}, preset = null) {
    const isTestOrDebug = process.env.VUE_CLI_TEST || process.env.VUE_CLI_DEBUG
    const { run, name, context, afterInvokeCbs, afterAnyInvokeCbs } = this

    if (!preset) {
      if (cliOptions.preset) {
        // vue create foo --preset bar
        preset = await this.resolvePreset(cliOptions.preset, cliOptions.clone)
      } else if (cliOptions.default) {
        // vue create foo --default
        preset = defaults.presets.default
      } else if (cliOptions.inlinePreset) {
        // vue create foo --inlinePreset {...}
        try {
          preset = JSON.parse(cliOptions.inlinePreset)
        } catch (e) {
          error(`CLI inline preset is not valid JSON: ${cliOptions.inlinePreset}`)
          exit(1)
        }
      } else {
        preset = await this.promptAndResolvePreset()
      }
    }

    // clone before mutating
    preset = cloneDeep(preset)
    // inject core service
    preset.plugins['@vue/cli-service'] = Object.assign({
      projectName: name
    }, preset)

    if (cliOptions.bare) {
      preset.plugins['@vue/cli-service'].bare = true
    }

    // legacy support for router
    if (preset.router) {
      preset.plugins['@vue/cli-plugin-router'] = {}

      if (preset.routerHistoryMode) {
        preset.plugins['@vue/cli-plugin-router'].historyMode = true
      }
    }

    // legacy support for vuex
    if (preset.vuex) {
      preset.plugins['@vue/cli-plugin-vuex'] = {}
    }

    const packageManager = (
      cliOptions.packageManager ||
      loadOptions().packageManager ||
      (hasYarn() ? 'yarn' : null) ||
      (hasPnpm3OrLater() ? 'pnpm' : 'npm')
    )
    const pm = new PackageManager({ context, forcePackageManager: packageManager })

    await clearConsole()
    logWithSpinner(`✨`, `Creating project in ${chalk.yellow(context)}.`)
    this.emit('creation', { event: 'creating' })

    // get latest CLI plugin version
    const { latestMinor } = await getVersions()

    // generate package.json with plugin dependencies
    const pkg = {
      name,
      version: '0.1.0',
      private: true,
      devDependencies: {},
      ...resolvePkg(context)
    }
    const deps = Object.keys(preset.plugins)
    deps.forEach(dep => {
      if (preset.plugins[dep]._isPreset) {
        return
      }

      // Note: the default creator includes no more than `@vue/cli-*` & `@vue/babel-preset-env`,
      // so it is fine to only test `@vue` prefix.
      // Other `@vue/*` packages' version may not be in sync with the cli itself.
      pkg.devDependencies[dep] = (
        preset.plugins[dep].version ||
        ((/^@vue/.test(dep)) ? `~${latestMinor}` : `latest`)
      )
    })

    // write package.json
    await writeFileTree(context, {
      'package.json': JSON.stringify(pkg, null, 2)
    })

    // intilaize git repository before installing deps
    // so that vue-cli-service can setup git hooks.
    const shouldInitGit = this.shouldInitGit(cliOptions)
    if (shouldInitGit) {
      logWithSpinner(`🗃`, `Initializing git repository...`)
      this.emit('creation', { event: 'git-init' })
      await run('git init')
    }

    // install plugins
    stopSpinner()
    log(`⚙\u{fe0f}  Installing CLI plugins. This might take a while...`)
    log()
    this.emit('creation', { event: 'plugins-install' })

    if (isTestOrDebug && !process.env.VUE_CLI_TEST_DO_INSTALL_PLUGIN) {
      // in development, avoid installation process
      await require('./util/setupDevProject')(context)
    } else {
      await pm.install()
    }

    // run generator
    log(`🚀  Invoking generators...`)
    this.emit('creation', { event: 'invoking-generators' })
    const plugins = await this.resolvePlugins(preset.plugins)
    const generator = new Generator(context, {
      pkg,
      plugins,
      afterInvokeCbs,
      afterAnyInvokeCbs
    })
    await generator.generate({
      extractConfigFiles: preset.useConfigFiles
    })

    // install additional deps (injected by generators)
    log(`📦  Installing additional dependencies...`)
    this.emit('creation', { event: 'deps-install' })
    log()
    if (!isTestOrDebug) {
      await pm.install()
    }

    // run complete cbs if any (injected by generators)
    logWithSpinner('⚓', `Running completion hooks...`)
    this.emit('creation', { event: 'completion-hooks' })
    for (const cb of afterInvokeCbs) {
      await cb()
    }
    for (const cb of afterAnyInvokeCbs) {
      await cb()
    }

    // generate README.md
    stopSpinner()
    log()
    logWithSpinner('📄', 'Generating README.md...')
    await writeFileTree(context, {
      'README.md': generateReadme(generator.pkg, packageManager)
    })

    // generate a .npmrc file for pnpm, to persist the `shamefully-flatten` flag
    if (packageManager === 'pnpm') {
      const pnpmConfig = hasPnpmVersionOrLater('4.0.0')
        ? 'shamefully-hoist=true\n'
        : 'shamefully-flatten=true\n'

      await writeFileTree(context, {
        '.npmrc': pnpmConfig
      })
    }

    // commit initial state
    let gitCommitFailed = false
    if (shouldInitGit) {
      await run('git add -A')
      if (isTestOrDebug) {
        await run('git', ['config', 'user.name', 'test'])
        await run('git', ['config', 'user.email', 'test@test.com'])
      }
      const msg = typeof cliOptions.git === 'string' ? cliOptions.git : 'init'
      try {
        await run('git', ['commit', '-m', msg])
      } catch (e) {
        gitCommitFailed = true
      }
    }

    // log instructions
    stopSpinner()
    log()
    log(`🎉  Successfully created project ${chalk.yellow(name)}.`)
    if (!cliOptions.skipGetStarted) {
      log(
        `👉  Get started with the following commands:\n\n` +
        (this.context === process.cwd() ? `` : chalk.cyan(` ${chalk.gray('$')} cd ${name}\n`)) +
        chalk.cyan(` ${chalk.gray('$')} ${packageManager === 'yarn' ? 'yarn serve' : packageManager === 'pnpm' ? 'pnpm run serve' : 'npm run serve'}`)
      )
    }
    log()
    this.emit('creation', { event: 'done' })

    if (gitCommitFailed) {
      warn(
        `Skipped git commit due to missing username and email in git config.\n` +
        `You will need to perform the initial commit yourself.\n`
      )
    }

    generator.printExitLogs()
  }

  run (command, args) {
    if (!args) { [command, ...args] = command.split(/\s+/) }
    return execa(command, args, { cwd: this.context })
  }

  async promptAndResolvePreset (answers = null) {
    // prompt
    if (!answers) {
      await clearConsole(true)
      answers = await inquirer.prompt(this.resolveFinalPrompts())
    }
    debug('vue-cli:answers')(answers)

    if (answers.packageManager) {
      saveOptions({
        packageManager: answers.packageManager
      })
    }

    let preset
    if (answers.preset && answers.preset !== '__manual__') {
      preset = await this.resolvePreset(answers.preset)
    } else {
      // manual
      preset = {
        useConfigFiles: answers.useConfigFiles === 'files',
        plugins: {}
      }
      answers.features = answers.features || []
      // run cb registered by prompt modules to finalize the preset
      this.promptCompleteCbs.forEach(cb => cb(answers, preset))
    }

    // validate
    validatePreset(preset)

    // save preset
    if (answers.save && answers.saveName && savePreset(answers.saveName, preset)) {
      log()
      log(`🎉  Preset ${chalk.yellow(answers.saveName)} saved in ${chalk.yellow(rcPath)}`)
    }

    debug('vue-cli:preset')(preset)
    return preset
  }

  async resolvePreset (name, clone) {
    let preset
    const savedPresets = loadOptions().presets || {}

    if (name in savedPresets) {
      preset = savedPresets[name]
    } else if (name.endsWith('.json') || /^\./.test(name) || path.isAbsolute(name)) {
      preset = await loadLocalPreset(path.resolve(name))
    } else if (name.includes('/')) {
      logWithSpinner(`Fetching remote preset ${chalk.cyan(name)}...`)
      this.emit('creation', { event: 'fetch-remote-preset' })
      try {
        preset = await loadRemotePreset(name, clone)
        stopSpinner()
      } catch (e) {
        stopSpinner()
        error(`Failed fetching remote preset ${chalk.cyan(name)}:`)
        throw e
      }
    }

    // use default preset if user has not overwritten it
    if (name === 'default' && !preset) {
      preset = defaults.presets.default
    }
    if (!preset) {
      error(`preset "${name}" not found.`)
      const presets = Object.keys(savedPresets)
      if (presets.length) {
        log()
        log(`available presets:\n${presets.join(`\n`)}`)
      } else {
        log(`you don't seem to have any saved preset.`)
        log(`run vue-cli in manual mode to create a preset.`)
      }
      exit(1)
    }
    return preset
  }

  // { id: options } => [{ id, apply, options }]
  async resolvePlugins (rawPlugins) {
    // ensure cli-service is invoked first
    rawPlugins = sortObject(rawPlugins, ['@vue/cli-service'], true)
    const plugins = []
    for (const id of Object.keys(rawPlugins)) {
      const apply = loadModule(`${id}/generator`, this.context) || (() => {})
      let options = rawPlugins[id] || {}
      if (options.prompts) {
        const prompts = loadModule(`${id}/prompts`, this.context)
        if (prompts) {
          log()
          log(`${chalk.cyan(options._isPreset ? `Preset options:` : id)}`)
          options = await inquirer.prompt(prompts)
        }
      }
      plugins.push({ id, apply, options })
    }
    return plugins
  }

  getPresets () {
    const savedOptions = loadOptions()
    return Object.assign({}, savedOptions.presets, defaults.presets)
  }

  resolveIntroPrompts () {
    const presets = this.getPresets()
    const presetChoices = Object.keys(presets).map(name => {
      return {
        name: `${name} (${formatFeatures(presets[name])})`,
        value: name
      }
    })
    const presetPrompt = {
      name: 'preset',
      type: 'list',
      message: `Please pick a preset:`,
      choices: [
        ...presetChoices,
        {
          name: 'Manually select features',
          value: '__manual__'
        }
      ]
    }
    const featurePrompt = {
      name: 'features',
      when: isManualMode,
      type: 'checkbox',
      message: 'Check the features needed for your project:',
      choices: [],
      pageSize: 10
    }
    return {
      presetPrompt,
      featurePrompt
    }
  }

  resolveOutroPrompts () {
    const outroPrompts = [
      {
        name: 'useConfigFiles',
        when: isManualMode,
        type: 'list',
        message: 'Where do you prefer placing config for Babel, ESLint, etc.?',
        choices: [
          {
            name: 'In dedicated config files',
            value: 'files'
          },
          {
            name: 'In package.json',
            value: 'pkg'
          }
        ]
      },
      {
        name: 'save',
        when: isManualMode,
        type: 'confirm',
        message: 'Save this as a preset for future projects?',
        default: false
      },
      {
        name: 'saveName',
        when: answers => answers.save,
        type: 'input',
        message: 'Save preset as:'
      }
    ]

    // ask for packageManager once
    const savedOptions = loadOptions()
    if (!savedOptions.packageManager && (hasYarn() || hasPnpm3OrLater())) {
      const packageManagerChoices = []

      if (hasYarn()) {
        packageManagerChoices.push({
          name: 'Use Yarn',
          value: 'yarn',
          short: 'Yarn'
        })
      }

      if (hasPnpm3OrLater()) {
        packageManagerChoices.push({
          name: 'Use PNPM',
          value: 'pnpm',
          short: 'PNPM'
        })
      }

      packageManagerChoices.push({
        name: 'Use NPM',
        value: 'npm',
        short: 'NPM'
      })

      outroPrompts.push({
        name: 'packageManager',
        type: 'list',
        message: 'Pick the package manager to use when installing dependencies:',
        choices: packageManagerChoices
      })
    }

    return outroPrompts
  }

  resolveFinalPrompts () {
    // patch generator-injected prompts to only show in manual mode
    this.injectedPrompts.forEach(prompt => {
      const originalWhen = prompt.when || (() => true)
      prompt.when = answers => {
        return isManualMode(answers) && originalWhen(answers)
      }
    })
    const prompts = [
      this.presetPrompt,
      this.featurePrompt,
      ...this.injectedPrompts,
      ...this.outroPrompts
    ]
    debug('vue-cli:prompts')(prompts)
    return prompts
  }

  shouldInitGit (cliOptions) {
    if (!hasGit()) {
      return false
    }
    // --git
    if (cliOptions.forceGit) {
      return true
    }
    // --no-git
    if (cliOptions.git === false || cliOptions.git === 'false') {
      return false
    }
    // default: true unless already in a git repo
    return !hasProjectGit(this.context)
  }
}
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/08/vue-cli了解/" data-id="ckchm0riq004u5ajhees4uztm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-node-Koa源码分析-2-2-1-Koa类构造函数设计" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/07/网易微专业-node-Koa源码分析-2-2-1-Koa类构造函数设计/" class="article-date">
  <time datetime="2020-05-07T07:09:50.000Z" itemprop="datePublished">2020-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/07/网易微专业-node-Koa源码分析-2-2-1-Koa类构造函数设计/">网易微专业-node-Koa源码分析-2.2.1-Koa类构造函数设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.集成Emitter<br>我们找到node_modules文件夹下的koa文件夹，找到package.json文件，看到main中的入口文件是lib/application.js，打开application.js</p>
<p><pre><br>// 判断是否为 genterator 方法(koa是基于async/await，而async/await是基于generator函数的)<br>const isGeneratorFunction = require(‘is-generator-function’);<br>// 设置debug的命明空间<br>const debug = require(‘debug’)(‘koa:application’);<br>// 当请求完成时执行的一个回调<br>const onFinished = require(‘on-finished’);<br>// 引入 response<br>const response = require(‘./response’);<br>// 中间件机制、剥洋葱模型<br>const compose = require(‘koa-compose’);<br>// 引入 context<br>const context = require(‘./context’);<br>// 引入 request<br>const request = require(‘./request’);<br>// 用于判断http状态的工具包<br>const statuses = require(‘statuses’);<br>// Node 原生事件驱动模块<br>const Emitter = require(‘events’);<br>// Node 原生工具包模块<br>const util = require(‘util’);<br>// Node 原生Stream模块<br>const Stream = require(‘stream’);<br>// Node 原生http模块<br>const http = require(‘http’);<br>// 用于返回对象指定的属性<br>const only = require(‘only’);<br>// 将基于koa生成器中间件转换成基于Promise的中间件<br>const convert = require(‘koa-convert’);<br>// 给出一些信息<br>const deprecate = require(‘depd’)(‘koa’);<br>// 用处创建Http Error的模块<br>const { HttpError } = require(‘http-errors’);<br></pre><br>2.构造函数<br>我们看到，application.js里边有这样的代码<br>module.exports = class Application extends Emitter<br>node是基于事件处理的，这里继承了node的event模块，在构造函数中看到<br>constructor(options) {<br>    // 调用父类进行构造<br>    super();<br>    // 设置一些初始值<br>    options = options || {};<br>    this.proxy = options.proxy || false;<br>    this.subdomainOffset = options.subdomainOffset || 2;<br>    this.proxyIpHeader = options.proxyIpHeader || ‘X-Forwarded-For’;<br>    this.maxIpsCount = options.maxIpsCount || 0;<br>    // 区分开发环境还是生产环境<br>    this.env = options.env || process.env.NODE_ENV || ‘development’;<br>    if (options.keys) this.keys = options.keys;<br>    // 将中间件保存到数组中<br>    this.middleware = [];<br>    this.context = Object.create(context);<br>    this.request = Object.create(request);<br>    this.response = Object.create(response);<br>    if (util.inspect.custom) {<br>      this[util.inspect.custom] = this.inspect;<br>    }<br> }<br><br>也就是说我们new Koa()的时候是可以根据需要传递参数的，在这里老师讲了一下每个参数的意义，部分写了注释<br>3.初始化功能<br>继续看application.js文件的Application的listen</p>
<p><pre><br>//监听端口，启动服务<br>listen(…args) {<br>    debug(‘listen’);<br>    //利用http模块创建服务，传入回调函数，以及监听端口<br>    const server = http.createServer(this.callback());<br>    return server.listen(…args);<br>}<br>//app.callback()<br>//执行后，返回一个(req,res)=&gt;{}<br>//构建了ctx<br>callback() {<br>    const fn = compose(this.middleware);</pre></p>
<pre><code>if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror);

const handleRequest = (req, res) =&gt; {
  const ctx = this.createContext(req, res);
  return this.handleRequest(ctx, fn);
};

return handleRequest;
</code></pre><p>}<br>//用于构建上下文对象<br>createContext(req, res) {<br>    const context = Object.create(this.context);<br>    const request = context.request = Object.create(this.request);<br>    const response = context.response = Object.create(this.response);<br>    context.app = request.app = response.app = this;<br>    context.req = request.req = response.req = req;<br>    context.res = request.res = response.res = res;<br>    request.ctx = response.ctx = context;<br>    request.response = response;<br>    response.request = request;<br>    context.originalUrl = request.originalUrl = req.url;<br>    context.state = {};<br>    return context;<br>}<br><br>4.简单模拟本节课内容<br>新建一个项目simple-koa，建立文件夹lib，然后touch application.js</p>
<p><pre><br>const http = require(‘http’);</pre></p>
<p>class Application {<br>    constructor() {<br>        this.callbackFunc;<br>    }</p>
<pre><code>listen(...args) {
    let server = http.createServer(this.callback());
    server.listen(...args);
}

use(fn) {
    this.callbackFunc = fn;
}

callback() {
    return (req, res) =&gt; {
        this.callbackFunc(req, res);
    };
}
</code></pre><p>}</p>
<p>module.exports = Application;<br><br>在根文件夹下touch demo.js</p>
<p><pre><br>const Koa = require(‘./lib/application’);<br>const app = new Koa();</pre></p>
<p>app.use((req, res) =&gt; {<br>    res.writeHeader(500);<br>    res.end(‘Server Error’);<br>});</p>
<p>app.listen(3000, () =&gt; {<br>    console.log(‘hello Simple Koa’);<br>});<br><br>初步模拟了koa的初始化。另外这里老师介绍了nodemon，这个插件就是node的热重启，安装在开发环境就好</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/07/网易微专业-node-Koa源码分析-2-2-1-Koa类构造函数设计/" data-id="ckchm0rge003d5ajhe1ozoss8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-node-Koa源码分析-2-1-1-Koa整体结构" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/06/网易微专业-node-Koa源码分析-2-1-1-Koa整体结构/" class="article-date">
  <time datetime="2020-05-06T00:45:43.000Z" itemprop="datePublished">2020-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/06/网易微专业-node-Koa源码分析-2-1-1-Koa整体结构/">网易微专业-node-Koa源码分析-2.1.1-Koa整体结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.web开发框架历史<br>Node.js本身就是web开发框架，在node中主要用于web服务器的模块就是http模块，下面我们回忆下如何使用http模块。创建一个文件夹，在命令行中进入文件夹，数额入npm init -y初始化项目。<br>http-server.js</p>
<pre>
const http = require('http')
http.createServer(function(req,res){
    res.end('Hello World')
}).listen(3000,function(){
    console.log('服务启动成功')
})
</pre>
使用node的http模块创建一个http服务还是比较简单的，但是在实际开发中会有更复杂的需求，所以有了基于nodejs的框架，express是其中之一
express-server.js
<pre>
const express = require('express');
const app = express()
app.get('/',function(req,res){
    res.send('hello world')
})
app.listen(3000)
</pre>
当然express的功能不仅仅是这样，我们找一个比较简单的实现一下，首先创建一个public文件夹，里面放入一些静态资源，并将express-server.js进行简单修改
<pre>
const express = require('express');
const app = express();
app.use(express.static('public'));
app.listen(3000);
</pre>
就可以看到public中的页面，这是express中间件的简单使用。
koa是express开发团队基于node.js平台的下一代开发框架
koa-server.js
<pre>
const Koa = require('koa');
const app = new Koa();
app.use(async ctx => {
    ctx.body = 'hello world!';
});
app.listen(3000)
</pre>
在express中是内置中间件的，但是在koa中把中间件分开，我们如果想使用koa的中间件需要安装koa-static，引入中间件之后，我们修改代码使用中间件
<pre>
const Koa = require('koa');
const app = new Koa();
const static = require('koa-static');

app.use(static(__dirname + '/public'));
app.listen(3000)
</pre>
重启服务看到与express使用中间件一样的效果，即看到public文件夹下的静态资源 
2.Koa源码目录结构
3.Koa主流程梳理
在我们创建的项目中新建flow-analysis.js
<pre>
const Koa = require('koa');
const app = new Koa();
// x-response-time
app.use(async (ctx, next) => {
    const start = Date.now();                           // ①
    await next();                                                   //  ②
    const ms = Date.now() - start;                  // ⑧
    ctx.set('X-Response-Time', `${ms}ms`);  // ⑨
});
//logger
app.use(async (ctx, next) => {
    const start = Date.now();                           // ③
    await next();                                                      // ④
    const ms = Date.now() - start;                     // ⑥
    console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);   // ⑦
});
// response
app.use(async ctx => { 
    ctx.body = 'Hello Wolrd';                                   // ⑤
});
app.listen(3000);

/**
 *  执行过程：
 *  1. 创建一个跟踪响应时间的 时间戳
 *  2.  等待下一个中间件执行完毕
 *  3. 创建另一个logger的持续时间
 *  4. 等待下一个中间件执行完毕
 *  5. 将响应体设置为 'hello world'
 *  6. 计算出logger的持续时间
 *  7. 输出logger
 *  8. 计算响应的持续是按
 *  9. 将 x-response-time 响应头设置好
 *  10. 交给koa处理
 */
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/06/网易微专业-node-Koa源码分析-2-1-1-Koa整体结构/" data-id="ckchm0rgd003a5ajh0ftf7kmp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业福利期-3-3-异步编程方法-发布-订阅" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/05/网易微专业福利期-3-3-异步编程方法-发布-订阅/" class="article-date">
  <time datetime="2020-05-05T09:39:21.000Z" itemprop="datePublished">2020-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/05/网易微专业福利期-3-3-异步编程方法-发布-订阅/">网易微专业福利期-3.3-异步编程方法-发布/订阅</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.理解发布/订阅<br>2.实现发布/订阅<br>3.Node.js的发布/订阅</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/05/网易微专业福利期-3-3-异步编程方法-发布-订阅/" data-id="ckchm0rh1004s5ajhrmyaepup" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构-树和二叉树" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/29/数据结构-树和二叉树/" class="article-date">
  <time datetime="2020-04-29T02:52:30.000Z" itemprop="datePublished">2020-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/29/数据结构-树和二叉树/">数据结构-树和二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h2>树形结构</h2><br>树形结构是一类重要的非线性数据结构。<br>树是n(n &gt;= 0)个结点的有限集。在任意一棵非空树中:<br>(1)有且仅有一个特定的称为根(Root)的结点<br>(2)当n &gt; 1时，其余结点可分为m(m &gt; 0)个互不相交的有限集T<sub>1</sub>,T<sub>2</sub>,…,T<sub>M</sub>，其中每一个集合本身又是一棵树，并且称为根的子树。<br>树的<b>结点</b>包含一个数据元素及若干指向其子树的分支。结点拥有的子树称为<b>结点的度</b>(Degree)。度为0的结点称为<b>叶子</b>(Leaf)或<b>终端结点</b>。度不为0的结点称为<b>非终端结点</b>或<b>分支结点</b>。<b>树的度</b>是树内各结点的度的最大值。结点的子树的根称为该结点的<b>孩子</b>(Child)，相应的，该结点称为孩子的<b>双亲</b>(Parent)。同一双亲的孩子之间互称<b>兄弟</b>。结点的<b>祖先</b>是从根到该结点所经分支上的所有结点。以某结点为根的子树中任一结点都称为该结点的<b>子孙</b>。<br>结点的<b>层次</b>(Level)是从根开始定义起，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为<b>堂兄弟</b>。树中结点的最大层次称为树的<b>深度</b>(Depth)或高度。<br>如果将树中结点的各子树看成从左至右是有序次的(即不能互换)，则成该树为<b>有序树</b>，否则称为<b>无序树</b>。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。<br><b>森林</b>(Forest)是m(m &gt;= 0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以森林和树相互递归的定义来描述树。<br>就逻辑结构而言，任何一棵树是一个二元组Tree=(root,F)，其中:root是数据元素，称作树的根结点；F是m(m &gt;= 0)棵树的森林，F=(T<sub>1</sub>,T<sub>2</sub>,…,T<sub>M</sub>)，其中T<sub>i</sub>=(r<sub>i</sub>,F<sub>i</sub>)称做根root的第i棵子树；当m!=0时，在树根和其子树森林之间存在下列关系:<br>RF = { &lt; root,r<sub>i</sub> &gt; | i = 1,2,…,m,m &gt; 0}<br>这个定义将有助于得到森林和树与二叉树之间转换的递归定义。<p></p>
<p></p><h3>二叉树</h3><br><b>二叉树</b>(Binary Tree)是另一种树形结构，它的特点是每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。<p></p>
<p></p><h6>二叉树的重要特性</h6><br>1.在二叉树的第i层上至多有2<sup>i-1</sup>个结点(i &gt;= 1)<br>2.深度为k第二叉树至多有2<sup>k</sup>-1个结点(k &gt;= 1)<br>3.对任何一棵二叉树T，如果其终端结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1<br>4.具有n个结点的完全二叉树的深度为parseInt(log<sub>2</sub>n)+1<br>5.如果对一棵有n个结点的完全二叉树(其深度为parseInt(log<sub>2</sub>n)+1)的结点按层序编号(从第一层到第parseInt(log<sub>2</sub>n)+1层，每层从左到右)，则对任一结点i(1 &lt;= i &lt;= n)，有<br>(1)如果i=1，则结点i是二叉树的根，无双亲；如果i &gt; 1，则其双亲parent(i)结点是parseInt(i/2)<br>(2)如果2<em>i &gt; n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子LCHILD(i)是结点2</em>i<br>(3)如果2<em>i+1 &gt; n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2</em>i+1<p></p>
<p>一棵深度为k且有2<sup>k</sup>-1个结点的二叉树称为<b>满二叉树</b>。深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为<b>完全二叉树</b>。<br><img src="https://snakexu.github.io/images/others/tree_1.jpeg"><br>上图(a)满二叉树；(b)完全二叉树；(c)&amp;(d)非完全二叉树</p>
<p></p><h4>二叉树的存储结构</h4><br>1.顺序存储结构<br>按照顺序存储结构的定义，在此约定，用一组地址看许的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组中下标为i-1的分量中。对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中<br>完全二叉树，图a<br><img src="https://snakexu.github.io/images/others/tree_2.jpeg"><br>二叉树，图b<br><img src="https://snakexu.github.io/images/others/tree_3.jpeg"><br>下图是上面两个二叉树的顺序存储，a是完全二叉树图a的顺序存储结构，b是二叉树图b的顺序存储结构<br><img src="https://snakexu.github.io/images/others/tree_4.jpeg"><br>由此可见，这种顺序存储结构仅适用于完全二叉树。因为，在醉话的情况下，一个深度为k且只有k个结点的单支树(树中不存在度为2度结点)却需要长度为2<sup>k</sup>-1的一维数组。<br>2.链式存储结构<br>设计不同的结点结构可构成不同形式的链式存储结构。由二叉树的定义得知，二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域:数据域和左右指针域。有时为了便于找到结点的双亲，则还可以在结点的结构中增加一个指向其双亲结点的指针域。利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表。链表的头指针指向二叉树的根结点。<br><img src="https://snakexu.github.io/images/others/tree_5.jpeg"><p></p>
<pre>
var BinaryTree =
    (value,parent,left,right) => ({ value, parent, left, right });
var banana = BinaryTree( "banana" );
var apple = banana.left = BinaryTree( "apple", banana );
var cherry = banana.right = BinaryTree( "cherry", banana );
var apricot = apple.right = BinaryTree( "apricot", apple );
var avocado = apricot.right = BinaryTree( "avocado", apricot );
var cantelope = cherry.left = BinaryTree( "cantelope", cherry );
var cucumber = cherry.right = BinaryTree( "cucumber", cherry );
var grape = cucumber.right = BinaryTree( "grape", cucumber );
</pre>
上面的代码生成的树如下图所示:
<img src="https://snakexu.github.io/images/others/tree_6.png">
<h3>遍历二叉树和线索二叉树</h3>
遍历二叉树:如何按照某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。"访问"的含义很广，可以是对结点作各种处理，如输出结点的信息等。
限定先左后右的遍历二叉树，有三种情况——
1.先序遍历
若二叉树为空，则空操作；否则:
(1)访问根结点
(2)先序遍历左子树
(3)先序遍历右子树
2.中序遍历
若二叉树为空，则空操作；否则:
(1)中序遍历左子树
(2)访问根结点
(3)中序遍历右子树
3.后序遍历
若二叉树为空，则空操作；否则:
(1)后序遍历左子树
(2)后序遍历右子树
(3)访问根结点
<pre>
//中序遍历
BinaryTree.leftEach = function leftEach(visitFn,node){
    if (node) {
        if (node.left) {
            leftEach( visitFn, node.left );
        }
        visitFn( node );
        if (node.right) {
            leftEach( visitFn, node.right );
        }
    }
};
BinaryTree.leftEach( node => console.log( node.value ), banana );
// apple apricot avocado banana cantelope cherry cucumber grape
// 仅访问根节点为 `cherry` 的子树
BinaryTree.leftEach( node => console.log( node.value ), cherry );
// cantelope cherry cucumber grape
//前序遍历
BinaryTree.preorderEach = function preorderEach(visitFn,node){
    visitFn( node );
    if (node.left) {
        preorderEach( visitFn, node.left );
    }
    if (node.right) {
        preorderEach( visitFn, node.right );
    }
};
BinaryTree.preorderEach( node => console.log( node.value ), banana );
//banana apple apricot avocado cherry cantelope cucumber grape
//后序遍历
BinaryTree.postEach = function postEach(visitFn,node){
    if (node.left) {
        postEach( visitFn, node.left );
    }
    if (node.right) {
        postEach( visitFn, node.right );
    }
    visitFn( node );
};
BinaryTree.postEach( node => console.log( node.value ), banana );
//avocado apricot apple cantelope grape cucumber cherry banana
//对树元素进行处理
BinaryTree.map = function map(mapperFn,node){
    if (node) {
        let newNode = mapperFn( node );
        newNode.parent = node.parent;
        newNode.left = node.left ?
            map( mapperFn, node.left ) : undefined;
        newNode.right = node.right ?
            map( mapperFn, node.right ): undefined;
        if (newNode.left) {
            newNode.left.parent = newNode;
        }
        if (newNode.right) {
            newNode.right.parent = newNode;
        }
        return newNode;
    }
};
var BANANA = BinaryTree.map(
    node => BinaryTree( node.value.toUpperCase() ),
    banana
);

BinaryTree.forEach( node => console.log( node.value ), BANANA );
// APPLE APRICOT AVOCADO BANANA CANTELOPE CHERRY CUCUMBER GRAPE
// https://cloud.tencent.com/developer/article/1013613
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/29/数据结构-树和二叉树/" data-id="ckchm0rfz002m5ajhfsb85aee" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构-线性表" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/24/数据结构-线性表/" class="article-date">
  <time datetime="2020-04-24T02:34:18.000Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/24/数据结构-线性表/">数据结构-线性表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为了复习数据结构，把大学时候的数据结构课本找出来了，希望能达到理想的效果吧。废话不多说，从线性结构开始。<br>线性结构的特点是:在数据元素的非空有限集合中，(1)存在唯一的一个被称作“第一个”的数据元素(2)存在唯一的一个被称作“最后一个”的数据元素(3)除第一个之外，集合中的每个数据元素均只有一个前驱(4)除最后一个之外，集合中每个数据元素均只有一个后续</p>
<p></p><h2>线性表</h2><br>线性表是最常用且最简单的一种数据结构。简而言之，一个线性表是N个数据元素的有限序列。<br>在稍复杂的线性表中，一个数据元素可以由若干个<b>数据项</b>组成。在这种情况下，常把数据元素称为<b>记录</b>，含有带昂记录的线性表又称为<b>文件</b>。<br>线性表中的数据元素可以是各种各样的，可以是26个英文字母(A,B,···，Z)，也可以是数字(1,2,3,···，100)，也可以是学生成绩的记录<br><!-- |姓名|学号|性别|年龄|数学|语文|
|张三|001|男  |15 |98 |95 |
|李四|002|男  |15 |99 |92 | --><br>  
<table>
	<thead>
		<th>
			</th></thead><td>姓名</td>
			<td>学号</td>
			<td>性别</td>
			<td>年龄</td>
			<td>数学</td>
			<td>语文</td>
		
	
	<tbody>
		<tr>
			<td>张三</td>
			<td>001</td>
			<td>男</td>
			<td>15</td>
			<td>98</td>
			<td>95</td>
		</tr>
		<tr>
			<td>李四</td>
			<td>002</td>
			<td>男</td>
			<td>15</td>
			<td>99</td>
			<td>92</td>
		</tr>
	</tbody>
</table>
<br>但是同一线性表中的元素必定具有相同特性，即属于同一数据对象，相邻数据元素之间存在着序偶关系。若将线性表记为<br>(a<sub>1</sub>,···,a<sub>i-1</sub>,a<sub>i</sub>,a<sub>i+1</sub>,···,a<sub>n</sub>)<br>则表中a<sub>i-1</sub>领先于a<sub>i</sub>，a<sub>i</sub>领先于a<sub>i+1</sub>，称a<sub>i-1</sub>是a<sub>i</sub>的直接前驱元素，a<sub>i+1</sub>是a<sub>i</sub>的直接后继元素。当i=1,2,···,n-1时，a<sub>i</sub>有且仅有一个直接后继，当i=2,3,···,n时，a<sub>i</sub>有且仅有一个直接前驱。<br>线性表中元素的个数n(n&gt;=0)定义为线性表的长度，n=0时称为控表。在非空表中的每个数据元素都有一个确定的位置，如a<sub>i</sub>是第一个数据元素，a<sub>n</sub>是最后一个数据元素，a<sub>i</sub>是第i个数据元素，称i为数据元素a<sub>i</sub>在线性表中的位序。<br>线性表是一个相当灵活的数据结构，它的长度可根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，还可进行插入和删除等。<p></p>
<p></p><h3>线性表的顺序表示和实现</h3><br>线性表的顺序表示指的是用一组连续的存储单元依次存储线性表的数据元素。<br>假设线性表的每个元素需占用l个存储单元，并以所占的第一个单元的存储地址作为数据元素的存储位置。则线性表中第i+1个数据元素的存储位置LOC(a<sub>i+1</sub>)和第i个数据元素的存储位置LOC(a<sub>i</sub>)之间满足下列关系:<br>LOC(a<sub>i+1</sub>) = LOC(a<sub>i</sub>) + l<br>一般来说，线性表的第i个数据元素a<sub>i</sub>的存储位置为<br>LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>) + (i-1) * l<br>上面LOC(a<sub>1</sub>)是线性表中的第一个数据元素a<sub>1</sub>的存储位置，通常称作线性表的起始位置或者基地址<br>线性表的这种机内表示称作线性表的顺序存储结构或顺序映像，通常，称这种存储结构的线性表为顺序表。它的特点是，为表中相邻的元素a<sub>i</sub>和a<sub>i+1</sub>赋以相邻的存储位置LOC(a<sub>i</sub>)和LOC(a<sub>i+1</sub>)。换句话说，以元素在计算机内“物理位置相邻”来表示线性表中数据元素之间的逻辑关系。每一个数据元素的存储位置都和线性表的起始位置相差一个和数据元素在线性表中的位序成正比的常数。由此，只要确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。<p></p>
<p></p><h3>线性表的链式表示和实现</h3><br>线性表的顺序存储结构的特点是逻辑关系上相邻的两个元素在物理位置上也相邻，因此可以随机存取表中任一元素，它的存储位置可用一个简单、直观的公式来表示。然而，从另一方面来讲，这个特点也铸成了这种存储结构的弱点：在作插入或删除操作时，需要移动大量元素。本节我们将讨论线性表的另一种表示方法——链式存储结构，由于它不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储所具有的弱点，但同时也失去了顺序表可随机存取的优点。<p></p>
<p></p><h4>线性链表</h4><br>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的，也可以是不连续的)。因此，为了表示每个数据元素a<sub>i</sub>与其直接后继数据元素a<sub>i+1</sub>之间的逻辑关系，对数据元素a<sub>i</sub>来说除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息(即直接后继的存储位置)。这两部分信息组成数据元素a<sub>i</sub>的存储映像，称为<b>结点</b>。它包括连个域：其中存储数据元素信息的域称为<b>数据域</b>，存储直接后继存储位置的域称为<b>指针域</b>。指针域中存储的信息称作<b>指针</b>或<b>链</b>。n个节点(a<sub>i</sub>(1&lt;=1&lt;=n)的存储映像)链结成一个<b>链表</b>，即为线性表<br>(a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>)<br>的链式存储结构。又由于此链表的每个结点中只包含一个指针域，故又称<b>线性链表</b>或<b>单链表</b>。<br>例如：<br>(ZHAO,QIAN,SUN,LI,ZHOU,WU,ZHENG,WANG)<br>的线性链表存储结构，整个链表的存取必须从<b>头指针</b>开始进行，头指针指示链表中第一个结点(即第一个数据元素的存储映像)的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为”空”(NULL)。<br> 
<table>
	<thead>
		<th>
			</th></thead><td></td>
			<td>存储地址</td>
			<td>数据域</td>
			<td>指针域</td>
		
	
	<tbody>
		<tr>
			<td rowspan="8" align="center">头指针H<br>31</td>
			<td>1</td>
			<td>LI</td>
			<td>43</td>
		</tr>
		<tr>
			<td>7</td>
			<td>QIAN</td>
			<td>13</td>
		</tr>
		<tr>
			<td>13</td>
			<td>SUN</td>
			<td>1</td>
		</tr>
		<tr>
			<td>19</td>
			<td>WANG</td>
			<td>NULL</td>
		</tr>
		<tr>
			<td>25</td>
			<td>WU</td>
			<td>37</td>
		</tr>
		<tr>
			<td>31</td>
			<td>ZHAO</td>
			<td>7</td>
		</tr>
		<tr>
			<td>37</td>
			<td>ZHENG</td>
			<td>19</td>
		</tr>
		<tr>
			<td>43</td>
			<td>ZHOU</td>
			<td>25</td>
		</tr>
	</tbody>
</table>
<br>用线性链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。换句话说，指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，由此，这种存储结构为非顺序映像或链式映像。<br>假设L是LinkList型的变量，则L为单链表的头指针，它指向表中第一个结点。若L为”空”(L=NULL)，则所表示的线性表为”空”表，其长度为”零”。有时我们在单链表的第一个结点之前附设一个结点，称之为<b>头结点</b>。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等类的附加信息，头结点的指针域存储指向第一个结点的指针(即第一个元素结点的存储位置)。<br>在单链表中，任何两个元素的存储位置之间没有固定的联系。然而，每个元素的存储位置都包含在其直接前驱结点的信息之中。假设p是指向线性表中第i个数据元素(结点a<sub>i</sub>)的指针，则p-&gt;next是指向第i+1个数据元素(结点a<sub>i+1</sub>)的指针。换句话说，若p-&gt;data=a<sub>i</sub>，则p-&gt;next-&gt;data=a<sub>i+1</sub>。由此，在单链表中，取得第i个数据元素必须从头指针出发寻找，因此，单链表是非随机存取的存储结构。<p></p>
<pre>
/*
* 单向链表的基本操作 增、删、查
* param data 结点的值
* param index 
* reverse 逆转链表
*/
class Node{
    constructor(data,next) {
        this.data = data
        this.next = next
    }
}
class LinkList{
    constructor(){
        this.head = new Node(0,null);//头结点
        this.length = 0;
    }
    createNode(data,next) {
        return new Node(data,next);
    }
    insertNode(index,data){
        if(index < 1) return new Error('请正确填写要插入数据的位置')
        let j = 1;
        let p = this.head;
        while(p.next && j < index){
            j++
            p = p.next
        }
        let newNode = this.createNode(data,p.next)
        p.next = newNode
        this.length++
    }
    deleteNode(index){
        if(typeof index !== 'number' || index < 0){
            return new Error('请正确选择要删除的项')
        }
        if(this.length === 0){
            return new Error('结点不存在')
        }
        let p = this.head,j=1;
        while(p.next && j < index){
            j++
            p = p.next
        }
        let item = p.next
        p.next = item.next
        item = null
        this.length -= 1;
    }
    find(index){
        let p = this.head,j=1;
        while(p.next && j < index){
            j++
            p = p.next
        }
        return p.next
    }
    getList(){
        let arr = []
        let p = this.head,i=0
        while(p.next){
            p=p.next
            arr[i++] = p.data
        }
        return arr
    }
    //getLength(){
        //return this.length
    //}
    reverse(){
        let p = this.head,s = p.next,t;
        while(s.next){
            t = s.next;
            s.next = p;
            p = s;
            s = t;
        }
        s.next = p;
        this.head.next.next = null
        this.head.next = s
    }
}
let list = new LinkList();
list.insertNode(1,'a')
list.insertNode(2,'b')
list.insertNode(3,'c')
list.deleteNode(1)
console.log(list.find(1))
console.log(list.getList())
console.log(list.getLength())
</pre>
<h3>循环链表</h3>
循环链表是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其它结点。
循环链表的操作和线性链表基本一致，差别仅在于算法中的循环条件是不是p或p->next是否为空，而是它们是否等于头指针。但有的时候，若在循环链表中设立尾指针而不设立头指针，可使某些操作简化。例如将两个线性表合并成一个表时，仅需将一个表的表尾和另一个表的表头相接。
<h3>双向链表</h3>
双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前趋。和单链的循环链表类似，双向链表也可以有循环链表。
<img src="https://snakexu.github.io/images/others/linear_1.jpeg">
上图中(c)，链表中存有两个环，(b)所示为只有一个表头结点的空表。在双向链表中，若d为指向表中某一结点的指针(即d为DuLinkList型变量)，则显然有
d -> next -> prior = d -> prior -> next = d
这个表示式恰当地反应了这种结构的特性。
在双向链表中，有些操作如:ListLength、GetElem和LocateElem等仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同，但在插入、删除时有很大的不同，在双向链表中需同时修改两个方向上的指针。
<pre>
/*
* 双向链表的基本操作
* param data 结点的值
* param index 结点索引
* param prev 前驱指针
* param next 后继指针
*/
class Node{
    constructor(data,prev,next){
        this.data = data;
        this.next = next;
        this.prev = prev
    }
}
class DoubleList{
    //
}
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/24/数据结构-线性表/" data-id="ckchm0rfz002o5ajhr830pn5g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-node-1-2-3-ES6-异步编程解决方案" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/23/网易微专业-node-1-2-3-ES6-异步编程解决方案/" class="article-date">
  <time datetime="2020-04-23T03:50:52.000Z" itemprop="datePublished">2020-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/23/网易微专业-node-1-2-3-ES6-异步编程解决方案/">网易微专业-node-1.2.3-ES6+异步编程解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.异步编程优势<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_1.png"><br>2.异步编程难点<br>2-1.异常处理<br>·过去异常处理</p>
<p><pre><br>try{<br>    JSON.parse(json);<br>}cache(e){<br>    //TODO<br>}<br></pre><br>·这对于异步编程而言并不一定适用<br>·只能捕获当次事件循环内的异常，对’callback’执行时抛出的异常行为将无能为力</p>
<p><pre><br>try{<br>    async(callback);<br>}cache(e){<br>    //TODO<br>}<br></pre><br>·node在处理异常形成了一种约定，将异常作为回调函数的第一个参数传回<br>·必须执行调用者传入的回调函数<br>·正确传递异常供调用者判断<br>·另一个容易犯的错误是对用户传递的回调函数进行异常捕获<br>错误示范:</p>
<p><pre><br>try{<br>    req.body = JSON.parse(buf,options,reviver);<br>    callback();<br>}cache(err){<br>    err.body = buf;<br>    err.status = 400;<br>    callback(400);<br>}<br></pre><br>2-2.函数嵌套过深<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_2.png"><br>2-3.其它难点<br>·多线程编程<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_3.png"><br>·异步转同步<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_4.png"><br>3.异步编程解决方案<br>解决方案:<br>·事件发布/订阅模式<br>·async流程控制<br>·promise模式<br>·…<br>假设我们现在有三个文件dev.json、prod.json、test.json，相应的内容分别为{“dev”:”devdev”}、{“prod”:”prodprod”}、{“test”:”testtest”}，并且这三个文件和下面的代码文件在同一个跟目录下<br>index.js</p>
<p><pre><br>const fs = require(‘fs’);<br>let files = [‘/dev.json’, ‘/test.json’, ‘/prod.json’];<br>fs.readFile(<strong>dirname + files[0], ‘utf8’, (err, data) =&gt; {<br>    let result = [];<br>    if (err) console.log(‘Error: ‘ + err);<br>    result.push(data);<br>    fs.readFile(</strong>dirname + files[1], ‘utf8’, (err, data) =&gt; {<br>        if (err) console.log(‘Error: ‘ + err);<br>        result.push(data);<br>        fs.readFile(__dirname + files[2], ‘utf8’, (err, data) =&gt; {<br>            if (err) console.log(“Error: “ + err);<br>            result.push(data);<br>            console.log(result);<br>        });<br>    });<br>});<br></pre><br>执行上面index.js代码，得到如下结果<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_5.png"><br>但是index.js的代码已经看到了回调地狱的趋势，于是我们想用发布/订阅模式来使代码看起来更容易理解。<br>首先封装一个m.js</p>
<p><pre><br>const fs = require(‘fs’);<br>module.exports = function(filename,cb){<br>    fs.readFile(__dirname + filename, ‘utf8’, (err, data) =&gt; {<br>        cb(err,data)<br>    });<br>}<br></pre><br>index1.js</p>
<p><pre><br>const fn = require(‘./m’)//引入m.js<br>const events = require(‘events’);<br>let files = [‘/dev.json’, ‘/test.json’, ‘/prod.json’];<br>const emitter = new events.EventEmitter();<br>var done = after(times,cb,(res)=&gt;{<br>    console.log(res)<br>})<br>emitter.on(‘done’,done);<br>function after(times,cb){<br>    let count = 0, result = [];<br>    return function(data){<br>        result.push(data);<br>        count++;<br>        if(count === times){<br>            cb(result)<br>        }<br>    }<br>}<br>files.forEach((filename)=&gt;{<br>    fn(filename,(err,data)=&gt;{<br>        //if(err) TODO<br>        emitter.emit(‘done’,data)<br>    })<br>})<br></pre><br>可以看到index1.js的执行结果和上面我们用回调写的代码执行结果还是一样的，说明代码没有问题<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_6.png"><br>多执行几次代码，我们发现，文件读取顺序是不一样的<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_7.png"><br>emitter.on默认在node中只能绑定10次，超过10次就会报错，认为内存泄漏，可以通过emitter.setMaxListeners(100)这样绑定修改最大值<br>我们还可以在项目中安装async库来实现需求。async库安装之后，新建一个index2.js</p>
<p><pre><br>const fn = require(‘./m’)<br>const async = require(‘async’)<br>let files = [‘/dev.json’, ‘/test.json’, ‘/prod.json’];<br>async.waterfall([<br>    (cb) =&gt; {<br>        fn(files[0], (err, data) =&gt; {<br>            cb(err, data);<br>        });<br>    },<br>    (data1, cb) =&gt; {<br>        fn(files[1], (err, data) =&gt; {<br>            cb(err, data1, data)<br>        });<br>    },<br>    (data1, data2, cb) =&gt; {<br>        fn(files[2], (err, data) =&gt; {<br>            cb(err, data1, data2, data);<br>        });<br>    }<br>], (err, data1, data2, data3) =&gt; {<br>    if (err) console.log(err);<br>    let result = [data1, data2, data3];<br>    console.log(result);<br>});<br></pre><br>执行index2.js会按照我们写的函数顺序去读取文件，也就是说读取文件的顺序是确定的，如果中间哪个文件读取出错，后面就不会再执行了(不会执行后面的读取，但是整个函数还是会执行)<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_8.png"><br>另外就是使用Promise来满足我们的需求<br>index3.js</p>
<p><pre><br>const fn = require(‘./m’);<br>let files = [‘/dev.json’, ‘/test.json’, ‘/prod.json’];<br>function toPromiseStyle(fn) {<br>    return (…args) =&gt; {<br>        return new Promise((resolve, reject) =&gt; {<br>            fn(…args, (err, data) =&gt; {<br>                if (err) reject(err);<br>                resolve(data);<br>            });<br>        });<br>    }<br>}<br>let op = toPromiseStyle(fn);<br>let result = [];<br>op(files[0])<br>    .then((data) =&gt; {<br>        result.push(data);<br>        return op(files[1]);<br>    })<br>    .then((data) =&gt; {<br>        result.push(data);<br>        return op(files[2]);<br>    })<br>    .then((data) =&gt; {<br>        result.push(data);<br>        console.log(relust);<br>    }).catch((err) =&gt; {<br>        console.log(err);<br>        console.log(result);<br>    });<br>function* getResult() {<br>    let res;<br>    try {<br>        res = yield op(files[0]);<br>        res = yield op(files[1]);<br>        res = yield op(files[2]);<br>        return res;<br>    } catch (error) {<br>        return console.log(err);<br>    }<br>}<br>async function getResult1() {<br>    let res;<br>    try {<br>        res = await op(files[0]);<br>        res = await op(files[1]);<br>        res = await op(files[2]);<br>        return res;<br>    } catch (error) {<br>        return console.log(err);<br>    }<br>}<br></pre><br>promise这个和async相同之处就是会按照代码定义顺序去读取文件，如果中间出错，就会直接打印最后结果，出错文件之后的文件不会再读取。getResult和getResult1两个函数分别是gentor函数和async函数去执行promise，其实也就是讲述了async的原理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/23/网易微专业-node-1-2-3-ES6-异步编程解决方案/" data-id="ckchm0rge003b5ajhwuibolqq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-node-1-2-2-异步编程的优势与难点" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/22/网易微专业-node-1-2-2-异步编程的优势与难点/" class="article-date">
  <time datetime="2020-04-22T04:00:37.000Z" itemprop="datePublished">2020-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/22/网易微专业-node-1-2-2-异步编程的优势与难点/">网易微专业-node-1.2.2-异步编程的优势与难点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.事件驱动<br>1-1.事件机制<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_1.png"><br>事件机制的实现<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_2.png"><br>2.异步I/O模型<br>2-1.异步I/O的必要性<br>2-1-1.实现I/O并行<br>(1)多线程单进程<br>多线程设计之初就是为了共享程序空间，例如java、c++等，但是缺点在于执行过程中要进行线程与线程之间的切换，即执行时上下文要交换，开销会比较大，还有就是两个线程操作同一个文件，如果两个线程对同一个文件的同一变量进行不同操作，产生了锁的机制同步状态，产生了状态同步的问题，使程序更加复杂化。<br>(2)单线程多进程<br>为了避免多线程使用不便的问题，就使用了单线程保持调用的简单，但是启动的时候会启动多个进程来达到充分利用cpu和整体并行能力的问题。但是缺点在于，业务逻辑复杂的时候，业务进程不能分布到多个进程之间，处理起来可能比多线程还要复杂。<br>2-1-2.异步I/O的必要性<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_4.png"><br>2-2.阻塞与非阻塞、异步与同步<br>2-2-1.I/O的阻塞与非阻塞<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_5.png"><br>2-2-2.I/O的异步与同步<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_6.png"><br>另：当进行非阻塞I/O调用时，要读取完整的数据，应用程序需要进行多次轮询，才能确保数据读取完成，以进行下一步操作。<br>2-3.理想的异步I/O<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_7.png"><br>2-4.Node.js中的异步I/O<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_8.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_9.png"><br>3.事件循环<br>3-1.高并发策略<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_10.png"><br>3-2.Node.js运行原理<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_11.png"><br>3-3.事件循环实现原理<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_12.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_13.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_14.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_15.png"><br>3-4.业务场景<br>·不适用场景<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_16.png"><br>·适用场景<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_17.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/22/网易微专业-node-1-2-2-异步编程的优势与难点/" data-id="ckchm0rgc00385ajh7ph4bcx8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-node-1-2-1-异步I-O实现现状" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/21/网易微专业-node-1-2-1-异步I-O实现现状/" class="article-date">
  <time datetime="2020-04-21T07:34:37.000Z" itemprop="datePublished">2020-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/21/网易微专业-node-1-2-1-异步I-O实现现状/">网易微专业-node-1.2.1-异步I/O实现现状</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.模块化概述<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.1_1.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.2.1_2.png"><br>1-1.CommonJs特点<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.1_3.png"><br>a.js</p>
<pre>
let name = 'evan'
let getName = function(name){
    console.log(name)
}
module.exports = {
    name:name,
    getName:getName
}
</pre>
b.js
<pre>
let person = require('a.js')
console.log(person)
console.log(person.name)
person.getName('study163')
person.name = 'updateName'
console.log(person)
</pre>
执行结果
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_4.png">
2.module对象详解
2-1.module对象的属性
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_5.png">
03-module.js
<pre>
module.exports = {
    name:'evan',
    getName:function(name){
        console.log(name)
    }
}
console.log(module)
</pre>
执行结果
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_6.png">
2-2.模块分类
2-2-1.核心模块
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_7.png">
2-2-2.文件模块
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_8.png">
2-3.module.exports与exports
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_9.png">
04-exports-module-exports.js
<pre>
var module = {
    exports:{}
}
var exports = module.exports
function change(exports){
    //通过形参的方式传入的exports
    exports.name = 'evan';
    exports={
        age:18
    }
    console.log(exports)
}
change(exports)
console.log(module.exports)
</pre>
执行结果
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_10.png">
要注意的是在change函数中exports={}，相当于改变了change函数中形参exports的指向；而如果用module.exports={}这样赋值就解决了(其实个人以为这就是对象指针指向问题，另外change函数对exports的赋值还说明了参数是传值而不是传引用的)
3.require方法详解
3-1.模块引入规则
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_11.png">
3-2.加载步骤
(1)路径分析(模块标识符分析)
·核心模块
·以'./'或者'../'开始的相对路径文件模块
·以/开始的绝对路径模块
·非路径形式的模块
(2)文件定位
·扩展名分析
·目标文件和包分析
(3)编译执行
3-3.
<pre>
//a、b引入同一个对象
var a = require('aa.js');
var b = require('aa.js')
console.log(a===b)//true 
//在a引入aa.js之后，aa.js会在缓存中，b=require('aa.js')再次引入则是在缓存中查找，所以a===b
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/21/网易微专业-node-1-2-1-异步I-O实现现状/" data-id="ckchm0rgd00395ajhphmhxajv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业福利期-3-2-Event-Loop机制" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/20/网易微专业福利期-3-2-Event-Loop机制/" class="article-date">
  <time datetime="2020-04-20T09:28:59.000Z" itemprop="datePublished">2020-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/20/网易微专业福利期-3-2-Event-Loop机制/">网易微专业福利期-3.2-Event Loop机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.浏览器的Event Loop<br>异步实现:<br>(1)宏观:浏览器多线程<br>(2)微观:Event Loop事件循环</p>
<p><pre><br>console.log(‘1’);<br>setTimeout(function(){<br>    console.log(‘2’)<br>},0)<br>Promise.resolve().then(function(){<br>    console.log(‘3’)<br>})<br>console.log(‘4’)<br>//143undefined2<br></pre><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_1.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_2.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_3.png"></p>
<p><pre><br>console.log(‘start’);<br>setTimeout(()=&gt;{<br>    console.log(‘setTimeout’);<br>    new Promise(resolve=&gt;{<br>        console.log(‘promise inner1’);<br>        resolve();<br>    }).then(()=&gt;{<br>        console.log(‘promise then1’)<br>    })<br>},0)<br>new Promise(resolve=&gt;{<br>    console.log(‘promise inner2’);<br>    resolve();<br>}).then(()=&gt;{<br>        console.log(‘promise then2’)<br>})<br></pre><br>上面代码的运行结果<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_4.png"></p>
<p><pre><br>async function async1(){<br>    console.log(‘async1 start’)<br>    await async2()<br>    console.log(‘async1 end’)<br>}<br>async function async2(){<br>    return Promise.resolve().then(_=&gt;{<br>        console.log(‘async2 promise’)<br>    })<br>}<br>console.log(‘start’)<br>setTimeout(function(){<br>    console.log(‘setTimeout’)<br>},0)<br>async1()<br>new Promise(function(resolve){<br>    console.log(‘promise1’)<br>    resolve()<br>}).then(function(){<br>    console.log(‘promise2’)<br>})<br></pre><br>上面代码的运行结果<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_5.png"><br>2.Node.js的Event Loop<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_6.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_7.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_8.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_9.png"></p>
<p><pre><br>const fs = require(‘fs’)<br>function someAsyncOperation(callback){<br>    fs.readFile(__dirname,callback);<br>}<br>const timeoutScheduled = Date.now()<br>setTimeout(()=&gt;{<br>    const delay = Date.now() - timeoutScheduled;<br>    console.log(<code>${delay}ms have passed since I was scheduled</code>)<br>},100)<br>someAsyncOperation(()=&gt;{<br>    const startCallback = Date.now();<br>    while(Date.now() - startCallback &lt; 200){<br>        //do something<br>    }<br>})<br></pre><br>上面代码执行结果<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_10.png"></p>
<p><pre><br>const fs = require(‘fs’)<br>fs.readFile(__filename,<em>=&gt;{<br>    setTimeout(</em>=&gt;{<br>        console.log(‘setTimeout’)<br>    },0)<br>    setImmediate(_=&gt;{<br>        console.log(‘setImmediate’)<br>    })<br>})<br></pre><br>上面代码执行结果<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_11.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_12.png"></p>
<p><pre><br>const fs = require(‘fs’)<br>fs.readFile(__filename,<em>=&gt;{<br>    setTimeout(</em>=&gt;{<br>        console.log(‘setTimeout’)<br>    },0)<br>    setImmediate(<em>=&gt;{<br>        console.log(‘setImmediate’)<br>        process.nextTick(</em>=&gt;{<br>            console.log(‘nextTick2’)<br>        })<br>    })<br>    process.nextTick(_=&gt;{<br>        console.log(‘nextTick1’)<br>    })<br>})<br></pre><br>上面代码执行结果<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_13.png"><br>nextTick会让整个event loop停下来，先把nextTick中的callback执行完之后再继续event loop</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/20/网易微专业福利期-3-2-Event-Loop机制/" data-id="ckchm0rgz004m5ajh7bwg5dtu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/拉勾/">拉勾</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾/">拉勾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业/">网易微专业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECMAScript新特性/" style="font-size: 10px;">ECMAScript新特性</a> <a href="/tags/JavaScript异步编程/" style="font-size: 10px;">JavaScript异步编程</a> <a href="/tags/TypeScript语言/" style="font-size: 10px;">TypeScript语言</a> <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/函数式编程范式/" style="font-size: 10px;">函数式编程范式</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/手写Promise源码/" style="font-size: 10px;">手写Promise源码</a> <a href="/tags/拉勾/" style="font-size: 20px;">拉勾</a> <a href="/tags/拉勾，自动化构建/" style="font-size: 10px;">拉勾，自动化构建</a> <a href="/tags/数据结构/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 17.5px;">算法</a> <a href="/tags/网易微专业/" style="font-size: 10px;">网易微专业</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/08/拉勾-自动化构建/">拉勾-自动化构建</a>
          </li>
        
          <li>
            <a href="/2020/07/03/拉勾-脚手架工具/">拉勾-脚手架工具</a>
          </li>
        
          <li>
            <a href="/2020/07/03/拉勾-工程化概述/">拉勾-工程化概述</a>
          </li>
        
          <li>
            <a href="/2020/06/28/拉勾-JavaScript性能优化/">拉勾-JavaScript性能优化</a>
          </li>
        
          <li>
            <a href="/2020/06/26/拉勾-TypeScript语言/">拉勾-TypeScript语言</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>