<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="喵小喵的窝">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="喵小喵的窝">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-网易微专业-node-1-2-3-ES6-异步编程解决方案" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/23/网易微专业-node-1-2-3-ES6-异步编程解决方案/" class="article-date">
  <time datetime="2020-04-23T03:50:52.000Z" itemprop="datePublished">2020-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/23/网易微专业-node-1-2-3-ES6-异步编程解决方案/">网易微专业-node-1.2.3-ES6+异步编程解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.异步编程优势<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_1.png"><br>2.异步编程难点<br>2-1.异常处理<br>·过去异常处理</p>
<p><pre><br>try{<br>    JSON.parse(json);<br>}cache(e){<br>    //TODO<br>}<br></pre><br>·这对于异步编程而言并不一定适用<br>·只能捕获当次事件循环内的异常，对’callback’执行时抛出的异常行为将无能为力</p>
<p><pre><br>try{<br>    async(callback);<br>}cache(e){<br>    //TODO<br>}<br></pre><br>·node在处理异常形成了一种约定，将异常作为回调函数的第一个参数传回<br>·必须执行调用者传入的回调函数<br>·正确传递异常供调用者判断<br>·另一个容易犯的错误是对用户传递的回调函数进行异常捕获<br>错误示范:</p>
<p><pre><br>try{<br>    req.body = JSON.parse(buf,options,reviver);<br>    callback();<br>}cache(err){<br>    err.body = buf;<br>    err.status = 400;<br>    callback(400);<br>}<br></pre><br>2-2.函数嵌套过深<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_2.png"><br>2-3.其它难点<br>·多线程编程<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_3.png"><br>·异步转同步<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_4.png"><br>3.异步编程解决方案<br>解决方案:<br>·事件发布/订阅模式<br>·async流程控制<br>·promise模式<br>·…<br>假设我们现在有三个文件dev.json、prod.json、test.json，相应的内容分别为{“dev”:”devdev”}、{“prod”:”prodprod”}、{“test”:”testtest”}，并且这三个文件和下面的代码文件在同一个跟目录下<br>index.js</p>
<p><pre><br>const fs = require(‘fs’);<br>let files = [‘/dev.json’, ‘/test.json’, ‘/prod.json’];<br>fs.readFile(<strong>dirname + files[0], ‘utf8’, (err, data) =&gt; {<br>    let result = [];<br>    if (err) console.log(‘Error: ‘ + err);<br>    result.push(data);<br>    fs.readFile(</strong>dirname + files[1], ‘utf8’, (err, data) =&gt; {<br>        if (err) console.log(‘Error: ‘ + err);<br>        result.push(data);<br>        fs.readFile(__dirname + files[2], ‘utf8’, (err, data) =&gt; {<br>            if (err) console.log(“Error: “ + err);<br>            result.push(data);<br>            console.log(result);<br>        });<br>    });<br>});<br></pre><br>执行上面index.js代码，得到如下结果<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_5.png"><br>但是index.js的代码已经看到了回调地狱的趋势，于是我们想用发布/订阅模式来使代码看起来更容易理解。<br>首先封装一个m.js</p>
<p><pre><br>const fs = require(‘fs’);<br>module.exports = function(filename,cb){<br>    fs.readFile(__dirname + filename, ‘utf8’, (err, data) =&gt; {<br>        cb(err,data)<br>    });<br>}<br></pre><br>index1.js</p>
<p><pre><br>const fn = require(‘./m’)//引入m.js<br>const events = require(‘events’);<br>let files = [‘/dev.json’, ‘/test.json’, ‘/prod.json’];<br>const emitter = new events.EventEmitter();<br>var done = after(times,cb,(res)=&gt;{<br>    console.log(res)<br>})<br>emitter.on(‘done’,done);<br>function after(times,cb){<br>    let count = 0, result = [];<br>    return function(data){<br>        result.push(data);<br>        count++;<br>        if(count === times){<br>            cb(result)<br>        }<br>    }<br>}<br>files.forEach((filename)=&gt;{<br>    fn(filename,(err,data)=&gt;{<br>        //if(err) TODO<br>        emitter.emit(‘done’,data)<br>    })<br>})<br></pre><br>可以看到index1.js的执行结果和上面我们用回调写的代码执行结果还是一样的，说明代码没有问题<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_6.png"><br>多执行几次代码，我们发现，文件读取顺序是不一样的<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_7.png"><br>emitter.on默认在node中只能绑定10次，超过10次就会报错，认为内存泄漏，可以通过emitter.setMaxListeners(100)这样绑定修改最大值<br>我们还可以在项目中安装async库来实现需求。async库安装之后，新建一个index2.js</p>
<p><pre><br>const fn = require(‘./m’)<br>const async = require(‘async’)<br>let files = [‘/dev.json’, ‘/test.json’, ‘/prod.json’];<br>async.waterfall([<br>    (cb) =&gt; {<br>        fn(files[0], (err, data) =&gt; {<br>            cb(err, data);<br>        });<br>    },<br>    (data1, cb) =&gt; {<br>        fn(files[1], (err, data) =&gt; {<br>            cb(err, data1, data)<br>        });<br>    },<br>    (data1, data2, cb) =&gt; {<br>        fn(files[2], (err, data) =&gt; {<br>            cb(err, data1, data2, data);<br>        });<br>    }<br>], (err, data1, data2, data3) =&gt; {<br>    if (err) console.log(err);<br>    let result = [data1, data2, data3];<br>    console.log(result);<br>});<br></pre><br>执行index2.js会按照我们写的函数顺序去读取文件，也就是说读取文件的顺序是确定的，如果中间哪个文件读取出错，后面就不会再执行了(不会执行后面的读取，但是整个函数还是会执行)<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.3_8.png"><br>另外就是使用Promise来满足我们的需求<br>index3.js</p>
<p><pre><br>const fn = require(‘./m’);<br>let files = [‘/dev.json’, ‘/test.json’, ‘/prod.json’];<br>function toPromiseStyle(fn) {<br>    return (…args) =&gt; {<br>        return new Promise((resolve, reject) =&gt; {<br>            fn(…args, (err, data) =&gt; {<br>                if (err) reject(err);<br>                resolve(data);<br>            });<br>        });<br>    }<br>}<br>let op = toPromiseStyle(fn);<br>let result = [];<br>op(files[0])<br>    .then((data) =&gt; {<br>        result.push(data);<br>        return op(files[1]);<br>    })<br>    .then((data) =&gt; {<br>        result.push(data);<br>        return op(files[2]);<br>    })<br>    .then((data) =&gt; {<br>        result.push(data);<br>        console.log(relust);<br>    }).catch((err) =&gt; {<br>        console.log(err);<br>        console.log(result);<br>    });<br>function* getResult() {<br>    let res;<br>    try {<br>        res = yield op(files[0]);<br>        res = yield op(files[1]);<br>        res = yield op(files[2]);<br>        return res;<br>    } catch (error) {<br>        return console.log(err);<br>    }<br>}<br>async function getResult1() {<br>    let res;<br>    try {<br>        res = await op(files[0]);<br>        res = await op(files[1]);<br>        res = await op(files[2]);<br>        return res;<br>    } catch (error) {<br>        return console.log(err);<br>    }<br>}<br></pre><br>promise这个和async相同之处就是会按照代码定义顺序去读取文件，如果中间出错，就会直接打印最后结果，出错文件之后的文件不会再读取。getResult和getResult1两个函数分别是gentor函数和async函数去执行promise，其实也就是讲述了async的原理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/23/网易微专业-node-1-2-3-ES6-异步编程解决方案/" data-id="ckdbzsiie002mjrxq0ryx5pye" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-node-1-2-2-异步编程的优势与难点" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/22/网易微专业-node-1-2-2-异步编程的优势与难点/" class="article-date">
  <time datetime="2020-04-22T04:00:37.000Z" itemprop="datePublished">2020-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/22/网易微专业-node-1-2-2-异步编程的优势与难点/">网易微专业-node-1.2.2-异步编程的优势与难点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.事件驱动<br>1-1.事件机制<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_1.png"><br>事件机制的实现<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_2.png"><br>2.异步I/O模型<br>2-1.异步I/O的必要性<br>2-1-1.实现I/O并行<br>(1)多线程单进程<br>多线程设计之初就是为了共享程序空间，例如java、c++等，但是缺点在于执行过程中要进行线程与线程之间的切换，即执行时上下文要交换，开销会比较大，还有就是两个线程操作同一个文件，如果两个线程对同一个文件的同一变量进行不同操作，产生了锁的机制同步状态，产生了状态同步的问题，使程序更加复杂化。<br>(2)单线程多进程<br>为了避免多线程使用不便的问题，就使用了单线程保持调用的简单，但是启动的时候会启动多个进程来达到充分利用cpu和整体并行能力的问题。但是缺点在于，业务逻辑复杂的时候，业务进程不能分布到多个进程之间，处理起来可能比多线程还要复杂。<br>2-1-2.异步I/O的必要性<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_4.png"><br>2-2.阻塞与非阻塞、异步与同步<br>2-2-1.I/O的阻塞与非阻塞<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_5.png"><br>2-2-2.I/O的异步与同步<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_6.png"><br>另：当进行非阻塞I/O调用时，要读取完整的数据，应用程序需要进行多次轮询，才能确保数据读取完成，以进行下一步操作。<br>2-3.理想的异步I/O<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_7.png"><br>2-4.Node.js中的异步I/O<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_8.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_9.png"><br>3.事件循环<br>3-1.高并发策略<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_10.png"><br>3-2.Node.js运行原理<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_11.png"><br>3-3.事件循环实现原理<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_12.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_13.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_14.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_15.png"><br>3-4.业务场景<br>·不适用场景<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_16.png"><br>·适用场景<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.2_17.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/22/网易微专业-node-1-2-2-异步编程的优势与难点/" data-id="ckdbzsiic002jjrxqsiyj7njt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-node-1-2-1-异步I-O实现现状" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/21/网易微专业-node-1-2-1-异步I-O实现现状/" class="article-date">
  <time datetime="2020-04-21T07:34:37.000Z" itemprop="datePublished">2020-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/21/网易微专业-node-1-2-1-异步I-O实现现状/">网易微专业-node-1.2.1-异步I/O实现现状</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.模块化概述<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.1_1.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.2.1_2.png"><br>1-1.CommonJs特点<br><img src="https://snakexu.github.io/images/wangyi/node/1.2.1_3.png"><br>a.js</p>
<pre>
let name = 'evan'
let getName = function(name){
    console.log(name)
}
module.exports = {
    name:name,
    getName:getName
}
</pre>
b.js
<pre>
let person = require('a.js')
console.log(person)
console.log(person.name)
person.getName('study163')
person.name = 'updateName'
console.log(person)
</pre>
执行结果
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_4.png">
2.module对象详解
2-1.module对象的属性
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_5.png">
03-module.js
<pre>
module.exports = {
    name:'evan',
    getName:function(name){
        console.log(name)
    }
}
console.log(module)
</pre>
执行结果
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_6.png">
2-2.模块分类
2-2-1.核心模块
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_7.png">
2-2-2.文件模块
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_8.png">
2-3.module.exports与exports
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_9.png">
04-exports-module-exports.js
<pre>
var module = {
    exports:{}
}
var exports = module.exports
function change(exports){
    //通过形参的方式传入的exports
    exports.name = 'evan';
    exports={
        age:18
    }
    console.log(exports)
}
change(exports)
console.log(module.exports)
</pre>
执行结果
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_10.png">
要注意的是在change函数中exports={}，相当于改变了change函数中形参exports的指向；而如果用module.exports={}这样赋值就解决了(其实个人以为这就是对象指针指向问题，另外change函数对exports的赋值还说明了参数是传值而不是传引用的)
3.require方法详解
3-1.模块引入规则
<img src="https://snakexu.github.io/images/wangyi/node/1.2.1_11.png">
3-2.加载步骤
(1)路径分析(模块标识符分析)
·核心模块
·以'./'或者'../'开始的相对路径文件模块
·以/开始的绝对路径模块
·非路径形式的模块
(2)文件定位
·扩展名分析
·目标文件和包分析
(3)编译执行
3-3.
<pre>
//a、b引入同一个对象
var a = require('aa.js');
var b = require('aa.js')
console.log(a===b)//true 
//在a引入aa.js之后，aa.js会在缓存中，b=require('aa.js')再次引入则是在缓存中查找，所以a===b
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/21/网易微专业-node-1-2-1-异步I-O实现现状/" data-id="ckdbzsiic002kjrxqtx5kaqdp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业福利期-3-2-Event-Loop机制" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/20/网易微专业福利期-3-2-Event-Loop机制/" class="article-date">
  <time datetime="2020-04-20T09:28:59.000Z" itemprop="datePublished">2020-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/20/网易微专业福利期-3-2-Event-Loop机制/">网易微专业福利期-3.2-Event Loop机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.浏览器的Event Loop<br>异步实现:<br>(1)宏观:浏览器多线程<br>(2)微观:Event Loop事件循环</p>
<p><pre><br>console.log(‘1’);<br>setTimeout(function(){<br>    console.log(‘2’)<br>},0)<br>Promise.resolve().then(function(){<br>    console.log(‘3’)<br>})<br>console.log(‘4’)<br>//143undefined2<br></pre><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_1.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_2.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_3.png"></p>
<p><pre><br>console.log(‘start’);<br>setTimeout(()=&gt;{<br>    console.log(‘setTimeout’);<br>    new Promise(resolve=&gt;{<br>        console.log(‘promise inner1’);<br>        resolve();<br>    }).then(()=&gt;{<br>        console.log(‘promise then1’)<br>    })<br>},0)<br>new Promise(resolve=&gt;{<br>    console.log(‘promise inner2’);<br>    resolve();<br>}).then(()=&gt;{<br>        console.log(‘promise then2’)<br>})<br></pre><br>上面代码的运行结果<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_4.png"></p>
<p><pre><br>async function async1(){<br>    console.log(‘async1 start’)<br>    await async2()<br>    console.log(‘async1 end’)<br>}<br>async function async2(){<br>    return Promise.resolve().then(_=&gt;{<br>        console.log(‘async2 promise’)<br>    })<br>}<br>console.log(‘start’)<br>setTimeout(function(){<br>    console.log(‘setTimeout’)<br>},0)<br>async1()<br>new Promise(function(resolve){<br>    console.log(‘promise1’)<br>    resolve()<br>}).then(function(){<br>    console.log(‘promise2’)<br>})<br></pre><br>上面代码的运行结果<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_5.png"><br>2.Node.js的Event Loop<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_6.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_7.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_8.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_9.png"></p>
<p><pre><br>const fs = require(‘fs’)<br>function someAsyncOperation(callback){<br>    fs.readFile(__dirname,callback);<br>}<br>const timeoutScheduled = Date.now()<br>setTimeout(()=&gt;{<br>    const delay = Date.now() - timeoutScheduled;<br>    console.log(<code>${delay}ms have passed since I was scheduled</code>)<br>},100)<br>someAsyncOperation(()=&gt;{<br>    const startCallback = Date.now();<br>    while(Date.now() - startCallback &lt; 200){<br>        //do something<br>    }<br>})<br></pre><br>上面代码执行结果<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_10.png"></p>
<p><pre><br>const fs = require(‘fs’)<br>fs.readFile(__filename,<em>=&gt;{<br>    setTimeout(</em>=&gt;{<br>        console.log(‘setTimeout’)<br>    },0)<br>    setImmediate(_=&gt;{<br>        console.log(‘setImmediate’)<br>    })<br>})<br></pre><br>上面代码执行结果<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_11.png"><br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_12.png"></p>
<p><pre><br>const fs = require(‘fs’)<br>fs.readFile(__filename,<em>=&gt;{<br>    setTimeout(</em>=&gt;{<br>        console.log(‘setTimeout’)<br>    },0)<br>    setImmediate(<em>=&gt;{<br>        console.log(‘setImmediate’)<br>        process.nextTick(</em>=&gt;{<br>            console.log(‘nextTick2’)<br>        })<br>    })<br>    process.nextTick(_=&gt;{<br>        console.log(‘nextTick1’)<br>    })<br>})<br></pre><br>上面代码执行结果<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.2_13.png"><br>nextTick会让整个event loop停下来，先把nextTick中的callback执行完之后再继续event loop</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/20/网易微专业福利期-3-2-Event-Loop机制/" data-id="ckdbzsijg003xjrxq7did67u7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业福利期-2-6-常用函数" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/网易微专业福利期-2-6-常用函数/" class="article-date">
  <time datetime="2020-04-19T09:33:59.000Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/网易微专业福利期-2-6-常用函数/">网易微专业福利期-2.6-常用函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.memozition<br>缓存函数:是指将上次的计算结果缓存起来，当下次调用时，如果遇到相同的参数，就直接返回缓存中的数据</p>
<pre>
let add = (a,b) => a+b;
//假设memoize函数可以实现缓存
let calculate = memoize(add);
calculate(10,20);//30
calculate(10,20);//相同的参数，第二次调用时，从缓存中取出，而非重新计算一次
</pre>
实现原理:把参数和对应的结果数据存到一个对象中，调用时，判断参数对应的数据是否存在，存在就返回对应的结果数据
<pre>
let memoize = function(func){
    let cache = {}
    return function(key){
        if(!cache[key]){
            cache[key] = function.apply(this,arguments);
        }
        return cache[key]
    }
}
</pre>
underscore.js中缓存函数的实现
<pre>
let memoize = function(func,hasher){
    var memoize = function(key){
        var cache = memoize.cahche;
        var address = '' + (hasher ? hasher.apply(this,arguments) : key);
        if(!cache[address]) cache[address] = func.apply(this,arguments);
        return cache[address]
    }
    memoize.cache = {};
    return memoize;
}
</pre>
如果hasher存在，就用hasher计算key，否则就用func计算
缓存函数适用于需要大量重复计算，或者大量计算又依赖于之前的结果
2.curry
柯里化函数:在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转化成一系列使用一个参数的函数的技术。
普通函数:
<pre>
function girl(name,age,single){
    return `我叫${name},我今年${age}岁，我${single}单身`;
}
let lincancan = girl('林灿灿',18，'不是')
console.log(lincancan);//我叫林灿灿，我今年18岁，我不是单身
</pre>
柯里化函数
<pre>
function girl(name){
    return function(age){
        return function(single){
            return `我叫${name},我今年${age}岁，我${single}单身`;
        }
    }
}
let rst = girl('林灿灿')(18)('不是')
</pre>
需求:检测字符串中是否包含正则
<pre>
let matching = (reg,str) => reg.test(str);
matching(/\s+/g,'hello world');//true
matching(/\s+/g,'abcdefg');//false
</pre>
如果我们有很多字符串需要校验，那么我们需要将reg参数复用，可以借助柯里化的思想实现这个需求
<pre>
let curry = (reg) =>{
    return (str) =>{
        return reg.test(str);
    }
}
let hasSpace = curry(/\s+/g);
hasSpace('hello world');//true
hasSpace('abcdefg');//false
hasSpace('I Love China');//true
</pre>
需求:请获取数组对象的age属性的值
<pre>
let persons = [
    {'name':'Peter',age:21},
    {'name':'Mark',age:28},
    {'name':'Josn',age:19},
    {'name':'Jane',age:31},
    {'name':'Tony',age:35},
]
//不用柯里化
let getAge = persons.map(item=>{
    return item.age
})
console.log(getAge);//[21,28,19,31,35]
</pre>
Lodash:是一个一致性、模块化、高性能的JavaScript实用工具库；通过降低array、number、objects、string等等的使用难度从而让JavaScript变得简单
Lodash的安装和使用:使用npm i lodash -S进行安装
<pre>
//lodash的curry
const _ = require('lodash');
let getProp = _.curry((key,obj)=>{
    return obj[key]
})
let ages = persons.map(getProp('age'));
console.log(ages);
</pre>
3.偏函数
柯里化函数是将一个多参数函数转换成多个单参数函数，也就是将一个n元函数转换成n个一元函数；偏函数则是固定一个函数的一个或者多个参数，也就是将一个n元函数转换成一个n-x元函数
柯里化:f(a,b,c) = f(a)(b)(c)
偏函数:f(a,b,c) = f(a,b)(c)
<pre>
let add = (x,y)=>x+y;
let rst = add.bind(null,1);
rst(2);//3
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/19/网易微专业福利期-2-6-常用函数/" data-id="ckdbzsijf003ujrxqiwy2pyan" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业福利期-2-5-高阶函数" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/网易微专业福利期-2-5-高阶函数/" class="article-date">
  <time datetime="2020-04-19T07:36:47.000Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/网易微专业福利期-2-5-高阶函数/">网易微专业福利期-2.5-高阶函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.高阶函数<br>js函数都指向某个变量，既然变量可以指向函数，函数的参数可以接收某个变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称为高阶函数。<br>·高阶函数是对其他函数进行操作的函数，可以将它们作为参数或返回它们<br>·简单来说，高阶函数是一个函数，它接收函数作为参数或将函数作为输出返回<br>2.map/reduce/filter<br>2-1.map<br>需求:创建一个新数组，其中的值是原数组的值的两倍</p>
<pre>
const arr1 = [1,2,3,4];
const arr2 = arr1.map(function(item,index,array){
    return item*2;
})
const arr3 = arr1.map( item => item * 2 )
</pre>
2-2.reduce
<pre>
let arr = [1,2,3,4,5];
let sum = arr.reduce((prev,cur)=>{
    return prev + cur
},0)
</pre>
这里传入了初始值0，所以开始时prev=0，cur=1(arr的第一项),0+1=1,1作为下一轮回调的prev值……prev表示上一次回调时返回的值，或者是我们传入的初始值。
我们还可以通过reduce实现数组去重
<pre>
let arr = [1,2,3,4,5,5,6,6,7,7,8];
let newArr = arr.reduce((prev,cur)=>{
    prev.indexOf(cur) === -1 && prev.push(cur);
    return prev;
},[])
</pre>
2-3.filter
filter主要用于对数组的过滤、筛选，它会创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素
需求:请将对象数组中年龄大于21的组成新的对象数组
<pre>
let persons = [
    {'name':'Peter',age:21},
    {'name':'Mark',age:28},
    {'name':'Josn',age:19},
    {'name':'Jane',age:31},
    {'name':'Tony',age:35},
]
let newAge = persons.filter(item => item.age > 21);
console.log(newAge)
</pre>
3.flat
数组成员有时还是数组，flat方法用于把数组成员拉平，也就是数组扁平化，将多维数组变成一维数组，该方法会返回一个新数组，对原数据没有影响
<pre>
let arr = [1,2,3,4,[5,6,7]];
let arr1 = arr.flat();
console.log(arr1);//[1,2,3,4,5,6,7]
</pre>
flat默认只能拉平一层，也就是如果数组是[1,2,3,4,[5,6,7,[8,9]]]，那么[8，9]是不能被拉平的，会变成[1,2,3,4,5,6,7,[8,9]]。如果想要拉平多层数组嵌套，可以传入一个整数参数，它的默认值为1
<pre>
let arr = [1,2,3,4,[5,6,[7,8]]];
let arr1 = arr.flat(3);
console.log(arr1);//[1,2,3,4,5,6,7,8]
</pre>
如果我们不确定有多少嵌套，都需要转成一维数组，可以使用Infinity关键字作为参数
<pre>
let arr = [1,2,3,4,[5,6,[7,8,[9,10,[11,12]]]]];
let arr1 = arr.flat(Infinity);
console.log(arr1);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
</pre>
但是大家要注意，目前flat方法还没有在所有浏览器被兼容(包括node.js上)
4.高阶函数的意义
高阶函数的意义：函数可以作为参数；函数可以作为返回值
4-1.参数为函数的高阶函数
<pre>
function foo(f){
    //判断参数是否为函数
    if((typeof f) === 'function'){
        f();
    }
}
//调用
foo(function(){})
</pre>
4-2.返回值为函数的高阶函数
<pre>
function foo(){
    return function(){}
}
//调用
let f = foo()
</pre>
4-3.高阶函数的实际作用
<pre>
//回调函数
let callback = (value) => {
    console.log(value)
}
let foo = (value,fn) => {
    if(typeof callback === 'function'){
        fn(value);
    }
}
foo('hello',callback);
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/19/网易微专业福利期-2-5-高阶函数/" data-id="ckdbzsijh0041jrxqasu2l3u2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业福利期-2-4-compose函数和pipe函数" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/17/网易微专业福利期-2-4-compose函数和pipe函数/" class="article-date">
  <time datetime="2020-04-17T08:42:34.000Z" itemprop="datePublished">2020-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/17/网易微专业福利期-2-4-compose函数和pipe函数/">网易微专业福利期-2.4-compose函数和pipe函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.compose函数<br>·将需要嵌套执行的函数平铺<br>·嵌套执行指的是，一个函数的返回值将作为另一个函数的参数<br>实现函数式编程中的Pointfree，使我们专注于转换而不是数据：我们可以把数据处理的过程定义成一种与参数无关的合成运算，不需要用到代表数据的参数，只需要把一些简单的运算步骤合成在一起即可；而pointfree指的是不使用所要处理的值，只合成运算过程，即我们所指的无参数分隔。<br>假设我们现在有一个需求:一个数加上10之后再乘以10，那么我们首先想到的就是</p>
<p><pre><br>let calculate = x =&gt; (x+10)*10<br>console.log(calculate(10))<br></pre><br>这样写是没有问题的，但是这样写是典型的命令式编程，这样的代码也不具备复用性。作为一个函数式编程开发者，会对这段代码进行抽象来实现简化代码的目的，而且函数式编程就是将我们的程序分解为一些更可充用更可靠性更易于理解的部分，然后再将他们组合起来，形成一个更易于推理的需求整体。以上面加上10再乘以10的需求为例，我们关注的是他的动作——先加上10，再乘以10，我们可以写出两个函数</p>
<p><pre><br>let add = x =&gt; x+10;<br>let multiply = y =&gt; y*10;<br>console.log(multiply(add(10)))<br></pre><br>这样也能实现我们的需求，但是根据复合函数的定义，我们需要将上述代表动作的两个函数合成一个函数。我们分析两个函数的特性：第一，这两个函数都有一个共同的参数；第二， 函数的执行顺序是从右到左；第三，前面函数的执行结果交由后面的函数处理。根据特性，我们可以这样来实现</p>
<p><pre><br>let add = x =&gt; x+10;<br>let multiply = y =&gt; y*10;<br>let compose = (f,g)=&gt;{<br>    return function(x){<br>        return f(g(x))<br>    }<br>}<br>let calculate = compose(multiply,add)<br>console.log(calculate(10))<br></pre><br>但是这样的compose没有通用性，因为只能处理两个函数，接下来就看如何实现通用的compose函数</p>
<p><pre><br>let add = x =&gt; x+10;<br>let multiply = y =&gt; y*10;<br>let compose = function(){<br>    //将我们传入的函数当作参数收集起来，所以将arguments转化成数组<br>    let args = [].slice.call(arguments);<br>    return function(x){<br>        //因为需要把上一次执行结果当作参数传递给下一次执行，所以可以使用reduce来实现<br>        //reduce方法可以接收一个函数作为累加器，也就是说reduce会将数组中的每一个元素依次执行传入的函数<br>        //复合函数的执行顺序是从右到左依次执行的，reduce是从左向右累加，reduceRight是从右向左累加<br>        return args.reduceRight(function(res,cb){<br>            return cb(res);<br>        },x)<br>    }<br>}<br>let calculate = compose(multiply,add)<br>console.log(calculate(10))<br></pre><br>array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)<br>function(total,currentValue, index,arr)    必需。用于执行每个数组元素的函数。<br>total    必需。初始值, 或者计算结束后的返回值。<br>currentValue    必需。当前元素<br>currentIndex    可选。当前元素的索引<br>arr    可选。当前元素所属的数组对象。<br>initialValue    可选。传递给函数的初始值<br>用es6重写componse函数</p>
<p><pre><br>const compose = (…args) =&gt; x =&gt; args.reduceRight((res,cb) =&gt; cb(res),x)<br></pre><br>2.pipe函数<br>compose和pipe都是函数组合，组合是函数式编程中非常重要的思想，就是将多个函数组合在一起，以便能构建出一个新函数。在函数式编程中纯函数应该只做一件事，如果想实现多个功能，可以通过函数的组合来实现。pipe函数是compose函数的复制品，唯一修改的是数据流方向，它做的事和compose函数相同，只不过交换了数据流方向</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/17/网易微专业福利期-2-4-compose函数和pipe函数/" data-id="ckdbzsijd003qjrxqoub3h2q6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-node-1-1-9-通信协议" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/16/网易微专业-node-1-1-9-通信协议/" class="article-date">
  <time datetime="2020-04-16T08:24:42.000Z" itemprop="datePublished">2020-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/16/网易微专业-node-1-1-9-通信协议/">网易微专业-node-1.1.9-通信协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.计算机网络协议<br>1-1.概念<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_1.png"><br>1-2.网络协议三要素<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_2.png"><br>2.开放系统互连参考模型<br>2-1.OSI/RM模型分层<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_3.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_4.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_5.png"><br>2-1-1.物理层<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_6.png"><br>2-1-2.链路层<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_7.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_8.png"><br>2-1-3.网络层<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_9.png"><br>2-1-4.传输层<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_10.png"><br>(1)TCP三次握手<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_11.png"><br>(2)TCP四次挥手<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_12.png"><br>2-1-5.会话层<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_13.png"><br>2-1-6.表示层<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_14.png"><br>2-1-7.应用层<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_15.png"><br>3.HTTP协议详解<br>3-1.概念<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_16.png"><br>3-2.原理<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_17.png"><br>3-3.消息结构<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_18.png"><br>3-4.工作流程<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_19.png"><br>3-5.HTTP请求方法<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_20.png"><br>get请求与post请求的区别<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_21.png"><br>3-6.请求报文<br>(1)get请求报文<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_23.png"><br>(2)post请求报文<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_22.png"><br>3-7.HTTP状态码<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.9_24.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/16/网易微专业-node-1-1-9-通信协议/" data-id="ckdbzsiib002hjrxqfir0krw0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-node-1-1-8-MySQL入门与应用" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/15/网易微专业-node-1-1-8-MySQL入门与应用/" class="article-date">
  <time datetime="2020-04-15T02:31:54.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/15/网易微专业-node-1-1-8-MySQL入门与应用/">网易微专业-node-1.1.8-MySQL入门与应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.MySQL安装与配置<br>1-1.MySQL简介<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_1.png"><br>1-2.MySQL安装及基础配置<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_2.png"><br>官网:<a href="https://www.mysql.com/" target="_blank" rel="noopener">https://www.mysql.com/</a><br><!--安装的时候不能用yum(因为没有yum安装包)，如果用别的安装方式，需要先安装依赖，这些依赖是有一定安装顺序的:common lias client server--><br>2.MySQL基本概念<br>2-1.结构化查询语言<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_3.png"><br>2-2.SQL语言分类<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_4.png"><br>2-3.命令行连接<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_5.png"><br>上面截图中-user=username这种第二个方法，都应该是两个横线，--user=username这样<br>2-4.数据类型·字符型<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_6.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_7.png"><br>2-4.数据类型·数值型<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_8.png"><br>2-5.数据类型·日期时间<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_9.png"><br>datetime存储的是localtime，默认值为null，系统内占用8个字节，插入的时候直接插入<br>timestamp会和时区挂钩，默认值为系统当前时间，系统内占用4个字节，插入时间时会转换成utc时间<br>3.MySQL数据库操作<br>3-1.数据库管理<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_10.png"><br>3-2.表管理<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_11.png"><br>下面的方法可以在navicat中快速创建表，表结构会和from后面的表结构一样，但是主键和一些InnoDB等不会复制<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_12.png"><br>下面的方法可以快速复制表<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_13.png"><br>desc(查看结构)       show create(查看sql)<br>修改表(示例代码)<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_14.png"><br>alter table `courses` rename `grades`;//修改表名<br>alter table `grades` rename column `class` to `course`;//修改字段名<br>alter table `grades` add `description` text default null comment ‘备注’;//插入字段,默认插入到尾部<br>alter table `grades` add `description` text default null comment ‘备注’ first;//插入字段,插入到最前面<br>alter table `grades` add `description` text default null comment ‘备注’ after `id`;//插入字段,插入到id后面<br>alter table `grades` drop `description`;//删除字段<br>alter table `grades` modify `score` int(10) after `student`;//修改字段属性，modify是专门用来修改字段属性的，change既可以修改字段属性，又可以修改表名<br>alter table `grades` change `score` `score` int(3) after `course`;<br>3-3.数据操作<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_16.png"><br>//插入一条完整数据<br>insert into `grades` values (1,’A’,’Math’,90);<br>//插入一条数据<br>insert into `grades` (`student`,`course`,`score`) values (‘A’,’Chinese’,95);<br>//插入多条数据<br>insert into `grades` (`student`,`course`,`score`) values (‘A’,’History’,80),(‘A’,’English’,60);<br>//修改数据<br>update `grades` set `student` = ‘章三’ where id = 1;<br>//删除数据<br>delete from `grades` where id = 1;//不加where条件将删除表中所有数据<br>//清空表，把指定表全部删掉再创建一个同名新表<br>truncate grades;<br>3-3-1.查询<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_17.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_18.png"><br><img src="https://snakexu.github.io/images/wangyi/node/1.1.8_19.png"><br>count统计的时候，如果是select * 那么是统计空值的，如果select某一列，那么是不统计空值的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/15/网易微专业-node-1-1-8-MySQL入门与应用/" data-id="ckdbzsiib002ijrxqprjhkcqj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-node-1-1-7-MongoDB入门与应用" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/14/网易微专业-node-1-1-7-MongoDB入门与应用/" class="article-date">
  <time datetime="2020-04-14T02:05:29.000Z" itemprop="datePublished">2020-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/14/网易微专业-node-1-1-7-MongoDB入门与应用/">网易微专业-node-1.1.7-MongoDB入门与应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.MongoDB简介<br>1-1.简介<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.7_1.png"><br>1-2.特性<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.7_2.png"><br>2.MongoDB安装及配置<br>2-1.安装<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.7_3.png"><br>安装的时候尽量不要选择rpm，因为rpm对一些需要下载的依赖没有自动处理；也尽量不要选download source(tgz)，因为编译安装一是耗时，另外就是如果编译安装过程中配置不对容易出错。在官网底部我们可以找到installation，点击installation，找到我们需要安装的版本，老师因为是安装在Linux的虚拟机里，所以选择了Linux的版本，在用yum安装的时候(yum可以自动下载安装相关依赖)可以把镜像源替换成阿里的镜像( 阿里云镜像网址: <a href="https://developer.aliyun.com/mirror/mongodb?spm=a2c6h.13651102.0.0.3e221b11VnKXtR" target="_blank" rel="noopener">https://developer.aliyun.com/mirror/mongodb?spm=a2c6h.13651102.0.0.3e221b11VnKXtR</a> ，按照页面提示操作)因为如果是国外的镜像源可能下载地址较慢(如果阿里云版本比较低，可以把版本号换一下，换成最新版本)</p>
<p><pre><br>命令:<br>vim /etc/yum.repos.d/mongodb-org.repo<br>i命令编辑文件<br>[mongodb-org]<br>name = MongoDB Repository<br>baseurl = <a href="https://mirrors.aliyun.com/mongodb/yum/redhat/$releasever/mongodb-org/4.2/x86_64/" target="_blank" rel="noopener">https://mirrors.aliyun.com/mongodb/yum/redhat/$releasever/mongodb-org/4.2/x86_64/</a><br>gpgcheck = 1<br>enabled = 1<br>gpgkey = https：// <a href="http://www.mongodb.org/static/pgp/server-4.2.asc" target="_blank" rel="noopener">www.mongodb.org/static/pgp/server-4.2.asc</a><br>:wq (保存退出)<br>yum search mongodb(会更新一些缓存)<br>yum install -y mongodb<br>yum install -y mongodb-org<br>ps -ef|grep mongod(查询进程)<br>service mongod start<br></pre><br>如果用上面提到的方法安装的mongodb，就按照上面的方法启动，不要找到运行目录再启动，因为在运行目录下启动，是root启动的，如果在用mongod启动，就回有权限问题。如果不小心遇到了，就要修改用户组用户名为mongod(在/var/lib目录下输入命令行chown mongod:mongod -R mongo/)<br>2-2.MongoDB常用配置<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.7_4.png"><br>3.MongoDB查询与应用<br>这里查询的概念不单单是对数据的增删改查<br>3-1.MongoDB基础概念<br>3-1-1.文档:数据的基本单元，相当于关系型数据库中的行<br>·由键值对组成的有序集<br>·不仅区分大小写，还区分数据类型<br>3-1-2.集合:由多个文档组成集合，文档可以是不同的结构，相当于关系型数据库中的表<br>·不能以system开头，且不能使用保留字符<br>·动态模式可以使一个集合中包含多样化文档对象<br>3-1-3.数据库:多个集合聚合组成数据库<br>·数据库名称区分大小写<br>·几个特殊意义的数据库:admin(用户数据)、local(本地数据)、config(配置数据)<br>3-2.MongoDB客户端shell<br>·客户端shell可以使用命令行于MongoDB实例进行交互<br>·它是一个功能完备的JavaScript解释器，所以又称为JavaScript shell，可以运行任意JavaScript代码<br>·通过shell可以对数据进行基本操作:CURD<br>假设我们写了这样一段js代码放到mongoDB中执行<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.7_5.png"><br>可以给MongoDB添加数据<br>3-3.MongoDB连接<br>标准URI连接语法</p>
<p><pre><br>mongodb://[username:password@]host1[:port1][,host2[:port2]],···[,hostN[,portN]]][/[database][?options]]<br></pre><br><img src="https://snakexu.github.io/images/wangyi/node/1.1.7_6.png"><br>3-4.MongoDB用户管理<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.7_7.png"><br>3-5.MongoDB数据库、集合操作<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.7_8.png"><br>3-6.MongoDB文档操作<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.7_9.png"><br>3-7.文档查询$特殊符号<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.7_10.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/14/网易微专业-node-1-1-7-MongoDB入门与应用/" data-id="ckdbzsiie002njrxq240ghh1z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/拉勾/">拉勾</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾/">拉勾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业/">网易微专业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECMAScript新特性/" style="font-size: 10px;">ECMAScript新特性</a> <a href="/tags/JavaScript异步编程/" style="font-size: 10px;">JavaScript异步编程</a> <a href="/tags/TypeScript语言/" style="font-size: 10px;">TypeScript语言</a> <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/函数式编程范式/" style="font-size: 10px;">函数式编程范式</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/手写Promise源码/" style="font-size: 10px;">手写Promise源码</a> <a href="/tags/拉勾/" style="font-size: 20px;">拉勾</a> <a href="/tags/拉勾，自动化构建/" style="font-size: 10px;">拉勾，自动化构建</a> <a href="/tags/数据结构/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 17.5px;">算法</a> <a href="/tags/网易微专业/" style="font-size: 10px;">网易微专业</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/29/拉勾-规范化标准/">拉勾-规范化标准</a>
          </li>
        
          <li>
            <a href="/2020/07/28/拉勾-其他打包工具/">拉勾-其他打包工具</a>
          </li>
        
          <li>
            <a href="/2020/07/17/拉勾-Webpack打包/">拉勾-Webpack打包</a>
          </li>
        
          <li>
            <a href="/2020/07/15/拉勾-模块化开发/">拉勾-模块化开发</a>
          </li>
        
          <li>
            <a href="/2020/07/08/拉勾-自动化构建/">拉勾-自动化构建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>