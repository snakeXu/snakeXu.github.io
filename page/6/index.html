<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>喵小喵的窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="喵小喵的窝">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="喵小喵的窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="喵小喵的窝">
  
    <link rel="alternate" href="/atom.xml" title="喵小喵的窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵小喵的窝</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-网易微专业-node-1-1-1-es6快速入门" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/09/网易微专业-node-1-1-1-es6快速入门/" class="article-date">
  <time datetime="2020-04-09T03:38:24.000Z" itemprop="datePublished">2020-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/09/网易微专业-node-1-1-1-es6快速入门/">网易微专业-node-1.1.1-es6快速入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.初识ECMAScript6.0<br>1-1.ES6初识<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.1_1.png"><br>1-2.ES6新增变化<br><img src="https://snakexu.github.io/images/wangyi/node/1.1.1_2.png"><br>2.ES6快速入门<br>2-1.let、const以及变量解构赋值<br>这里说一下，虽然较新版本的chrome等浏览器支持es6，但是一般还是会用babel解析成es5<br>2-1-1.let<br>·ES6新增了let命令，用于声明变量，只在其所在的代码块内有效<br>·let不允许在相同的作用域内重复声明同一个变量<br>·let声明变量的方式实际上就是为JavaScript新增了块级作用域</p>
<pre>
var name = 'Evan';
function foo(){
    console.log(name);
    if(false){
        let name = 'Bob'
    }
}
foo()
</pre>
这里需要注意，var定义变量会有变量提升，比如
<pre>
console.log(x)
var x = 10
</pre>
控制台会输出undefined，因为变量提升，所以在console.log之前会定义变量x，即var x;在console之后再赋值，但是对于let定义是不会变量提升的
<pre>
console.log(y)
let y = 10
</pre>
用let定义，在定义之前console的话，控制台会报错，因为let不会变量提升，相当于没有定义先使用变量，所以报错
<pre>
function foo(){
    let x = 10;
    let x = 20;
}
</pre>
如果在同一作用域中用var重复定义，后定义的变量值开辟的内存会起作用，先定义变量开辟的内存被放弃，但是如果用let在同一作用域中重复定义变量，像上面代码重复定义，浏览器会报错    
2-1-2.const
·const用来声明常量
·const声明变量必须立即初始化，并且其值不能再改变
<p>
const PI = 3.14 //常量定义名字一般大写
</p>
另外const和let一样，都是有块级作用域的
如果想改变常量的值，浏览器会报错，如下代码，浏览器会报错
<p>
const PI = 3.14 
PI = 3.15
console.log(PI)
</p>
2-1-3.全局对象的属性
- var命令和function命令声明的全局变量依旧是全局对象的属性
- let命令、const命令和class命令声明的全局变量不属于全局对象的属性
<pre>
var x = 10;
let y = 20;
console.log(window.x)  //10
console.log(window.y)  //undefined
</pre>
2-1-4.变量的解构赋值
-ES6允许按照一定的模式，从数组或对象中提取值，对变量进行赋值
(1)数组的解构赋值
<pre>
let [x,y,z] = [10,20,30]
x //10
y //20
z //30
</pre>
(2)对象的解构赋值
<pre>
let {x,y} = {x:10,y:20}
x //10
y //20
</pre>
2-2.字符串新增方法
includes():返回布尔值，表示是否找到了参数字符串
starstWith():返回布尔值，表示参数字符串是否在源字符串的开始位置
endsWith():返回布尔值，表示参数字符串是否在源字符串的结尾位置
这三个方法都支持第2个参数，表示开始匹配的位置
<pre>
let s = 'Hello world!';
s.includes('o');        //true
s.startsWith('Hello');  //true
s.endsWith('!');        //true
s.includes('o',8);      //false
s.startsWith('world',6);//true
s.endsWith('Hello',5);  //true
</pre>
2-3.模版字符串
·模版字符串是增强版的字符串，用反引号(`)标识
·模版字符串可以当作普通字符串使用，也可以用来定义多行字符串
·在模版字符串中可以嵌入变量，只需要将变量名字写入${}中
<pre>
var name = 'Evan' , age = 18;
`My name is ${name}, I'm ${age} years old.`
</pre>
2-4.箭头函数
箭头函数的特点:
1.如果参数只有一个，可以省略小括号
2.如果函数体只有一行，可以不写大括号
3.箭头函数中没有arguments变量
4.不会改变this指向(箭头函数根本没有自己的this，导致内部的this就是外层代码块的this)
<pre>
let sum = (n1,n2)=>n1+n2
等价于
let sum = (n1,n2)=>{return n1+n2}



let f = v=>v
等价于
let f = v=>return v
</pre>
<pre>
let getTempItem = id=>{id:id,name:'temp'};//这里本身是想返回一个对象，但是会报错，因为大括号会被解释成代码块
let getTempItem = id=>({id:id,name:'temp'})//上面一行代码，如果想返回一个对象，这样写才对
</pre>
箭头函数中this指向被固化
<pre>
var person = {
    name:'Evan',
    age:18,
    func:function(){
        console.log(this)
    }
}
person.func();//person对象
</pre>
<pre>
var person = {
    name:'Evan',
    age:18,
    func:()=>{
        console.log(this)
    }
}
person.func();//window对象
</pre>
关于this，ES5中谁调用，this指向谁；在ES6中定义时候的环境决定了this的指向。所以根据需要灵活运用
2-5.对象属性和方法的简洁表示法
·ES6允许直接写入变量和函数作为对象的属性和方法。
<pre>
//简洁表示法
function(x,y){
    return {x,y}
}
//常规写法
function(x,y){
    return {x:x,y:y}
}
</pre>
<pre>
//简洁表示法
var o = {
    method(){
        return "Hello"
    }
}
//常规写法
var o = {
    method:function(){
        return "Hello"
    }
}
</pre>
2-6.ES6中的面向对象
使用class构造对象，示例代码
<img src="https://snakexu.github.io/images/wangyi/node/1.1.1_3.png">
2-7.Promise对象
·Promise是异步编程的一种解决方案，比传统的解决方案(回调函数和事件)更合理、更强大
·有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
·Promise对象提供统一的接口，使得控制异步操作更加容易
<pre>
const promiseObj = new Promise(function(resolve,reject){
    //...some code
    if(/*异步操作成功*/){
        resolve(value)
    }else{
        reject(error)
    }
})
</pre>
·Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject
·Promise实例生成后，可以用then方法分别指定resolved和rejected状态的回调函数
<pre>
promiseObj.then(function(value){
    //success
},function(error){
    //failure
})
</pre>
·then方法的两个回调函数都接受Promise对象传出的值作为参数
·then方法的第一个回调函数是Promise对象的状态变为resolved时调用
·then方法的第二个回调函数是Promise对象的状态变为rejected时调用，该函数是可选的，不一定要提供
<pre>
function timeout(ms){
    return new Promise(resolve,reject){
        setTimeout(resolve,ms,'完成')
    }
}
timeout(1000).then(value=>console.log(value))
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/09/网易微专业-node-1-1-1-es6快速入门/" data-id="ckchm0rg700305ajhlsy68i3z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js实现重载和重写" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/01/js实现重载和重写/" class="article-date">
  <time datetime="2020-04-01T09:02:12.000Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/js实现重载和重写/">js实现重载和重写</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>重载<br>函数名相同，函数的参数列表不同(包括参数个数和参数类型)，根据参数的不同去执行不同的操作。在JavaScript中，同一个作用域，出现两个名字一样的函数，后面的会覆盖前面的，所以 JavaScript 没有真正意义的重载。</p>
<p><pre><br>// 可以跟据arguments个数实现重载<br>function fn(){<br>    switch(arguments.length){<br>        case 0:<br>        addFn(arguments.length)<br>        break<br>        case 1:<br>        deleteFn(arguments.length)<br>    }<br>}<br>function addFn(n){<br>    console.log(<code>fn函数参数个数为${n+1}个</code>)<br>}<br>function deleteFn(n){<br>    console.log(<code>fn函数参数个数为${n-1}个</code>)<br>}<br>fn()  // fn函数参数个数为1个<br>fn(1) // fn函数参数个数为0个<br></pre><br>重写<br>“实例中的指针仅指向原型，而不是指向构造函数”。<br>“重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的关系；它们引用的仍然是最初的原型”。</p>
<p><pre><br>var parent = function(name,age){<br>    this.name = name;<br>    this.age = age;<br>}<br>parent.prototype.showProper = function(){<br>    console.log(this.name+”:”+this.age);<br>}<br>var child = function(name,age){<br>    parent.call(this,name,age);<br>}<br>// inheritance<br>child.prototype = Object.create(parent.prototype);<br>// child.prototype = new parent();<br>child.prototype.constructor = child;<br>// rewrite function<br>child.prototype.showProper = function(){<br>    console.log(‘I am ‘+this.name+”:”+this.age);<br>}<br>var obj = new child(‘wozien’,’22’);<br>obj.showProper();<br></pre><br>上面这段代码通过使用寄生组合继承，实现子类私有继承父类私有，子类公有继承父类公有，达到重写父类的showProper</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/01/js实现重载和重写/" data-id="ckchm0rbt00025ajhl437z9c1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-MV-组件化开发React专题-React生态-2-4-3-Redux源码解析分享" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/01/网易微专业-MV-组件化开发React专题-React生态-2-4-3-Redux源码解析分享/" class="article-date">
  <time datetime="2020-04-01T08:45:38.000Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/网易微专业-MV-组件化开发React专题-React生态-2-4-3-Redux源码解析分享/">网易微专业-MV-组件化开发React专题-React生态-2.4.3-Redux源码解析分享</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/01/网易微专业-MV-组件化开发React专题-React生态-2-4-3-Redux源码解析分享/" data-id="ckchm0rck001b5ajh0peb6iyv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-MV-组件化开发React专题-React生态-2-4-2-实现React-下-so-diff" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/29/网易微专业-MV-组件化开发React专题-React生态-2-4-2-实现React-下-so-diff/" class="article-date">
  <time datetime="2020-03-29T11:52:59.000Z" itemprop="datePublished">2020-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/29/网易微专业-MV-组件化开发React专题-React生态-2-4-2-实现React-下-so-diff/">网易微专业-MV-组件化开发React专题-React生态-2.4.2-实现React(下)-so-diff</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>diff算法原理:将虚拟DOM与真实DOM进行比较，得到需要改变的部分然后进行重绘。这其中vnode(虚拟DOM是已知的，因为React.render(&lt; APP /&gt;)，这个语法就是虚拟DOM)，我们真实DOM是未知的，所以需要通过某种手段获取真实DOM，进行比较。需要比较:(1)文本节点(2)组件(3)子元素(4)属性，这之中(1)(2)(4)相对而言都是比较简单的，最难的是(3)子元素的比较，因为子元素的比较还涉及到key，当然还可能有别的需要比较的，可以自行斟酌。实现这些就是写一个diff(vnode,dom)，两个参数分别为虚拟DOM和真实DOM，这个函数得到的体现是得到需要改变的地方进行重绘。</p>
<pre>
/*
将虚拟dom 和真实dom 进行比较，得到需要改变的部分。重绘。
vnode
reactDOM.render(< App />,container)
1. 文本节点。
2. 比较组件
3. 比较子元素 key
4. 比较属性
diff (vnode, dom)
明确了 实现diff算法了 实现diff函数，参数是 vnode,真实dom.  需要改变的部分。重绘。
 */
import { Componet } from '../react'
import { setAttribute } from './dom'
/**
 * @param {HTMLElement} dom 真实DOM
 * @param {vnode} vnode 虚拟DOM
 * @param {HTMLElement} container 容器
 * @returns {HTMLElement} 更新后的DOM
 */
export const preDomTree = () => {
    let domTree = null
    return {
        set(tree){
            domTree = tree
        },
        get(){
            return domTree
        }
    }
}
export function diff(vnode, container ) {
    const ret = diffNode( preDomTree().get(), vnode );
    if ( ret.parentNode !== container ) {
        container.appendChild( ret );
    }
    preDomTree().set(ret)
    return ret;
}
function diffNode( dom, vnode ) {
    let out = dom;
    if ( vnode === undefined || vnode === null || typeof vnode === 'boolean' ) vnode = '';
    if ( typeof vnode === 'number' ) vnode = String( vnode );
    // diff text node
    if ( typeof vnode === 'string' ) {
        // 如果当前的DOM就是文本节点，则直接更新内容
        if ( dom && dom.nodeType === 3 ) {    // nodeType: https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType
            if ( dom.textContent !== vnode ) {
                dom.textContent = vnode;
            }
        // 如果DOM不是文本节点，则新建一个文本节点DOM，并移除掉原来的
        } else {
            out = document.createTextNode( vnode );
            if ( dom && dom.parentNode ) {
                dom.parentNode.replaceChild( out, dom );
            }
        }
        return out;
    }
    if ( typeof vnode.tag === 'function' ) {
        return diffComponent( dom, vnode );
    }
    //
    if ( !dom || !isSameNodeType( dom, vnode ) ) {
        out = document.createElement( vnode.tag );

        if ( dom ) {
            //展开运算符可以将一个类数组对象变成一个真正的数组对象:
            //var list=document.getElementsByTagName('div');
            //var arr=[..list];
            [ ...dom.childNodes ].map( out.appendChild );    // 将原来的子节点移到新节点下
            if ( dom.parentNode ) {
                dom.parentNode.replaceChild( out, dom );    // 移除掉原来的DOM对象
            }
        }
    }
    if ( vnode.children && vnode.children.length > 0 || ( out.childNodes && out.childNodes.length > 0 ) ) {
        diffChildren( out, vnode.children );
    }
    diffAttributes( out, vnode );
    return out;
}
function diffChildren( dom, vchildren ) {
      let keyedLen = 0
    const domChildren = dom.childNodes;
    const children = [];
    const keyed = {};
    if ( domChildren.length > 0 ) {
        for ( let i = 0; i < domChildren.length; i++ ) {
            const child = domChildren[ i ];
            const key = child.key;
            if ( key ) {
                keyedLen++;
                keyed[ key ] = child;
            } else {
                children.push( child );
            }
        }
    }
    if ( vchildren && vchildren.length > 0 ) {
        let min = 0;
        let childrenLen = children.length;
        for ( let i = 0; i < vchildren.length; i++ ) {
            const vchild = vchildren[ i ];
            const key = vchild.key;
            let child;
            if ( key ) {
                if ( keyed[ key ] ) {
                    child = keyed[ key ];
                    keyed[ key ] = undefined;
                }
            } else if ( min < childrenLen ) {
                for ( let j = min; j < childrenLen; j++ ) {
                    let c = children[ j ];
                    if ( c && isSameNodeType( c, vchild ) ) {
                        child = c;
                        children[ j ] = undefined;
                        if ( j === childrenLen - 1 ) childrenLen--;
                        if ( j === min ) min++;
                        break;
                    }
                }
            }
            child = diffNode( child, vchild );
            const f = domChildren[ i ];
            if ( child && child !== dom && child !== f ) {
                if ( !f ) {
                    dom.appendChild(child);
                } else if ( child === f.nextSibling ) {
                    removeNode( f );
                } else {
                    dom.insertBefore( child, f );
                }
            }
        }
    }
}
function diffComponent( dom, vnode ) {
    let c = dom && dom._component;
    let oldDom = dom;
    // 如果组件类型没有变化，则重新set props
    if ( c && c.constructor === vnode.tag ) {
        setComponentProps( c, vnode.attrs );
        dom = c.base;
    // 如果组件类型变化，则移除掉原来组件，并渲染新的组件
    } else {
        if ( c ) {
            unmountComponent( c );
            oldDom = null;
        }
        c = createComponent( vnode.tag, vnode.attrs );
        setComponentProps( c, vnode.attrs );
        dom = c.base;
        if ( oldDom && dom !== oldDom ) {
            oldDom._component = null;
            removeNode( oldDom );
        }
    }
    return dom;
}
function setComponentProps( component, props ) {
    if ( !component.base ) {
        if ( component.componentWillMount ) component.componentWillMount();
    } else if ( component.componentWillReceiveProps ) {
        component.componentWillReceiveProps( props );
    }
    component.props = props;
    renderComponent( component );
}
export function renderComponent( component ) {
    let base;
    const renderer = component.render();
    if ( component.base && component.componentWillUpdate ) {
        component.componentWillUpdate();
    }
    base = diffNode( component.base, renderer );
    if ( component.base ) {
        if ( component.componentDidUpdate ) component.componentDidUpdate();
    } else if ( component.componentDidMount ) {
        component.componentDidMount();
    }
    component.base = base;
    base._component = component;

}
function createComponent( component, props ) {
    let inst;
    if ( component.prototype && component.prototype.render ) {
        inst = new component( props );
    } else {
        inst = new Component( props );
        inst.constructor = component;
        inst.render = function() {
            return this.constructor( props );
        }
    }
    return inst;
}
function unmountComponent( component ) {
    if ( component.componentWillUnmount ) component.componentWillUnmount();
    removeNode( component.base);
}
function isSameNodeType( dom, vnode ) {
    if ( typeof vnode === 'string' || typeof vnode === 'number' ) {
        return dom.nodeType === 3;
    }
    if ( typeof vnode.tag === 'string' ) {
        return dom.nodeName.toLowerCase() === vnode.tag.toLowerCase();
    }
    return dom && dom._component && dom._component.constructor === vnode.tag;
}
function diffAttributes( dom, vnode ) {
    const old = {};    // 当前DOM的属性
    const attrs = vnode.attrs;     // 虚拟DOM的属性
    for ( let i = 0 ; i < dom.attributes.length; i++ ) {
        const attr = dom.attributes[ i ];
        old[ attr.name ] = attr.value;
    }
    // 如果原来的属性不在新的属性当中，则将其移除掉（属性值设为undefined）
    for ( let name in old ) {
        if ( !( name in attrs ) ) {
            setAttribute( dom, name, undefined );
        }
    }
    // 更新新的属性值
    for ( let name in attrs ) {
        if ( old[ name ] !== attrs[ name ] ) {
            setAttribute( dom, name, attrs[ name ] );
        }
    }
}
function removeNode( dom ) {
    if ( dom && dom.parentNode ) {
        dom.parentNode.removeChild( dom );
    }
}
</pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/29/网易微专业-MV-组件化开发React专题-React生态-2-4-2-实现React-下-so-diff/" data-id="ckchm0rg2002s5ajh7aqsovxj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业福利期-异步编程-3-1-理解异步" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/网易微专业福利期-异步编程-3-1-理解异步/" class="article-date">
  <time datetime="2020-03-26T14:10:17.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/网易微专业福利期-异步编程-3-1-理解异步/">网易微专业福利期-异步编程-3.1-理解异步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.同步与异步<br>&lt;!–<br>+new Date() 会调用Date.prototype 上面的 valueOf方法，根据<br>MDN：developer.mozilla.org/en-US/docs/…</p>
<p>new Date().getTime() === new Date().valueOf() //true</p>
<p>下面的例子返回效果等同：</p>
<p>+new Date();<br>new Date().getTime();<br>new Date().valueOf();<br>new Date()*1复制代码<br>转载于:<a href="https://juejin.im/post/5cd23b7bf265da03ab233f88" target="_blank" rel="noopener">https://juejin.im/post/5cd23b7bf265da03ab233f88</a><br>–&gt;<br>代码一：</p>
<p><pre><br>const test = ()=&gt;{<br>    let t = +new Date();<br>    while(true){<br>        if(+new Date() - t &gt;=2000){<br>            console.log(4)<br>            break;<br>        }<br>    }<br>}<br>console.log(1);<br>test();<br>console.log(2);<br>console.log(3);<br></pre><br>执行结果为先打印1，两秒之后打印4，接着马上打印2 3<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_1.png"><br>代码二：</p>
<p><pre><br>console.log(1);<br>setTimeout(()=&gt;{<br>    console.log(2);<br>},2000);<br>console.log(3);<br></pre><br>执行结果为先打印1 3，两秒后打印2<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_2.png"><br>代码一是我们所说的同步代码，代码二是我们所说的异步代码<br>同步：调用之后得到结果再做别的任务<br>异步：调用之后先不管结果继续做别的任务<br>我们先来了解一下进程与线程<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_3.png"><br>查看进程的常用命令，在Linux中为ps，是process status的缩写，可以查看进程的状态；还有一个命令是top，是top of processes的缩写，这个命令可以查看动态进程的变化<br>2.JavaScript单线程<br>js是单线程的，怎么实现异步？通过浏览器内核多线程实现异步<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_4.png"><br>下面这个图片简单描述了每个线程的作用<br>GUI线程：是渲染页面，html/css解析，构建DOM树/渲染树<br>js引擎线程：我们常听到的chrome V8就是一个js引擎，js引擎就是跑在js引擎线程，js引擎线程只有一个，也就是我们常说的js是单线程语言的原因。语言本身是没有单线程和多线程之说的，只是解释这个语言的线程是单线程还是多线程。js引擎也可以操作DOM，如果js引擎线程和GUI线程同时操作DOM会引起混乱，不知道以哪个线程为准。js引擎线程和GUI线程互斥，如果js操作的时间过长，页面的渲染就会受到影响，所以我们要控制js文件的大小，不要让js执行的时间过长。<br>定时触发器线程：在我们上面代码二中，为什么setTimeout没有阻塞console.log(3)，因为setTimeout是由定时触发线程完成的，不是js引擎线程完成的，所以是可以setTimeout和console是可以同时进行的。定时器触发线程会在定时任务完成后通知事件触发线程往任务队列中添加事件。<br>事件触发线程：将满足触发条件的事件放入任务队列，事件队列将会在event loop章节讲解，一些异步事件会放到任务队列中。<br>异步HTTP请求线程：用于处理ajax请求线程，当请求完成时如果有回调函数就会通知事件触发线程往任务队列中添加事件<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_5.png"><br>关于线程先讲到这里，下面是有哪些异步场景<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_6.png"><br>3.定时器<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_7.png"><br>(1).主线程有一个执行栈，代码是在执行栈中执行，首先是调用webAPI(webAPI可以理解为浏览器提供的一种能力，setTimeout就是一种webAPI)<br>(2).调用setTimeout定时器线程计数2s<br>(3).定时器线程计数2s这个任务结束之后，会通知事件触发线程。事件触发线程将定时器事件放入任务队列<br>(4).主线程通过EventLoop遍历任务队列(EventLoop是一个循环，主要是检查任务队列和主线程的调用栈)<br>下面通过一段代码来看一下定时器的执行过程<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_8.png"><br>定时器可能存在哪些问题：<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_9.png"></p>
<p><pre><br>const test = ()=&gt;{<br>    let t = +new Date();<br>    while(true){<br>        if(+new Date() - t &gt;=5000){<br>            break;<br>        }<br>    }<br>}<br>setTimeout(()=&gt;{<br>    console.log(2)<br>},2000);<br>test();<br></pre><br>上面代码执行我们发现，5秒钟之后打印的2。经过前面内容的讲解我们知道，是因为在同步内容执行完成之后才执行的定时内容setTimeout，这就是定时器任务可能不会按时执行的一个例子了。<br>定时器应用场景：防抖/节流/倒计时/动画<br>这是一个经典的js执行问题，导致这个问题的原因是js没有块级作用域<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_10.png"><br>经过我们改造，打印了1到10<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_11.png"><br>还有一种达到我们预期的方法就是用es6的变量定义let，因为let是有块级作用域的<br><img src="https://snakexu.github.io/images/fuliqi/javascript/3.1_12.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/网易微专业福利期-异步编程-3-1-理解异步/" data-id="ckchm0rh0004o5ajhlvbp80c0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-VuePress项目实战-4-1-2-基本配置" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/网易微专业-VuePress项目实战-4-1-2-基本配置/" class="article-date">
  <time datetime="2020-03-26T08:24:08.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/网易微专业-VuePress项目实战-4-1-2-基本配置/">网易微专业-VuePress项目实战-4.1.2-基本配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/网易微专业-VuePress项目实战-4-1-2-基本配置/" data-id="ckchm0rcx001v5ajhkhegjxx2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-VuePress项目实战-4-1-1-设计-运行原理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/网易微专业-VuePress项目实战-4-1-1-设计-运行原理/" class="article-date">
  <time datetime="2020-03-26T06:57:08.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/网易微专业-VuePress项目实战-4-1-1-设计-运行原理/">网易微专业-VuePress项目实战-4.1.1-设计-运行原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.什么是VuePress<br><img src="https://snakexu.github.io/images/wangyi/VuePress/4.1.1_1.png"><br><img src="https://snakexu.github.io/images/wangyi/VuePress/4.1.1_2.png"><br>2.快速上手VuePress<br><img src="https://snakexu.github.io/images/wangyi/VuePress/4.1.1_3.png"><br><img src="https://snakexu.github.io/images/wangyi/VuePress/4.1.1_4.png"><br>2-1.新建项目想换主题<br><img src="https://snakexu.github.io/images/wangyi/VuePress/4.1.1_5.png"><br><img src="https://snakexu.github.io/images/wangyi/VuePress/4.1.1_6.png"><br>如何使用一个主题</p>
<p><pre><br>//.vuepress/config.js<br>module.exports = {<br>    theme:’vuepress-theme-xx’,<br>    themeConfig:{<br>        //…<br>    }<br>}<br></pre><br>3.VuePress主题<br>如何自定义一个主题<br><img src="https://snakexu.github.io/images/wangyi/VuePress/4.1.1_7.png"><br>上面是自定义一个主题的完整的目录结构<br>global-components：被自动注册为全局组件<br>components：vue组件存放的地方<br>layouts：本身是一个布局组件，是一个必须存在的目录结构，我们所有的页面将默认会使用layout.vue作为布局组件，对于那些匹配不到的，路由将会使用404.vue<br>styles：定义全局的样式/调色板<br>index.js：主题文件的入口文件<br><img src="https://snakexu.github.io/images/wangyi/VuePress/4.1.1_8.png"><br>老师用官网上介绍vuepress的模型讲述了vuepress，详情看官网 <a href="https://v1.vuepress.vuejs.org/zh/plugin/" target="_blank" rel="noopener">https://v1.vuepress.vuejs.org/zh/plugin/</a><br>4.插件<br>如何书写一个VuePress插件<br><img src="https://snakexu.github.io/images/wangyi/VuePress/4.1.1_9.png"><br>插件案例<br><img src="https://snakexu.github.io/images/wangyi/VuePress/4.1.1_10.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/网易微专业-VuePress项目实战-4-1-1-设计-运行原理/" data-id="ckchm0rd200205ajhofgzd97t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-VuePress项目实战-4-1-0-VuePress课程导学" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/网易微专业-VuePress项目实战-4-1-0-VuePress课程导学/" class="article-date">
  <time datetime="2020-03-26T06:46:05.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/网易微专业-VuePress项目实战-4-1-0-VuePress课程导学/">网易微专业-VuePress项目实战-4.1.0-VuePress课程导学</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.什么是VuePress<br>VuePress由两部分组成:<br>·第一部分是一个极简静态网站生成器，它包含由Vue驱动的主题系统和插件API<br>·第二部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持Vue及其子项目的文档需求</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/网易微专业-VuePress项目实战-4-1-0-VuePress课程导学/" data-id="ckchm0rcy001w5ajh0iby2si6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-MV-组件化开发React专题-React生态-2-4-1-实现React-下-state" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/20/网易微专业-MV-组件化开发React专题-React生态-2-4-1-实现React-下-state/" class="article-date">
  <time datetime="2020-03-20T03:10:26.000Z" itemprop="datePublished">2020-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/20/网易微专业-MV-组件化开发React专题-React生态-2-4-1-实现React-下-state/">网易微专业-MV-组件化开发React专题-React生态-2.4.1-实现React(下)-state</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre>
import React from 'react'
import ReactDOM from 'react-dom'
class  App extends React.Component{
    constructor(props) {
        super(props);
        this.state = {
          num: 1,
        }
    }
    add(){
        this.setState({num:3})
        this.setState({num:4})
        this.setState({num:5})
        this.setState({num:8})
    }
    render() {
        console.log("hello")
        return (
            < div>
            hello world {this.state.num} < button onClick={e => {
            this.add()
            } }>add< /button>
            < /div>
        );
    }
}
ReactDOM.render(< App/>,document.getElementById('root'))
</pre>
看到上面的代码，在add中我们执行了四次setState，按照我们之前的理解，render的console.log('hello')会执行四次，但是实际上只执行了一次。
<img src="https://snakexu.github.io/images/wangyi/react/2.4.2_1.png">
<img src="https://snakexu.github.io/images/wangyi/react/2.4.2_2.png">
在我们过去的理解中，当调用setState进行调用的时候，页面就会进行重绘，这里视图只重绘了一次，所以我们发现react的setState不会立即执行，而是把这些状态推到一个队列中去，在一定的时间之后才会执行，把队列里所有的数据做一次性处理。
这里还有一个地方就是setState可以传入一个数据也可以传入一个函数
<pre>
import React from 'react'
import ReactDOM from 'react-dom'
class  App extends React.Component{
    constructor(props) {
        super(props);
        this.state = {
          num: 1,
        }
    }
    add(){
        this.setState({num:3})
        this.setState(function(preState){
            return {
                num : preState.num * 2
            }
        })
    }
    render() {
        console.log("hello")
        return (
            < div>
            hello world {this.state.num} < button onClick={e => {
            this.add()
            } }>add< /button>
            < /div>
        );
    }
}
ReactDOM.render(< App/>,document.getElementById('root'))
</pre>
下面我们实现react数据队列的更新。
react-index.js
<pre>
import setAttribute from './setAttribute'
let setStateQueue = []//定义一个队列，当前变化的组件
let renderQueue = []//页面上需要重绘的所有队列
// reRender 只在 队列的最后，执行一次
function defer( fn ) {
    return Promise.resolve().then( fn );
}
// APp demo setState
function enqueueSetState(stateChange, component) {
    //stateChange描述新状态的一个参数，component组件
    if(setStateQueue.length === 0){ 
        defer(reRender)//这里是一个小技巧，当前同步队列执行完毕之后开始执行reRender
    }
    setStateQueue.push({
        stateChange,
        component
    })
    if(!renderQueue.some(item => item === component)) {
        renderQueue.push(component)
    }
}
function reRender(){
    let item,component
    while(item = setStateQueue.shift()){
        const {stateChange,component} = item;
        if(!component.prevState){
            component.prevState = Object.assign({},component.state)
        }
        if(typeof stateChange === 'function'){
            Object.assign(component.state,stateChange(component.prevState))
        }else{
            Object.assign(component.state,stateChange)
        }
        component.prevState = component.state//stateChange可能是函数
    }
    while(component = renderQueue.shift()){
        renderComponent(component)
    }
}
function createElement( tag, attrs, ...children ) {
  return {
    tag,
    attrs,
    children
  }
}
function render( vnode, container ) {
  return container.appendChild( _render( vnode ) );
}
function _render( vnode ) {
  if ( vnode === undefined || vnode === null || typeof vnode === 'boolean' ) vnode = '';
  if ( typeof vnode === 'number' ) vnode = String( vnode );
  if ( typeof vnode === 'string' ) {
    let textNode = document.createTextNode( vnode );
    return textNode;
  }
  if ( typeof vnode.tag === 'function' ) {
    const component = createComponent( vnode.tag, vnode.attrs );
    setComponentProps( component, vnode.attrs );
    return component.base;
  }
  const dom = document.createElement( vnode.tag );
  if ( vnode.attrs ) {
    Object.keys( vnode.attrs ).forEach( key => {
      const value = vnode.attrs[ key ];
      setAttribute( dom, key, value );
    } );
  }
  vnode.children.forEach( child => render( child, dom ) );    // 递归渲染子节点
  return dom;
}

class Component {
  constructor( props = {} ) {
    this.state = {};
    this.props = props;
  }
  setState( stateChange ) {
    // 将修改合并到state
    // Object.assign( this.state, stateChange );
    // renderComponent( this );
    enqueueSetState( stateChange, this );
  }
}
function createComponent( component, props ) {
  let inst;
  // 如果是类定义组件，则直接返回实例
  if ( component.prototype && component.prototype.render ) {
    inst = new component( props );
    // 如果是函数定义组件，则将其扩展为类定义组件
  } else {
    inst = new Component( props );
    inst.constructor = component;
    inst.render = function() {
      return this.constructor( props );
    }
  }
  return inst;
}
function setComponentProps( component, props ) {
  if ( !component.base ) {
    if ( component.componentWillMount ) component.componentWillMount();
  } else if ( component.componentWillReceiveProps ) {
    component.componentWillReceiveProps( props );
  }
  component.props = props;
  renderComponent( component );
}
export function renderComponent( component ) {
  let base;
  const renderer = component.render();
  if ( component.base && component.componentWillUpdate ) {
    component.componentWillUpdate();
  }
  base = _render( renderer );
  if ( component.base ) {
    if ( component.componentDidUpdate ) component.componentDidUpdate();
  } else if ( component.componentDidMount ) {
    component.componentDidMount();
  }
  if ( component.base && component.base.parentNode ) {
    component.base.parentNode.replaceChild( base, component.base );
  }
  component.base = base;
  base._component = component;

}
export const React = {
  createElement,
  Component
}
export const ReactDOM = {
  render: ( vnode, container ) => {
    container.innerHTML = '';
    return render( vnode, container );
  }
}
export const tool = {
  renderComponent
}
</pre>
react.js
<pre>
import {React} from './react-index'
export default React
</pre>
react-dom.js
<pre>
import {ReactDOM} from './react-index'
export default ReactDOM
</pre>
index.js
<pre>
import React from './react';
import ReactDOM from './react-dom';
class  App extends React.Component{
    constructor(props) {
        super(props);
        this.state = {
          num: 1,
        }
    }
    add(){
        this.setState({num:3})
        this.setState({num:4})
        this.setState(function(preState){
             console.log(preState.num)
             return {
                 num : preState.num * 2
             }
        })
        this.setState(function(preState){
             console.log(preState.num)
             return {
                 num : preState.num * 2
             }
        })
    }
    render() {
        console.log("hello")
        return (
            < div>
            hello world {this.state.num} < button onClick={e => {
            this.add()
            } }>add< /button>
            < /div>
        );
    }
}
ReactDOM.render(< App/>,document.getElementById('root'))
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/20/网易微专业-MV-组件化开发React专题-React生态-2-4-1-实现React-下-state/" data-id="ckchm0rcn001f5ajhm084p63q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易微专业-MV-组件化开发React专题-React生态-2-4-1-实现React" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/18/网易微专业-MV-组件化开发React专题-React生态-2-4-1-实现React/" class="article-date">
  <time datetime="2020-03-18T07:54:35.000Z" itemprop="datePublished">2020-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/18/网易微专业-MV-组件化开发React专题-React生态-2-4-1-实现React/">网易微专业-MV-组件化开发React专题-React生态-2.4.1-实现React</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因为这节课程没有给代码，所以不是太能猜测出来项目初始化都安装了什么依赖，就搜索了一下如何模拟react，搜索到这个 <a href="https://segmentfault.com/a/1190000019994139" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019994139</a> ，个人觉得还不错，先放到这里<br>1.</p>
<p><pre><br>function createElement(tag,attrs,…children){<br>    return {<br>        tag,<br>        attrs,<br>        children<br>    }<br>}<br>const React = {<br>    createElement<br>}<br>let vnode = {<br>    &lt; div&gt;<br>        actions<br>        &lt; span&gt;aa&lt; /span&gt;<br>        &lt; p&gt;bb&lt; /p&gt;<br>    &lt; /div&gt;<br>}<br>console.log(vnode)<br></pre><br>上面代码中我们并没有调用createElement这个函数，可是为什么会生效？原因是虚拟dom会自动传入这个函数中，我们通过实现createElement方法来实现react，控制台打印结果如下<br><img src="https://snakexu.github.io/images/wangyi/react/2.4.1_1.png"><br>打印出来的数据结构已经和react的很类似了，如果我们想通过ReactDOM.render(vnode,document.getElementById(‘root’))渲染到页面上，我们就需要完善ReactDOM</p>
<p><pre><br>function createElement(tag,attrs,…children){<br>    return {<br>        tag,<br>        attrs,<br>        children<br>    }<br>}<br>function render(vnode,container){<br>    container.appendChild(_render(vnode));//把树形结构转换为真实DOM<br>}<br>function _render(vnode){<br>    //我们从之前的控制台打印可以看出vnode有多种形式，所以这里做一下判断<br>    if( vnode === undefined || vnode === null || typeof vnode === ‘boolean’ ) vnode =’’<br>    if( typeof vnode === ‘number’ ) vnode = String(vnode)<br>    if( typeof vnode === ‘string’ ){<br>        let textNode = document.createElement(vnode);<br>        return textNode<br>    }<br>    const dom = document.createElement(vnode.tag)<br>    vnode.children.forEach(child=&gt;{<br>        render(child,dom)//渲染子节点<br>    })<br>    return dom<br>}<br>const React = {<br>    createElement<br>}<br>const ReactDOM = {<br>    render(vnode,container)<br>}<br>let vnode = {<br>    &lt; div&gt;<br>        actions<br>        &lt; span&gt;aa&lt; /span&gt;<br>        &lt; p&gt;bb&lt; /p&gt;<br>    &lt; /div&gt;<br>}<br>ReactDOM.render(vnode,document.getElementById(‘root’))<br></pre><br><img src="https://snakexu.github.io/images/wangyi/react/2.4.1_2.png"><br>这时候已经能把虚拟dom渲染到页面上了，下面我们想渲染一个组件。</p>
<p><pre><br>function setAttribute(dom,name,value){<br>    //如果属性名称是className，则改为class<br>    if(name === ‘className’) name=’class’;<br>    //如果属性名是onXXX，则是一个事件监听方法<br>    if(/on\w+/.test(name)){<br>        name = name.toLowerCase();<br>        dom[name] = value || ‘’;<br>        //如果属性名是style，则更新style对象<br>    }else if(name === ‘style’){<br>        if(!value || typeof value === ‘string’){<br>            dom.style.cssText = value || ‘’<br>        }else if( value &amp;&amp; typeof value === ‘object’){<br>            for(let name in value){<br>                //可以通过style={widht:20}这种形式来设置样式，可以省略掉单位px<br>                dom.style[name] = typeof value[name] === ‘number’ ? value[name] + ‘px’ : value[name]<br>            }<br>        }<br>        //普通属性则直接更新属性<br>    }else{<br>        if(name in dom){<br>            dom[name] = value || ‘’<br>        }<br>        if(value){<br>            dom.setAttribute(name,value)<br>        }else{<br>            dom.removeAttribute(name)<br>        }<br>    }<br>}<br>function createElement(tag,attrs,…children){<br>    return {<br>        tag,<br>        attrs,<br>        children<br>    }<br>}<br>function render(vnode,container){<br>    container.appendChild(_render(vnode));<br>}<br>function _render(vnode){<br>    if( vnode === undefined || vnode === null || typeof vnode === ‘boolean’ ) vnode =’’<br>    if( typeof vnode === ‘number’ ) vnode = String(vnode)<br>    if( typeof vnode === ‘string’ ){<br>        let textNode = document.createTextNode(vnode);<br>        return textNode<br>    }<br>    if( typeof vnode.tag === ‘function’){<br>        const component = createComponent(vnode.tag,vnode.attrs)//返回一个实例化组件<br>        setComponentProps(component,vnode.attrs)//更新属性，生命周期<br>        //为什么把创建组件和设置组件属性拆开？因为组件的属性在不断变化的时候会有componentreceiveprops这样一个过程，<br>        //在接收属性的时候一些相应的生命周期的方法需要触发<br>        return component.base<br>    }<br>    //console.log(typeof vnode.tag,vnode) //这行的控制台打印结果是下面的2.4.1_3<br>    const dom = document.createElement(vnode.tag)<br>    if(vnode.attrs){<br>        Object.keys(vnode.attrs).forEach(key=&gt;{<br>            const value = vnode.attrs[key]<br>            setAttribute(dom,key,value)<br>        })<br>    }<br>    vnode.children.forEach(child=&gt;{<br>        render(child,dom)//渲染子节点<br>    })<br>    return dom<br>}<br>function createComponent(component,props){<br>    console.log(component)<br>    console.log(new component(props))<br>    console.log(props)<br>    return new component(props)<br>}<br>function setComponentProps(component,props){<br>    //组件属性的变化的触发<br>    if(!component.base){<br>        //如果组件已经被创建<br>        if(component.componentWillMount){<br>            component.componentWillMount()<br>        }else if(component.componentWillReceiveProps){<br>            component.componentWillReceiveProps(props)<br>        }<br>    }<br>    component.props = props   //组件属性的变化的触发<br>    renderComponent(component)//组件的重绘<br>}<br>function renderComponent(component){<br>    let base;<br>    console.log(component)<br>    const renderer = component.render()//返回的是树状结构<br>    //判断组件是否被挂载到页面上<br>    if(component.base &amp;&amp; component.componentWillUpdate){<br>        component.componentWillUpdate();<br>    }<br>    base = _render(renderer)//base 当前虚拟dom转化成的真实dom<br>    if(component.base &amp;&amp; component.base.parentNode){<br>        //如果存在父节点，则把父节点替换成当前的dom结构<br>        component.base.parentNode.replaceChild(base,component.base)<br>    }<br>    component.base = base;<br>    base._component = component;<br>}<br>class Component{<br>    constructor(props){<br>        this.props = props<br>        this.state = {}<br>    }<br>    setState(stateChange){<br>        Object.assign(this.state,stateChange);//合并<br>        renderComponent(this)//组件重绘<br>    }<br>}<br>const React = {<br>    createElement,<br>    Component<br>}<br>const ReactDOM = {<br>    render(vnode,container){<br>        container.innerHtml = ‘’<br>        render(vnode,container)<br>    }<br>}<br>class Demo extends React.Component{<br>    state = {<br>        value:1<br>    }<br>    render(){<br>        return (<br>            &lt; div&gt;<br>                &lt; p&gt;{this.state.value}&lt; /p&gt;<br>                &lt; button onClick={(e)=&gt;{<br>                this.setState({value:2})<br>                }}&gt;aaa&lt; /button&gt;<br>                actions {this.props.name}<br>                &lt; span&gt;aa&lt; /span&gt;<br>                &lt; p&gt;bb&lt; /p&gt;<br>            &lt; /div&gt;<br>        )<br>    }<br>}<br>ReactDOM.render(&lt; Demo name=”aa”/&gt;,document.getElementById(‘root’))<br></pre><br><img src="https://snakexu.github.io/images/wangyi/react/2.4.1_3.png"><br><img src="https://snakexu.github.io/images/wangyi/react/2.4.1_4.png"><br><img src="https://snakexu.github.io/images/wangyi/react/2.4.1_5.png"><br>上面代码，我们的页面重绘是一个略粗暴的方法，整个页面dom的重绘，真实的react是有一个diff算法的；react的setState方法做了一个异步的优化，可以连续多次调用setState，可是最后在页面上只会调用执行一次，这里有一个优化项的操作。这些都是后面学习的内容。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/18/网易微专业-MV-组件化开发React专题-React生态-2-4-1-实现React/" data-id="ckchm0rd200215ajh6omrfvjo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/拉勾/">拉勾</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript新特性/">ECMAScript新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript异步编程/">JavaScript异步编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript语言/">TypeScript语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-babel/">react babel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程范式/">函数式编程范式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端路由/">前端路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信小程序/">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手写Promise源码/">手写Promise源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾/">拉勾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拉勾，自动化构建/">拉勾，自动化构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业/">网易微专业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-Flutter/">网易微专业 Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网易微专业-node/">网易微专业 node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECMAScript新特性/" style="font-size: 10px;">ECMAScript新特性</a> <a href="/tags/JavaScript异步编程/" style="font-size: 10px;">JavaScript异步编程</a> <a href="/tags/TypeScript语言/" style="font-size: 10px;">TypeScript语言</a> <a href="/tags/react-babel/" style="font-size: 10px;">react babel</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/函数式编程范式/" style="font-size: 10px;">函数式编程范式</a> <a href="/tags/前端路由/" style="font-size: 10px;">前端路由</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/手写Promise源码/" style="font-size: 10px;">手写Promise源码</a> <a href="/tags/拉勾/" style="font-size: 20px;">拉勾</a> <a href="/tags/拉勾，自动化构建/" style="font-size: 10px;">拉勾，自动化构建</a> <a href="/tags/数据结构/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 17.5px;">算法</a> <a href="/tags/网易微专业/" style="font-size: 10px;">网易微专业</a> <a href="/tags/网易微专业-Flutter/" style="font-size: 10px;">网易微专业 Flutter</a> <a href="/tags/网易微专业-node/" style="font-size: 10px;">网易微专业 node</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/08/拉勾-自动化构建/">拉勾-自动化构建</a>
          </li>
        
          <li>
            <a href="/2020/07/03/拉勾-脚手架工具/">拉勾-脚手架工具</a>
          </li>
        
          <li>
            <a href="/2020/07/03/拉勾-工程化概述/">拉勾-工程化概述</a>
          </li>
        
          <li>
            <a href="/2020/06/28/拉勾-JavaScript性能优化/">拉勾-JavaScript性能优化</a>
          </li>
        
          <li>
            <a href="/2020/06/26/拉勾-TypeScript语言/">拉勾-TypeScript语言</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 snakeXu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>